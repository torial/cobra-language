class Stmt
	is abstract, partial
	inherits SyntaxNode

	var _parent as INode?
	
	def init(token as IToken)
		base.init(token)

	pro parent from var
		"""
		The node that the statement belongs to. This is being set on an as-needed basis.
		Typical needs are for error checking, but could also include other purposes such as code generation.
		The common place to set a node's `parent` is in the `_bindImp` of the parent 
		"""
		
	get lastToken as IToken
		return .token

	def afterParserRecognizesStatement
		pass

	def afterStatementBindImp
		"""
		Invoked to let expressions know when they are used as statements. This default
		implementation does nothing. Invoked by OneBlockCodeMember and BlockStmt.
		"""
		pass

	def noAssignmentAllowed(expr as Expr)
		"""
		Utility method for IfStmt and WhileStmt which do not allow assignment in
		their expressions.
		"""
		if expr inherits BinaryOpExpr
			if expr.op=='ASSIGN'
				.throwError('Cannot make an assignment in a flow control expression. Change to == or make the assignment just above.')
			else if expr.op=='BANG_EQUALS'
				.throwError('Cannot use an augmented assignment in a flow control expression. "a != b" means "a = a ! b" where "!" is an operator concerning nil. If you meant "does not equal" then use "<>".')
			else if expr.op.endsWith('_EQUALS')
				.throwError('Cannot use an augmented assignment in a flow control expression. Change to == or make the assignment just above.')

	def bindVar(ve as NameExpr) as IVar
		"""
		Computes the _var from the _varExpr which is either IdentifierExpr or AsExpr.
		May call `_error` and `inferredType` as needed.
		Typical use: _var = .bindVar(_varExpr)
		"""
		# TODO: would prefer to do this as a mixin with two class vars:
		# var _varExpr as NameExpr
		# var _var as IVar?
		varr as IVar?
		if ve inherits IdentifierExpr
			# find or infer
			definition as INamedNode?
			canBeUndottedMember = .compiler.canNameBeUndottedMember(ve.name)
			usingExistingLocal = false
			if canBeUndottedMember
				assert .compiler.boxStack.count
				definition = .compiler.symbolForName(ve.name, canBeUndottedMember, false) to passthrough
				if definition is nil
					ve.throwUnknownIdError
			else
				definition = .compiler.findLocal(ve.name)
				# infer a local var
				it = .inferredType
				if it is nil
					.throwError('Cannot infer the type for "[ve.name]" from the "for" loop.')				
				if definition is nil
					definition = LocalVar(ve.token, it).bindAll to INamedNode  # CC: axe cast after "as this"
					.compiler.curCodeMember.addLocal(definition to LocalVar)
				else
					# using an existing local. that's fine as long as the types are the name
					usingExistingLocal = true
			if definition inherits IVar
				varr = definition
				if usingExistingLocal
					ve.bindImp  # can't do this at the beginning of this method as it interferes with type inference. but here, it's an existing var so no "Unknown identifier" error will occur
					assert definition.type
					if definition.type is .compiler.passThroughType
						varr.type = definition.type
					else if not it.isAssignableTo(definition.type to !)
						.throwError('Cannot redeclare "[ve.name]" as "[it.name]" because it was declared as "[definition.type.name]" earlier.') # TODO: would be nice to give the location of the other declaration				
			else
				.throwError('The definition of "[ve.name]" is not a variable which is what the "for" loop requires.')
			ve.bindImp
		else if ve inherits AsExpr
			ve.bindImp
			assert ve.definition
			varr = ve.definition to AbstractLocalVar
		else
			throw FallThroughException(ve)
		return varr to !

	def inferredType as IType?
		"""
		Used by .bindVar so that the subclasses can implement their inferred type logic.
		"""
		return nil

	var _canSetLine as bool

	def bindImp as dynamic is override
		# CC: and ensure result inherits Stmt
		return base.bindImp
		
	def _bindImp
		base._bindImp
		_canSetLine = .compiler.willTrackLocals
		# note that the code member stack can be empty because of class vars (ex: var _foo = true)
		# even the box stack can be empty because of assembly; has ...


class AssertStmt
	is partial
	inherits Stmt

	var _expr as Expr
	var _info as Expr?

	def init(token as IToken, expr as Expr, info as Expr?)
		base.init(token)
		_expr = TruthExpr(expr)
		_info = info

	def addSubFields
		base.addSubFields
		.addField('expr', _expr)
		.addField('info', _info)

	get expr from var

	get info from var

	def _bindImp
		base._bindImp
		_expr.bindImp
		e = _expr
		if e.willChangeVar
			if e inherits TruthExpr
				e = e.expr
			if e inherits AbstractAssignExpr
				# TODO: should also cover any assignment expressions anywhere inside the expression
				.throwError('Assert condition is an assignment. Since asserts may be suppressed these conditions should not have side effects. Perhaps you meant to do a comparison "==" instead of assignment "=".')
			else
				.throwError('Condition has a side effect. Since asserts may be suppressed at compile-time or run-time, their conditions cannot have side effects.')
		# Augment any warning about non nilable expr evaluate to true
		.compiler.augmentWarning(this, 'always evaluate to true because it is not nilable', _
			'You can remove the expression', _
			'This assertion is always true. You can remove the assertion or correct the condition')
		if _info, _info.bindImp


class CompileTimeTraceStmt
	inherits Stmt

	var _expr as Expr
	
	def init(token as IToken, expr as Expr)
		base.init(token)
		_expr = expr

	def addSubFields
		base.addSubFields
		.addField('expr', _expr)

	get expr from var

	def _bindImp
		base._bindImp
		expr = _expr
		# this output will likely need to be done as warning output so it works with IDEs
		prefix = '    -'
		print 'Compile-time trace at [.token.toTechString]'
		print '[prefix] before bind imp on expression: [expr.toCobraSource] = [expr]'
		expr.bindImp
		print '[prefix] after bind imp on expression:  [expr.toCobraSource] = [expr]'
		dexpr = expr to dynamic
		try
			defi = dexpr.definition
			if defi, print '    - definition = [defi]'
		catch DynamicOperationException
			print '[prefix] no definition'
		try
			type = dexpr.type
			if type, print '    - type = [type]'
		catch DynamicOperationException
			print '[prefix] no type'

	# no writeSharpDef for a compile-time trace


class BranchStmt
	is partial
	inherits Stmt

	var _expr as Expr
	var _onParts as List<of BranchOnPart>
	var _elsePart as BlockStmt?

	def init(token as IToken, expr as Expr, onParts as List<of BranchOnPart>, elsePart as BlockStmt?)
		base.init(token)
		_expr = expr
		_onParts = onParts
		_elsePart = elsePart

	def addSubFields
		base.addSubFields
		.addField('expr', _expr)
		.addField('onParts', _onParts)
		.addField('elsePart', _elsePart)

	def _bindImp
		base._bindImp
		_expr.bindImp
		for bop in _onParts, bop.bindImp
		if _elsePart, _elsePart.bindImp


class BranchOnPart
	inherits Node

	var _exprs as List<of Expr>
	var _block as BlockStmt

	def init(exprs as List<of Expr>, block as BlockStmt)
		base.init
		_exprs = exprs
		_block = block

	def addSubFields
		base.addSubFields
		.addField('exprs', _exprs)
		.addField('block', _block)

	get block from var

	get exprs from var
		has Subnodes

	def _bindImp
		base._bindImp
		for expr in _exprs, expr.bindImp
		_block.bindImp


class BlockStmt
	is partial
	inherits Stmt
	"""
	A BlockStmt holds a series of statements which are the target of complex statement such
	if, while, etc. BlockStmts are *not* the target of a method or property.
	"""

	var _stmts as List<of Stmt>
	var _ifInheritsVar as IVar?
	var _ifInheritsType as IType?
	var _curStmtIndex as int  # to implement .replaceChild

	def init(token as IToken, stmts as List<of Stmt>)
		base.init(token)
		_stmts = stmts

	get lastToken as IToken
		return if(_stmts.count, _stmts[_stmts.count-1].lastToken, base.lastToken)

	def addSubFields
		base.addSubFields
		.addField('stmts', _stmts)

	def setIfInherits(varr as IVar, type as IType)
		_ifInheritsVar = varr
		_ifInheritsType = type

	get stmts from var
		has Subnodes

	def replaceChild(find as INode, replace as INode) as bool
		# using _curStmtIndex is faster and blocks can get potentially large
		if _curStmtIndex < _stmts.count and _stmts[_curStmtIndex] is find
			_stmts[_curStmtIndex] = replace to Stmt
			return true
		else
			return base.replaceChild(find, replace)

	def _bindImp
		base._bindImp
		_curStmtIndex = 0
		for stmt in _stmts.toArray
			stmt.parent = this
			try
				stmt.bindImp
				stmt.afterStatementBindImp  # to let expressions know when they are used as statements
			catch ne as NodeException
				.compiler.recordError(ne)
			_curStmtIndex += 1


class BreakStmt
	is partial
	inherits Stmt

	def init(tok as IToken)
		base.init(tok)


class ContinueStmt
	is partial
	inherits Stmt

	def init(tok as IToken)
		base.init(tok)


class ExpectStmt
	is partial
	inherits Stmt

	var _exceptionTypeNode as ITypeProxy
	var _exceptionType as IType?
	var _block as BlockStmt
	var _varNumber as int

	def init(token as IToken, exceptionTypeNode as ITypeProxy, block as BlockStmt)
		base.init(token)
		_exceptionTypeNode = exceptionTypeNode
		_block = block

	get lastToken as IToken is override
		return _block.lastToken

	def addSubFields
		base.addSubFields
		.addField('exceptionTypeNode', _exceptionTypeNode)
		.addField('exceptionType', _exceptionType)
		.addField('block', _block)

	def _bindImp
		base._bindImp
		if _exceptionType is nil
			_exceptionType = (_exceptionTypeNode.bindAll to ITypeProxy).realType  # CC: axe cast
		assert _exceptionType, this
		excClass = .compiler.exceptionType
		if not _exceptionType.isDescendantOf(excClass)
			.throwError('Can only use Exception and its descendants for "expect". "[_exceptionType.name]" does not inherit the Exception class.')
		.compiler.curBox.makeNextPrivateSerialNumber  # `writeSharpDef` uses two serial nums
		_varNumber = .compiler.curBox.makeNextPrivateSerialNumber
		_block.bindImp


class ForStmt
	is partial
	inherits Stmt
	"""
	Abstract base class for ForNumericStmt and ForEnumerablebase.
	"""

	var _varExpr as NameExpr
	var _var as IVar?
	var _block as BlockStmt

	def init(token as IToken, varr as NameExpr, block as BlockStmt)
		base.init(token)
		_varExpr = varr
		_block = block

	get varExpr from var
	
	get var from var
	
	get block from var
	
	get lastToken as IToken is override
		return _block.lastToken

	def addSubFields
		base.addSubFields
		.addField('varExpr', _varExpr)
		.addField('var', _var)
		.addField('block', _block)

	def _bindImp
		base._bindImp
		_varExpr.bindImp
		if _varExpr.definition
			if _varExpr.definition inherits IVar
				_var = _varExpr.definition to IVar
			else
				.throwError('Expecting a variable not a [_varExpr.definition.getType.name].')  # TODO: what's the best way to report what was found?
		else
			assert _varExpr.hasError
		#if not var.isTracked  TODO disabled this to get tests\200-classes\804-test.cobra working.
		if false
			varr = .var
			existingVar = .compiler.curCodeMember.findLocal(varr.name)
			if existingVar
				# that's fine as long as the types are the name
				if varr.type is .compiler.passThroughType
					varr.type = existingVar.type
				else if existingVar.type is not varr.type
					.throwError('Cannot redeclare "[varr.name]" as "[varr.type]" because it was declared as "[existingVar.type]" earlier.') # TODO: would be nice to give the location of the other declaration
			
# TODO: check for existing  variables
#		if 1
#			ns = .compiler.nameSpaceStack.peek
#			existingVar = ns.findLocal(varr.name)
#			if existingVar
#				# that's fine as long as the types are the name
#				if varr.type is .compiler.passThroughType
#					varr.type = existingVar.type
#				else if existingVar.type is not varr.type
#					.error('Cannot redeclare "[varr.name]" as "[varr.type]" because it was declared as "[existingVar.type]" earlier.')
#			else
#				.compiler.nameStack.peek.pushName(varr)   # TODO should be pushSymbol() or pushVar()
#		varr.bindAll  # CallExpr() wants its definition to have bound int, so here we call bindAll instead of bindImp
		_block.bindImp
		# TODO axe this
		#if not varr.isTracked
		#	.compiler.nameStack.peek.pop   # TODO should be popSymbol() or popVar()


class OldForNumericStmt
	is partial
	inherits ForStmt

	var _start as Expr
	var _stop as Expr
	var _dir as int
	var _step as Expr?

	def init(token as IToken, varr as NameExpr, start as Expr, stopp as Expr, dir as int, stepp as Expr?, block as BlockStmt)
		require
			dir==-1 or dir==+1
		body
			base.init(token, varr, block)
			_start = start
			_stop = stopp
			_dir = dir
			_step = stepp

	def addSubFields
		base.addSubFields
		.addField('start', _start)
		.addField('stop', _stop)
		.addField('dir', _dir)
		.addField('step', _step)
		.addField('block', _block)

	def _bindImp
		_start.bindImp
		_stop.bindImp
		if _step
			_step.bindImp
		_var = .bindVar(_varExpr)
		base._bindImp
		_block.bindImp

	def inferredType as IType? is override
		return _start.type.greatestCommonDenominatorWith(_stop.type to !)


class ForNumericStmt
	is partial
	inherits ForStmt

	var _start as Expr
	var _stop as Expr
	var _dir as int
	var _step as Expr?

	def init(token as IToken, varr as NameExpr, start as Expr, stopp as Expr, dir as int, stepp as Expr?, block as BlockStmt)
		require
			dir in [-1, 0, +1]  # 0 is for current syntax. -1 and +1 are for old "for x = 0 .. n ++ 2" syntax
		body
			base.init(token, varr, block)
			_start = start
			_stop = stopp
			_dir = dir
			_step = stepp

	def addSubFields
		base.addSubFields
		.addField('start', _start)
		.addField('stop', _stop)
		.addField('dir', _dir)
		.addField('step', _step)
		.addField('block', _block)

	get start from var
	
	get stop from var
	
	get step from var
	
	get dir from var
	
	def _bindImp
		_start.bindImp
		_stop.bindImp
		if _step
			_step.bindImp
		_var = .bindVar(_varExpr)
		base._bindImp
		_block.bindImp
		# optimization:
		if _dir == 0  # the value for: for x in start : stop : step
			if _step is nil
				_dir = +1
				_step = IntegerLit(.token.copy('INTEGER_LIT', '+1'), +1)
				_step.bindImp
			else if _step inherits IntegerLit
				_dir = if(_step.value < 0, -1, +1)

	def inferredType as IType? is override
		return _start.type.greatestCommonDenominatorWith(_stop.type to !)


class ForEnumerableStmt
	is partial
	inherits ForStmt

	var _what as Expr
	var _varNumber as int

	def init(token as IToken, varr as NameExpr, what as Expr, block as BlockStmt)
		base.init(token, varr, block)
		_what = what

	def addSubFields
		base.addSubFields
		.addField('_what', _what)
		.addField('_varNumber', _varNumber)

	get what from var
	
	get varNumber from var
	
	def _bindImp
		_what.bindImp
		if _what.type.isDynamic
			_what.contextType = .compiler.enumerableType
		if _what.type inherits AnyIntType
			# 'for x in 10' is a numeric for loop
			_transformTo(ForNumericStmt(.token, _varExpr, IntegerLit(.token.copy('INTEGER_LIT', '0'), 0), _what, 1, nil, _block).bindAll)
			base._bindImp  # just to pass the assertion that base._bindImp was invoked
		else
			_var = .bindVar(_varExpr)
			base._bindImp
			_varNumber = .compiler.curBox.makeNextPrivateSerialNumber
			_block.bindImp

	def inferredType as IType? is override
		assert _what.type
		return _what.type.innerType


class IfStmt
	is partial
	inherits Stmt

	var _cond as Expr
	var _trueStmts as BlockStmt
	var _falseStmts as BlockStmt?
	var _doNotPopIfInheritsStack as bool
	var _ifInheritsVar as IVar?

	def init(token as IToken, cond as Expr, trueStmts as BlockStmt, falseStmts as BlockStmt?)
		base.init(token)
		_cond = cond
		_trueStmts  = trueStmts
		_falseStmts = falseStmts

	get cond from var

	get ifInheritsVar from var

	get trueStmts from var
	
	get falseStmts from var
	
	get lastToken as IToken is override
		if _falseStmts
			return _falseStmts.lastToken
		else
			return _trueStmts.lastToken

	def addSubFields
		base.addSubFields
		.addField('cond', _cond)
		.addField('trueStmts', _trueStmts)
		.addField('falseStmts', _falseStmts)
		.addField('ifInheritsVar', _ifInheritsVar)

	def _bindImp
		base._bindImp
		try
			_cond.bindImp
		catch ne as NodeException
			.compiler.recordError(ne)
		success
			_doNotPopIfInheritsStack = false
			.noAssignmentAllowed(_cond)
			if _cond.type is not .compiler.boolType
				_cond = TruthExpr(_cond).bindImp to TruthExpr  # CC: axe cast when supporting 'as this'
			cond = _cond
			ifInherits = false
			# TODO: handle the "x inherits Y" being part of a sequence of "and"ed exprs
			# CC: combine some of the if statements below when "if inherits" can handle complex expressions
			if cond inherits InheritsExpr
				left = cond.left
				if left inherits IdentifierExpr
					leftVar = left.definition
					if leftVar inherits IVar  # if-inherits smarts only work on variables
						# if x inherits Y ...
						if (right = cond.right) inherits IPotentialTypeExpr
							assert right.potentialType
							leftVar.ifInheritsStack.push(right.potentialType to !)
						else
							throw FallThroughException(right)
						ifInherits = true
						_trueStmts.setIfInherits(leftVar, leftVar.ifInheritsStack.peek)
				else if left inherits AssignExpr
					if left.left inherits IdentifierExpr
						leftVar = (left.left to IdentifierExpr).definition
						if leftVar inherits IVar
							# if (x = expr) inherits Y ...
							if (right = cond.right) inherits IPotentialTypeExpr
								leftVar.ifInheritsStack.push(right.potentialType to !)
							else
								throw FallThroughException(right)
							ifInherits = true
							_trueStmts.setIfInherits(leftVar, leftVar.ifInheritsStack.peek)
			if not ifInherits
				# check for an if-not-nil
				if cond inherits TruthExpr
					if cond.expr inherits IdentifierExpr
						leftVar = (cond.expr to IdentifierExpr).definition
						leftType = leftVar.typeForIdentifier
						if leftType inherits NilableType or (leftType.isReference and leftType is not .compiler.objectType)
							# if x ...
							# Note: The check for .objectType just above is due to the fact that a type of Object can point to boxed values such as ints and bools which Cobra will treat properly at runtime.
							notNil = true
			# TODO: the checks about variables that are never nil (/always non-nil) need to happen at the *expression* level so they kick in for assert, require, etc.
			if not ifInherits and not notNil
				if cond inherits CompareExpr
					if cond.op in ['ISNOT', 'NE'] and cond.left inherits IdentifierExpr and cond.right inherits NilLiteral
						# if x is not nil ...
						# if x <> nil ...
						# TODO: also handle "if nil is not x"
						# TODO? "if not x is nil"  "if nil is not x"
						notNil = true
						leftVar = (cond.left to IdentifierExpr).definition
			if notNil
				if leftVar inherits IVar
					if leftVar.type inherits WrappedType
						leftVar.ifInheritsStack.push((leftVar.type to WrappedType).theWrappedType)
						ifInherits = true
				else
					throw FallThroughException(leftVar)
			if ifInherits
				if leftVar inherits IVar
					_trueStmts.setIfInherits(leftVar, leftVar.ifInheritsStack.peek)
				else
					throw FallThroughException(leftVar)
		if ifInherits
			if leftVar inherits IVar
				_ifInheritsVar = leftVar
				stackCount = leftVar.ifInheritsStack.count
			else
				assert false, leftVar
		_trueStmts.parent = this
		_trueStmts.bindImp
		if ifInherits
			if not _doNotPopIfInheritsStack
				(leftVar to IVar).ifInheritsStack.pop
			assert (leftVar to IVar).ifInheritsStack.count == stackCount - 1
			
		if _falseStmts
			_falseStmts.parent = this
			_falseStmts.bindImp

	def doNotPopIfInheritsStack
		_doNotPopIfInheritsStack = true


class ListenOrIgnoreStmt
	is abstract, partial
	inherits Stmt
	
	var _event as Expr?
	var _target as Expr?

	def init(token as IToken, eventRef as Expr, target as Expr)
		base.init(token)
		_event = eventRef
		_target = target

	def addSubFields
		base.addSubFields
		.addField('event', _event)
		.addField('target', _target)

	get event from var
	
	get target from var

	def _bindImp
		base._bindImp
		_event.bindImp
		_target.bindImp


class ListenStmt
	is partial
	inherits ListenOrIgnoreStmt

	def init(token as IToken, eventRef as Expr, target as Expr)
		base.init(token, eventRef, target)


class IgnoreStmt
	is partial
	inherits ListenOrIgnoreStmt

	def init(token as IToken, eventRef as Expr, target as Expr)
		base.init(token, eventRef, target)


class PassStmt
	is partial
	inherits Stmt
	
	def init(token as IToken)
		base.init(token)
		

class PrintStmt
	is partial
	inherits Stmt

	var _destination as Expr?
	var _args as List<of Expr>
	var _stop as bool

	def init(token as IToken, destination as Expr?, args as List<of Expr>, stopp as bool)
		base.init(token)
		_destination = destination
		_args = args
		_stop = stopp

	def _bindImp
		base._bindImp
		if _destination
			_destination.bindImp
		for arg in _args
			arg.bindImp

	def addSubFields
		base.addSubFields
		.addField('stop', _stop)
		.addField('destination', _destination)
		.addField('args', _args)

	get args from var
		has Subnodes


class PrintRedirectStmt
	is partial
	inherits Stmt

	var _destination as Expr
	var _block as BlockStmt

	def init(token as IToken, destination as Expr, block as BlockStmt)
		base.init(token)
		_destination = destination
		_block = block

	get lastToken as IToken is override
		return _block.lastToken

	def _bindImp
		base._bindImp
		_destination.bindImp
		_block.bindImp

	def addSubFields
		base.addSubFields
		.addField('destination', _destination)
		.addField('block', _block)


class RaiseStmt
	is partial
	inherits Stmt
	"""
	Raise an event.
	
	TODO: test raising an inherited event, either from source or from binary
	TODO: Test generic events.
	"""

	var _name = ''
	var _exprs as List<of Expr>

	# computed in _bindImp
	var _definition as BoxEvent?
	var _eventType as IType?
	var _params as List<of Param>?
	var _args as List<of Expr>?

	def init(token as IToken, exprs as List<of Expr>)
		require exprs.count > 0
		base.init(token)
		_exprs = exprs

	def addSubFields
		base.addSubFields
		.addField('exprs', _exprs)

	get name from var

	get exprs from var

	def _bindImp
		base._bindImp
		hasError = false
		for expr in _exprs
			try
				expr.bindImp
			catch ne as NodeException
				.compiler.recordError(ne)
				hasError = true
		if not hasError
			expr = _exprs[0]
			if expr inherits DotExpr
				right = expr.dotRight
				defi = (right to dynamic).definition
				if defi inherits BoxEvent
					_definition = defi
					_name = defi.name
					_eventType = defi.handlerType
				else
					.throwError('Expecting an event to raise.')
			else if expr inherits IdentifierExpr  # ex: raise _eventName
				_name = expr.name
				assert expr.potentialType
				_eventType = expr.potentialType
				if _eventType.isDescendantOf(.compiler.libraryType('System.Delegate')) or _eventType inherits MethodSig
					pass
				else if _eventType.isDescendantOf(.compiler.exceptionType)
					.throwError('Use "throw" instead of "raise" for the exception "[_eventType.name]".')
				else
					.throwError('Invalid expression for raising events. Try "raise .someEvent, args" or "throw SomeException(args)".')
			else
				.throwError('Invalid expression for raising events. Try "raise .someEvent, args" or "throw SomeException(args)".')
			if _eventType inherits MethodSig
				_params = _eventType.params
			else
				member = _eventType.memberForName('invoke')
				if member inherits Method
					_params = member.params
				else
					.throwError('Cannot find a single "invoke" method for "_eventType.name".')
			# TODO: check type compatibility of exprs with params
			args = _exprs[1:]
			params = _params
			unThis = 'Unnecessary "this" which is already implied by raising an event. You can remove it.'
			if args.count == params.count
				if args.count > 0 and args[0] inherits ThisLit
					.compiler.warning(this, unThis)
			else if args.count == params.count - 1
				# off by one.
				if args[0] inherits ThisLit
					.compiler.warning(this, unThis)
					# since we have 'this', try appending the args object
					args.add(_postCallForType(params[params.count-1].type))
				else
					# since we don't have 'this', try prepending 'this'
					args.insert(0, ThisLit(.token).bindImp)
			else if args.count == 0 and params.count == 2
				# missing both 'this' and event args
				args.add(ThisLit(.token).bindImp)
				args.add(_postCallForType(params[params.count-1].type))
			else
				.throwError('Event expects [params.count] arguments, but the "raise" statement is providing [args.count].')
			_args = args

	def _postCallForType(type as IType) as PostCallExpr		
		init = type.memberForName('init')
		good = false
		if init inherits Initializer
			if init.params.count == 0
				good = true
		else if init inherits MemberOverload
			for member in init.members
				if member.params.count == 0
					good = true
					break
		if good
			token = .token.copy('ID', type.name)
			return PostCallExpr(token, TypeExpr(token, type), List<of Expr>()).bindImp
		else
			.throwError('Missing argument for "raise" of type "[type.name]".')
		throw FallThroughException() # suppress an error


class ReturnStmt
	is partial
	inherits Stmt

	var _expr as Expr?

	def init(token as IToken, expr as Expr?)
		base.init(token)
		_expr = expr

	def addSubFields
		base.addSubFields
		.addField('expr', _expr)

	get expr from var

	def _bindImp
		base._bindImp
		expr = _expr
		curCodeMember = .compiler.codeMemberStack.peek
		if expr
			_expr.bindImp
			if not expr.canBeAssignedTo(curCodeMember.resultType)
				suffix = if(curCodeMember.resultType is .compiler.voidType, 'not declared to return anything.', 'declared to return a [curCodeMember.resultType.name].')
				.throwError('Cannot return [expr.type.name] because "[curCodeMember.name]" is [suffix]')
			_expr.contextType = curCodeMember.resultType
		else
			if curCodeMember.resultType is not .compiler.voidType
				.throwError('Return statement must return a [curCodeMember.resultType.name], or [curCodeMember.name] must have its return type removed.')
		curCodeMember.hasReturnStmt = true
		_sharpResultVarName = curCodeMember.sharpResultVarName


class TraceStmt
	is abstract, partial
	inherits Stmt

	var _codePart as AbstractMethod

	def init(token as IToken, codePart as AbstractMethod)
		base.init(token)
		_codePart = codePart

	def includeTraces as bool	
		return .compiler.options.boolValue('include-traces')


class TraceLocationStmt
	is partial
	inherits TraceStmt

	def init(token as IToken, codePart as AbstractMethod)
		base.init(token, codePart)


class TraceAllStmt
	is partial
	inherits TraceStmt

	def init(token as IToken, codePart as AbstractMethod)
		base.init(token, codePart)


class TraceExprsStmt
	is partial
	inherits TraceStmt

	var _exprs as List<of Expr>

	def init(token as IToken, codePart as AbstractMethod, exprs as List<of Expr>)
		base.init(token, codePart)
		_exprs = exprs

	get exprs from var
		has Subnodes

	def _bindImp
		base._bindImp
		for expr in _exprs
			expr.bindImp


class TryStmt
	is partial
	inherits Stmt

	var _tryBlock as BlockStmt
	var _catchBlocks as List<of CatchBlock>
	var _successBlock as BlockStmt?
	var _finallyBlock as BlockStmt?
	var _varNumber as int

	def init(token as IToken, tryBlock as BlockStmt, catchBlocks as List<of CatchBlock>, successBlock as BlockStmt?, finallyBlock as BlockStmt?)
		base.init(token)
		_tryBlock = tryBlock
		_catchBlocks = catchBlocks
		_successBlock = successBlock
		_finallyBlock = finallyBlock

	get lastToken as IToken is override
		if _finallyBlock
			return _finallyBlock.lastToken
		if _successBlock
			return _successBlock.lastToken
		if _catchBlocks.count
			return _catchBlocks[_catchBlocks.count-1].lastToken
		return _tryBlock.lastToken

	def addSubFields
		base.addSubFields
		.addField('tryBlock', _tryBlock)
		.addField('catchBlocks', _catchBlocks)
		.addField('succesBlock', _successBlock)
		.addField('finallyBlock', _finallyBlock)

	get catchBlocks from var
		has Subnodes

	def _bindImp
		base._bindImp
		_varNumber = .compiler.curBox.makeNextPrivateSerialNumber
		_tryBlock.bindImp
		for cb in _catchBlocks
			cb.bindImp
		if _successBlock
			_successBlock.bindImp
		if _finallyBlock
			_finallyBlock.bindImp
		# error check
		if _catchBlocks.count
			for stmt in _tryBlock.stmts
				if stmt inherits YieldStmt
					stmt.recordError('Cannot yield a value in the body of a try block with a catch clause.')
		# error check
		for cb in _catchBlocks
			for stmt in cb.block.stmts
				if stmt inherits YieldStmt
					stmt.recordError('Cannot yield a value in the body of a catch clause.')
		# error check
		if _finallyBlock
			for stmt in _finallyBlock.stmts
				if stmt inherits YieldStmt
					stmt.recordError('Cannot yield in the body of a finally clause.')


class CatchBlock
	is partial
	inherits SyntaxNode

	var _var as AbstractLocalVar?
	var _typeNode as ITypeProxy?
	var _type as IType?
	var _block as BlockStmt
	var _varName as String?

	def init(token as IToken, block as BlockStmt)
		"""
		This is for `success`, `finally` and typeless `catch` blocks.
		"""
		base.init(token)
		_block = block

	def init(token as IToken, varr as AbstractLocalVar, block as BlockStmt)
		"""
		This is for `catch` blocks that specify a type and variable.
		"""
		base.init(token)
		_var = varr
		_varName = varr.name
		_block = block

	def init(token as IToken, typeNode as ITypeProxy, block as BlockStmt)
		"""
		This is for `catch` blocks that specify a type, but no variable.
		"""
		base.init(token)
		_typeNode = typeNode
		_block = block

	get block from var

	get type from var

	get varName from var

	get lastToken as IToken
		return _block.lastToken

	def _bindImp
		base._bindImp
		if _var
			_var.bindImp
			# TODO: should this be using .bindVar like others?
			# TODO: wtf is isTracked again?
			if not _var.isTracked
				varr = _var to LocalVar  # CC: axe typecast
				codePart = .compiler.codeMemberStack.peek
				existingVar = codePart.findLocal(varr.name)
				if existingVar
					if existingVar.type is not varr.type
						.throwError('Cannot redeclare "[varr.name]" as "[varr.type.name]" because it was declared as "[existingVar.type.name]" earlier.')
				else
					codePart.addLocal(varr)
			if _type is nil
				_type = _var.type
				assert _type
		else if _typeNode
			_typeNode.bindImp
			_type = _typeNode.realType  # CC: combine with above: _type = _typeNode.bindImp.realType
		_sharpHelperName = '_lh_catch_[.compiler.curBox.makeNextPrivateSerialNumber]'
		_block.bindImp


class ThrowStmt
	is partial
	inherits Stmt

	var _expr as Expr?

	def init(token as IToken, expr as Expr?)
		base.init(token)
		_expr = expr

	def addSubFields
		base.addSubFields
		.addField('expr', '_expr')

	def _bindImp
		base._bindImp
		if _expr
			_expr.bindImp
			if not _expr.hasError
				exceptionType = .compiler.exceptionType
				typeType = .compiler.typeType
				if _expr.canBeAssignedTo(exceptionType)
					pass
				else if _expr.canBeAssignedTo(typeType)
					augment = ''
/#
					CC:
					if _expr responds to (get definition)
						defin = _expr.definition
						if defin responds to (def isDescendantOf(t as IType))
							augment = 'Try instantiating it with parentheses such as "[_expr.toCobraSource]()".'
#/
					try
						defin = (_expr to dynamic).definition
					catch UnknownMemberException
						defin = nil
					try
						if defin.isDescendantOf(exceptionType)
							augment = 'Try instantiating it with parentheses such as "[_expr.toCobraSource]()".'
					catch UnknownMemberException
						pass
					if augment == ''
						augment = 'Also, this type does not inherit from Exception.'
					.throwError('Cannot throw a type. [augment]')
				else
					try
						defin = (_expr to dynamic).definition
					catch UnknownMemberException
						defin = nil
					if defin inherits BoxEvent
						reason = 'it is an event, not an exception. Either throw an exception or use "raise" on the event instead of "throw"'
					else
						reason = 'it does not inherit from Exception'
					.throwError('Cannot throw "[_expr.type.name]" because [reason].')
		.compiler.curCodeMember.hasThrowStmt = true


class UsingStmt
	is partial
	inherits Stmt

	var _varExpr as NameExpr
	var _var as IVar?
	var _initExpr as Expr
	var _block as BlockStmt

	def init(token as IToken, varExpr as NameExpr, initExpr as Expr, block as BlockStmt)
		base.init(token)
		_varExpr = varExpr
		_initExpr = initExpr
		_block = block

	get lastToken as IToken is override
		return _block.lastToken

	def _bindImp
		base._bindImp
		_initExpr.bindImp
		_var = .bindVar(_varExpr)
		# TODO: add an error check that the var type and expr type are compatible
		_block.bindImp

	def inferredType as IType? is override
		assert _initExpr.type
		return _initExpr.type


class WhileStmt
	is partial
	inherits Stmt

	var _expr as Expr
	var _block as BlockStmt

	def init(token as IToken, expr as Expr, block as BlockStmt)
		base.init(token)
		_expr = expr
		_block = block

	get lastToken as IToken is override
		return _block.lastToken

	def addSubFields
		base.addSubFields
		.addField('expr', _expr)
		.addField('block', _block)

	def _bindImp
		base._bindImp
		try
			_expr.bindImp
		catch ne as NodeException
			.compiler.recordError(ne)
		success
			.noAssignmentAllowed(_expr)
			if _expr.type is not .compiler.boolType
				_expr = TruthExpr(_expr).bindImp to TruthExpr  # CC: axe when I have "as this"
		_block.bindImp


class PostWhileStmt
	is partial
	inherits WhileStmt

	def init(token as IToken, expr as Expr, block as BlockStmt)
		base.init(token, expr, block)


class YieldStmt
	is abstract, partial
	inherits Stmt

	# CC: axe when initializers are inherited
	def init(token as IToken)
		base.init(token)

	def _bindImp
		base._bindImp
		if .compiler.curCodeMember inherits Initializer
			.throwError('Cannot use yield statements in initializers.')
		# CC: should there be a check for property and indexer setters?
		.compiler.curCodeMember.hasYieldStmt = true


class YieldBreakStmt
	is partial
	inherits YieldStmt

	# CC: axe when initializers are inherited
	def init(token as IToken)
		base.init(token)

	def _bindImp
		base._bindImp


class YieldReturnStmt
	is partial
	inherits YieldStmt

	var _expr as Expr?

	def init(token as IToken, expr as Expr?)
		base.init(token)
		_expr = expr

	def addSubFields
		base.addSubFields
		.addField('expr', _expr)

	def _bindImp
		base._bindImp
		expr = _expr
		curCodeMember = .compiler.codeMemberStack.peek
		if expr
			_expr.bindImp
			resultType = curCodeMember.resultType
			if resultType is not .compiler.enumerableType and resultType is not .compiler.enumeratorType
				okay = false
				if resultType inherits Box
					ienumerableOf = .compiler.enumerableOfType
					ienumeratorOf = .compiler.enumeratorOfType
					okay = not (resultType is not ienumerableOf and resultType is not ienumeratorOf and not resultType.isConstructionOf(ienumerableOf) and not resultType.isConstructionOf(ienumeratorOf))
				if not okay
					.throwError('Cannot yield unless the return type is an iterator type (IEnumerable or IEnumerator, generic or not). Try "IEnumerable<of [expr.type.name]>".')
			if resultType inherits Box and (resultType to Box).isGeneric
				elementType = (resultType to Box).genericParams[0]
			else
				elementType = .compiler.objectType
			if not expr.canBeAssignedTo(elementType)
				suffix = if(elementType is .compiler.voidType, 'not declared to return anything.', 'declared to return a [elementType.name].')
				.throwError('Cannot return [expr.type.name] because "[curCodeMember.name]" is [suffix]')
			_expr.contextType = elementType
		else
			# TODO: can there just be "yield return"?
			pass
		curCodeMember.hasYieldStmt = true
