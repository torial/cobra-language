use System.Reflection


class Box
	is abstract, partial
	inherits Container<of IBoxMember>
	implements IType, IParentSpace, INameSpaceMember, IBoxMember
	"""
	The abstract base class for:
		* Class
		* Interface
		* Struct
	These are collectively known as "boxes".
	Note that of all the types, only Boxes can be generic. Which makes them special.
	"""

	# TODO: need to override greatestCommonDenominatorWith() to handle base interfaces

	var _genericParams as List<of IType>  # as in generic parameters
	var _genericDef as Box?
	var _constructedTypes as Dictionary<of String, Box>?
	var _extensions as List<of Extension>

	var _baseClass as Class?
	var _baseInterfaceProxies as List<of ITypeProxy>
	var _baseInterfaces as List<of Interface>

	var _overloads as List<of MemberOverload>
	var _nextPrivateSerialNumber = 1001

	var _attribs as AttributeList

	var _invariants as List<of Expr>
	var _testMethod as TestMethod?

	var _nativeType as NativeType?
	var _needScanNativeType as bool
	var _membersToUnNil as String?
	var _defaultMemberName as String?
		"""
		An Indexer in CLR is known by being a property with arguments whose name matches the .memberName of a box-level DefaultMemberAttribute.
		"""

	def init(token as IToken, name as String, paramList as List<of IType>, isNames as List<of String>, attribs as AttributeList, baseInterfaceNodes as List<of ITypeProxy>, docString as String?)
		base.init(token, name, isNames, docString)
		_attribs = attribs
		_genericParams = paramList
		for i = 0 .. _genericParams.count
			p = _genericParams[i]
			if p inherits GenericParam
				p.index = i
		_extensions = List<of Extension>()
		_baseInterfaceProxies = baseInterfaceNodes
		_baseInterfaces = List<of Interface>()
		_overloads = List<of MemberOverload>()
		_invariants = List<of Expr>()

	def _initNativeType(t as NativeType)
		ensure .needScanNativeType
		_nativeType = t
		_needScanNativeType = true
		_scanGenericArgs

	def addMinFields
		base.addMinFields
		.addField('didBindInh', .didBindInh)
		.addField('isGeneric', .isGeneric)
		.addField('isGenericDef', .isGenericDef)
		.addField('needsConstruction', .needsConstruction)

	def addRefFields
		base.addRefFields
		.addField('genericDef', _genericDef)
		.addField('baseClass', _baseClass)
		.addField('nativeType', .nativeType)

	def addSubFields
		base.addSubFields
		.addField('genericParams', _genericParams)
		.addField('baseInterfaces', _baseInterfaces)
		.addField('baseInterfaceProxies', _baseInterfaceProxies)

	def toTraceString as String
		sb = StringBuilder('[.getType.name]([.name], [.serialNum], ')
		if _genericParams.count
			sb.append('genericParams=[CobraCore.toTechString(_genericParams)], ')
		if not .didBindInh
			sb.append('not ')
		sb.append('didBindInh, ')
		if not .didBindInt
			sb.append('not ')
		sb.append('didBindInt, ')
		sb.append('nativeType=[.nativeType]')
		sb.append(')')
		return sb.toString

	get attributes as AttributeList is override
		return _attribs

	get baseClass from var

	get baseInterfaces from var

	get baseInterfaceProxies from var

	get canDeclNamesDifferOnlyByCase as bool is override
		return .nativeType is not nil

	get canHaveDetailedStackTrace as bool
		"""
		Normally returns true, but will return false for some key run-time support classes that help *implement* the DST.
		Otherwise, those classes could easily cause infinite recursion / stack overflow.
		Examples include CobraFrame and SourceSite.

		Note that returning true does not mean that the -dst option is turned on.
		Returning true only means that this box *can* have code instrumentation for DST.
		"""
		# TODO: use a class level attribute instead of hard-coded names. DetailedStackTrace(false)
		return .name not in @['CobraFrame', 'SourceSite']  # otherwise, stack overflow

	get constructedTypes as IDictionary<of String, Box>
		"""
		The return value is a shallow copy to prevent outside modification of a generic's constructedTypes cache.
		This property exists primarily for debugging/display.
		"""
		return Dictionary<of String, Box>(_constructedTypes)

	get defaultAccessLevel as String is override
		return 'public'

	get extensions from var

	get hasExtensions as bool
		if _extensions.count, return true
		if _baseClass and _baseClass.hasExtensions, return true
		for bi in _baseInterfaces
			if bi.hasExtensions, return true
		return false

	get isFromAssembly as bool
		"""
		Returns true if this box was read from an assembly (usually a .dll, but could be an .exe) as opposed to be source based.
		This is independent of language. If the DLL was written in Cobra, this still returns true.
		"""
		ensure
			.isSystemObjectClass implies result
			result implies .nativeType or (.genericDef and .genericDef.nativeType)
			not result implies .nativeType is nil
		body
			return _nativeType or (_genericDef and _genericDef._nativeType)
		
	get invariants from var

	get hasInvariants as bool
		"""
		Returns true if the box has any invariant conditions whether directly or through inheritance.
		"""
		if _invariants.count
			return true
		if _baseClass
			return _baseClass.hasInvariants
		else
			return false

	# TODO: cache
	get isSystemObjectClass as bool is override
		return _baseClass is nil and .name == 'Object' and .parentNameSpace and .parentNameSpace.fullName == 'System'

	get isSystemTypeClass as bool is override
		return .name == 'Type' and .parentNameSpace and .parentNameSpace.fullName == 'System'

	pro membersToUnNil from var

	get nativeType from var

	get needScanNativeType from var
	
	get nestedBoxes as IEnumerable<of Box>
		for decl in _declsInOrder
			if decl inherits Box
				yield decl

	pro parentNameSpace as NameSpace?
		get
			return base.parentNameSpace
		set
			# a box needs to be tied to its local namespace, not the unified one
			assert (value and .token.text <> '(empty)') implies not value.isUnified
			base.parentNameSpace = value

	get overloads from var

	get rootName as String
		ensure
			'<' not in result
			.name.startsWith(result)
		body
			name = .name
			i = name.indexOf('<')
			if i <> -1  # List<of>, Dictionary<of,>
				name = name[0:i]
			return name

	get qualifiedRootName as String
		require
			.parentNameSpace
		ensure
			not result.startsWith('.')
			not result.endsWith('.')
			not .parentNameSpace.isRoot implies '.' in result
		body
			return _qualifiedPrefix + .rootName

	get qualifiedName as String
		return _qualifiedPrefix + .name

	get _qualifiedPrefix as String
		ensure
			result.length implies result.endsWith('.')
			' ' not in result
		body
			nameSpaces = List<of NameSpace>()
			ns = .parentNameSpace
			while ns and not ns.isRoot
				nameSpaces.add(ns to !)
				assert ns is not ns.superNameSpace
				ns = ns.superNameSpace
			nameSpaces.reverse
			prefix = Utils.join('.', for ns in nameSpaces get ns.name)
			if prefix.length
				prefix += '.'
			return prefix

	get superType as IType? is override
		or require true
		if not .didBindInh
			.bindInh
		assert .didBindInh
		return _baseClass

	pro testMethod from var

	get isExtern as bool
		return 'extern' in _isNames

	def isDescendantOfInterface(inter as Interface) as bool
		if _baseInterfaces.count == 0 and _baseInterfaceProxies.count
			.bindInh
		if .compiler
			inter.bindInh
		if this is inter
			return true
		assert .serialNum <> inter.serialNum
		assert _baseInterfaceProxies.count == 0 or _baseInterfaces.count == _baseInterfaceProxies.count
		for bit in _baseInterfaces
			if bit.isDescendantOfInterface(inter)
				return true
		return false

	def interfaceMemberForName(name as String) as IBoxMember?
		m = .declForName(name)
		if m
			return m
		for inter in _baseInterfaces
			m = inter.interfaceMemberForName(name)
			if m
				break
		return m

	def makeNextPrivateSerialNumber as int
		n = _nextPrivateSerialNumber
		_nextPrivateSerialNumber += 1
		return n

	def mergedIntoPartialBox(newBox as Box)
		require
			newBox is not .parentBox
			newBox.name == .parentBox.name
		body
			_parentBox = newBox

	get canAccessMemberForName as bool is override
		return .didBindInh or (.nativeType and (.compiler.isBindingInt or .compiler.isBindingImp))

	def extensionMemberFor(box as Box, name as String) as IMember?
		# in the future, in support of C# 3.0, it will be necessary to implement this,
		# or for Extensions to be instantiated when DLLs are scanned
		return nil

	def memberForName(name as String) as IMember?
		if .nativeType
			_prepLibraryBox
		else
			.completeMemberConstructionIfNeeded
		m = base.memberForName(name)
		if m is nil and .hasExtensions and .compiler
			# look for an extension member, but it has to be accessible according to namespaces
			if .compiler.nameSpaceStack.count
				# don't need to go through the whole namespace stack because the namespace will check its parent
				m = .compiler.curNameSpace.extensionMemberFor(this, name)
		return m

	def suggestionsForBadMemberName(name as String) as List<of String>
		suggs = base.suggestionsForBadMemberName(name)
		if _baseClass
			suggs.addRange(_baseClass.suggestionsForBadMemberName(name))
		for bi in _baseInterfaces
			suggs.addRange(bi.suggestionsForBadMemberName(name))

		# eliminate duplicates
		suggs = List<of String>(Set<of String>(suggs))
		suggs.sort

		# okay to sort by alpha, but if a name differs only by case, put it up front
		lowerName = name.toLower
		for i in suggs.count
			if suggs[i].toLower == lowerName
				sugg = suggs[i]
				suggs.removeAt(i)
				suggs.insert(0, sugg)
				break
		return suggs

	def registerOverload(ol as MemberOverload)
		require
			ol.name.length
			ol not in _overloads
		body
			_overloads.add(ol)
			_declsByName[ol.name] = ol
			_declsByName[ol.name.toLower] = ol

	def addDeclFromOverload(decl as IBoxMember, ol as MemberOverload)
		require
			ol in .overloads
			decl.name == ol.name
		body
			_declsInOrder.add(decl)

	def paramForName(name as String) as IType?
		# TODO: make faster
		for param in _genericParams
			if name==param.name
				return param
		return nil

	def symbolForName(name as String, haveThis as bool) as IMember?
		return .symbolForName(name, haveThis, true)

	def symbolForName(name as String, haveThis as bool, firstCall as bool) as IMember?
		"""
		Unlike the inherited .declForName, this method follows the
		inheritance chain and provides options for haveThis.
		
		TODO:
		This method should be protected, but then this expression in the override in Extension: 
			.extendedBox._symbolForName(name, haveThis, firstCall)
		Gives this error message in C#:
			Cannot access protected member "Box._symbolForName(string, bool, bool)" via a qualifier of type "Box"; the qualifier must be of type "Extension" (or derived from it)
		Is this a limitation of C# or CLR? Do Java, C++ and D have the same restruction?
		"""
		if firstCall and name == _name
			return this
		p = .paramForName(name)
		if p
			if haveThis
				.throwError('Cannot refer to a generic parameter ("[name]") through `this`.')
			else
				return p
		x = .declForName(name) to IMember?
		if x is nil and _baseClass
			# try base class to look for nested types
			x = _baseClass.symbolForName(name, haveThis, false)
		if x is nil
			x = .interfaceMemberForName(name)  # TODO: can this be guarded by haveThis? can interfaces have enum decls and sigs?
		if x and not haveThis
			if x.requiresThis, x = nil
		if x is nil and firstCall
			# TODO: can this be guarded by haveThis
			# try parent box or namespace because they are in lexical scope
			nameSpace = .parentNameSpace
			if nameSpace is nil
				# happens for nested boxes which currently means sig/delegate inside a class
				# when classes can really be nested, or generic sigs are supported, we'll need some more work here
				if .parentBox
					x = .parentBox.symbolForName(name, haveThis, firstCall)
			else
				if not .name.startsWith('ArrayType_')  # TODO: axe this guard when ArrayType.memberForName's TODO to read the Array library type is done
					if .didBindInt
						assert nameSpace
				assert not nameSpace.isUnified
				x = nameSpace.symbolForName(name)
		return x

	## INamedNode

	get typeForIdentifier as IType is override
		assert .compiler
		return .compiler.typeType

	get typeForReceiver as IType is override
		return this

	## IType

	get innerType as IType? is override
		if .nativeType
			_prepLibraryBox
		else
			.completeMemberConstructionIfNeeded
		if this is .compiler.stringType  # TODO: hacky
			return .compiler.charType
# can a for loop go through an IEnumerator<of>?
#		if .isConstructed and .genericDef is .compiler.enumeratorOfType
#			return .genericParams[0]
		getEnum = .symbolForName('getEnumerator', true)
		if getEnum
			assert getEnum.didBindInt
			# can have two getEnumerators -- one generic and the other not. favor the generic one
			if getEnum inherits MemberOverload
				for member in getEnum.members
					if member inherits Method
						if member.resultType <> .compiler.objectType
							# implementing IEnumerable<of T> which requires two `getEnumerator` members
							getEnum = member
							break
			rt = getEnum.resultType
			if rt.isDynamicOrPassThrough
				return rt
			rt = rt.nonNil  # nilable is not a concern; unwrap it
			if rt inherits Box and (rt to Box).isGeneric
				# don't take the first argument of the result type -- that won't work for a nested type in a generic class, like ValueCollection, which gets the generic params of its parents
				rt = rt.memberForName('current').resultType
				return rt
			else
				if rt.isDescendantOf(.compiler.dictEnumeratorType)
					return rt.memberForName('entry').resultType
				if rt.isDescendantOf(.compiler.enumeratorType)
					return rt.memberForName('current').resultType
				else
					throw FallThroughException({'rt': rt, 'this': this, 'getEnum': getEnum})
		return nil

	def isEquatableTo(t as IType) as bool
		r = base.isEquatableTo(t)
		if not r and t inherits CharType and this is .compiler.stringType  # TODO: hacky? could this be determined by looking for a static == operator overload?
			r = true
		if not r and ('dynamic' in .name or 'dynamic' in t.name)  # TODO: hacky
			r = true
		return r

	def isComparableTo(t as IType) as bool
		r = base.isComparableTo(t)
		if not r and t inherits CharType and this is .compiler.stringType  # TODO: hacky? could this be determined by looking for a static == operator overload?
			r = true
		if not r and ('dynamic' in .name or 'dynamic' in t.name)  # TODO: hacky
			r = true
		return r

	## Binding

	def _bindInh
		base._bindInh
		.compiler.boxStack.push(this)
		try
			if _needScanNativeType
				_scanNativeType
			_bindBase
			# structs, classes and interfaces can all have 0 or more interfaces they inherit/implement
			if _baseInterfaceProxies.count <> _baseInterfaces.count  # otherwise, already done
				assert _baseInterfaces.count == 0
				for interfaceProxy in _baseInterfaceProxies
					try
						baseWhat = interfaceProxy.realType
						if baseWhat inherits Interface
							_baseInterfaces.add(baseWhat)
						else
							_badInterfaceError(baseWhat)
					catch ne as NodeException
						hadBaseInterfaceError = ne to ?
						.compiler.recordError(ne)
			for box in .nestedBoxes
				box.bindInh
			_checkForInheritanceCycles(this, Stack<of Box>())
		success
			# trace this, hadBaseInterfaceError, .baseInterfaceProxies, .baseInterfaces
			assert hadBaseInterfaceError or .baseInterfaceProxies.count == 0 or .baseInterfaceProxies.count == .baseInterfaces.count, [.baseInterfaceProxies.count, .baseInterfaces.count]
		finally
			.compiler.boxStack.pop

	def _checkForInheritanceCycles(originalBox as Box, bases as Stack<of Box>)
		if this in bases
			names = for aBase in List<of Box>(Stack<of Box>(bases))[1:] get aBase.name
			.throwError('Cyclical inheritance for "[.name]" with ancestor types [Utils.join(", ", names)] and back to [.name].')
		else
			bases.push(this)
			if .baseClass
				.baseClass._checkForInheritanceCycles(originalBox, bases)
			for bi in .baseInterfaces
				bi._checkForInheritanceCycles(originalBox, bases)
			bases.pop

	def bindInt as INode
		# because DLL boxes get bindInh and bindInt on demand, check this:
		if _genericDef
			assert _genericDef is not this
			if not _genericDef.didBindInt and not _genericDef.isBindingInt
				_genericDef.bindInt
			assert _genericDef.didBindInt or _genericDef.isBindingInt
		if .nativeType
			_prepLibraryBox
		else if not .didBindInh
			.bindInh
		if _genericDef
			assert _genericDef is not this
			assert _genericDef.didBindInt or _genericDef.isBindingInt
		return base.bindInt

	def _bindInt
		# Note that .bindInt (not this method, _bindInt) already ensures that if this box is constructed, its generic def binds int *first*.
		# Therefore, everthing below has already happened for a constructed box's generic def.
		base._bindInt
		.compiler.boxStack.push(this)
		try
			if .isSystemObjectClass
				.prepSystemObjectClass
			errorCount = .compiler.errors.count
			if _needScanNativeType
				_scanNativeType
			if _baseClass
				_baseClass.bindInt
			for interf in _baseInterfaces
				interf.bindInt
			for param in _genericParams
				param.bindInt
			if not .isConstructed  # because constructed boxes are already taken care of by way of their generic type def
				.unNilReturnTypes(this)
			for attrib in _attribs
				try
					attrib.bindInt
				catch ne as NodeException
					.compiler.recordError(ne)
			for invari in _invariants
				invari.bindInt
			for decl in List<of IBoxMember>(_declsInOrder)
				assert not decl is this
				.compiler.boxMemberStack.push(decl)
				try
					if decl inherits BoxMember
						if decl.parentBox is not this  # TODO: when does this happen
							continue
					decl.bindInt
				catch ne as NodeException
					.compiler.recordError(ne)
				finally
					.compiler.boxMemberStack.pop
			_finishOverloads
			if _testMethod
				_testMethod.bindInt
			if _constructedTypes
				if .compiler.errors.count <= errorCount  # completing construction on constructed types leads to chaos if this generic def had errors during bind interface
					for ct in _constructedTypes.values
						assert ct is not this
						ct.completeMemberConstructionIfNeeded
						ct.bindInt
		finally
			.compiler.boxStack.pop

	def prepSystemObjectClass
		# TODO: fix native
		# Pretend .NET is a bit more OO, consistent and elegant.
		# C#'s typeof(X) is X.getType in Cobra.
		existing = .declForName('getType') to BoxMember
		overload = MemberOverload(existing)
		.registerOverload(overload)
		meth = Method(TokenFix.empty, this, 'getType', List<of Param>(), ClrTypeProxy(Type), nil, ['shared'], AttributeList(), 'Returns the Type instance that defines this type.')
		meth.sharedMethodBacking = 'typeof'
		overload.addMember(meth)

	def _bindBase
		# invoked by _bindInt
		_baseClass = .compiler.objectClass

	def _badInterfaceError(type as IType)
		.throwError('Cannot inherit "[type.name]" which is a [type.englishName].')

	def _finishOverloads
		# this method is broken out so Class can override and deal with inheritance and overloads
		for ol in _overloads
			try
				ol.bindInt
			catch ne as NodeException
				.compiler.recordError(ne)

	def _bindImp
		base._bindImp
		assert .didBindInt
		.compiler.boxStack.push(this)
		try
			for attrib in _attribs
				try
					attrib.bindImp
				catch ne as NodeException
					.compiler.recordError(ne)
			for i in _invariants.count
				invari = _invariants[i]
				invari.bindImp
				if invari.type is not .compiler.boolType
					_invariants[i] = TruthExpr(invari).bindAll to Expr
			# TODO: should be able to remove the following
			for invari in _invariants
				invari.bindImp
			for decl in List<of IBoxMember>(_declsInOrder)
				assert not decl is this
				.compiler.boxMemberStack.push(decl)
				try
					if decl inherits BoxMember
						if decl.parentBox is not this
							continue
					decl.bindImp
				catch ne as NodeException
					.compiler.recordError(ne)
				finally
					.compiler.boxMemberStack.pop
			for ol in _overloads
				try
					ol.bindImp
				catch ne as NodeException
					.compiler.recordError(ne)
			if _testMethod
				_testMethod.bindImp
		finally
			.compiler.boxStack.pop

	var _didPrep as bool

	def _prepLibraryBox
		"""
		DLL types get bindInh & bindInt only on demand. (Otherwise reading system DLLs slows things down.)
		"""
		require .nativeType
		if _didPrep
			return
		_didPrep = true
		if not .didBindInh
			.bindInh
		if not .didBindInt and not .compiler.isBindingInh
			.bindInt

	var _didUnNilReturnTypes as bool

	get didUnNilReturnTypes as bool
		if .isConstructed
			return .genericDef.didUnNilReturnTypes
		else
			return _didUnNilReturnTypes

	def unNilReturnTypes(box as Box)
		if .compiler.isBindingInh
			# because the .membersToUnNil properties won't even be set until the compiler starts .bindInt
			return
		if _didUnNilReturnTypes
			return
		_didUnNilReturnTypes = true
		_unNilReturnTypes(box)

	def _unNilReturnTypes(box as Box)
		assert not _needScanNativeType
		if box.membersToUnNil
			for name in box.membersToUnNil.split
				m = .declForName(name)  # using .memberForName here is unnecessary and could/would cause an infinite loop
				if m
					m.unNilReturnType
		# follow inheritance to look at ancestors' .membersToUnNil
		if box.baseClass
			_unNilReturnTypes(box.baseClass to !)
		for interf in box.baseInterfaces
			_unNilReturnTypes(interf)


	## Generics

	def isAssignableTo(type as IType) as bool
		r = base.isAssignableTo(type)
		if not r
			type = type.nonNil
			if type inherits PrimitiveType
				if type.systemAliasType == this
					return true  # example: this is Int32 and type is int
			if type inherits Box
				if (.isGeneric and type.isGeneric and .genericDef is type.genericDef) or (.isGenericDef and type.isGeneric and this is type.genericDef)
					# CC?: r = all true for i, gp in .genericParams.numbered get gp.isAssignableTo(type.genericParams[i])
					i = 0
					r = true
					for gp in .genericParams  # CC: for i, gp in .genericParams.numbered
						if not gp.isAssignableTo(type.genericParams[i])
							r = false
							break
						i += 1
				else if type.isGenericDef and .isGeneric and type is .genericDef
					r = type.isAssignableTo(this)
		if not r
			if type inherits StreamType
				r = .isAssignableTo(type.box to !)
		return r

	get isConstructed as bool
		return _genericDef is not nil

	def isConstructionOf(box as Box) as bool
		"""
		Returns true if this type is a construction of the given generic type def, even going more than level deep through `genericDef`.
		"""
		if .genericDef is nil
			return false
		if .genericDef is box
			return true
		if .genericDef.genericDef
			return .genericDef.isConstructionOf(box) # TODO: would iteration be more efficient here?
		return false

	get isGenericDef as bool
		"""
		Returns true if this type is a definition of a generic type, and
		therefore capable of making subsequent generic types via the
		`constructedTypeFor` method. A generic type will have generic
		parameters which are all GenericParam (as opposed to other types
		such as `int` or a given class).
		"""
		# TODO: make this more efficient, maybe by computing in the initializer
		if _genericDef
			return false
		else if _genericParams.count
			for param in _genericParams
				if not param inherits GenericParam
					return false
			return true
		else
			return false

	get isGeneric as bool
		"""
		Returns true if this type is a generic type which includes
		generic type defs and open-or-closed constructed types. Note
		that arrays of generic types and pointers to generic types will
		return false.
		"""
		return _genericParams.count > 0

	get genericParams as List<of IType>
		"""
		Return the list of generic params for this generic type. This
		property requires that .isGenericDef is true.
		"""
		require .isGeneric
		return _genericParams

	get genericDef as Box?
		"""
		Returns the generic type definition for a constructed type (or nil if this type is not constructed).
		"""
		return _genericDef

	def constructedTypeFor(typeArgs as List<of IType>) as Box
		require
			.containsGenericParameters
			typeArgs.count == .genericParams.count
		ensure
			result.genericParams == typeArgs
		body
			assert .isGenericDef

			# TODO: can take this out. it's just a check that the above comparison is working. 2007-12-08
			equal = true
			for i = 0 .. typeArgs.count
				if typeArgs[i] <> .genericParams[i]
					equal = false
					break

			if typeArgs == _genericParams
				assert equal
				return this
			else
				assert not equal

			if not .didBindInh
				assert not .didBindInt
				.bindInh
				assert not .didBindInt
				if .nativeType
					_prepLibraryBox
					assert not .didBindInt or not .compiler.isBindingInh

			# the cache of constructed types has to come from the root generic type def or you end up with duplicate
			# constructed types which is not only wasteful, but causes problems with inheritance tests
			genericDef = this
			while genericDef.genericDef
				genericDef = genericDef.genericDef to !

			if genericDef._constructedTypes is nil
				genericDef._constructedTypes = Dictionary<of String, Box>()
			
			key = TypeUtil.keyForTypeArgs(typeArgs)

			if genericDef._constructedTypes.containsKey(key)
				return genericDef._constructedTypes[key]
			t = .memberwiseClone to Box
			assert t is not this
			genericDef._constructedTypes[key] = t
			argNames = Utils.join(',', for type in typeArgs get type.name)
			t._name = '[.rootName]<of [argNames]>'
			t._genericDef = this
			t._nativeType = nil  # The constructed type is really sourced from the generic def. Don't foster confusion with a reference to the original generic def's clr type (if there is one).
			t.cloneCollections
			# set the contructed type args immediately or its ancestors will get the original generic args during _bindInt:
			for i in typeArgs.count
				t._genericParams[i] = typeArgs[i]
			assert t._constructedTypes is nil or t._constructedTypes.count == 0
			if .didBindInt
				t._completeConstruction(typeArgs)
			else
				t._needsConstruction(typeArgs)
			assert t._constructedTypes is nil or t._constructedTypes.count == 0
			return t

	var _needs_typeArgs as List<of IType>?
		"""
		When non-nil, this box is constructed from a generic *and* requires completion of its construction of members.
		"""

	def completeMemberConstructionIfNeeded
		if _needs_typeArgs
			assert not .isGenericDef
			if not .didBindInt and not .isBindingInt
				.bindInt  # this is required when inheriting from a constructed type such as "class Foo inherits List<of int>". Since "bind inheritance" happens prior to "bind interface", the base type will have been partially constructed without ever binding int.
			# TODO: compiler gives false warning for next line. see http://cobra-language.com/trac/cobra/ticket/41
			if _needs_typeArgs  # .no-warnings.
				_completeConstruction(_needs_typeArgs)
			_needs_typeArgs = nil

	get needsConstruction as bool
		return _needs_typeArgs is not nil

	def _needsConstruction(typeArgs as List<of IType>)
		require
			.genericParams.count == typeArgs.count
		body
			_needs_typeArgs = typeArgs

	def _completeConstruction(typeArgs as List<of IType>)
		"""
		When this method is called, this instance is a constructed type, but its members (such as methods and properties) are still those of its generic type def.
		This method creates new members that are like the generic ones, but with the constructed type arguments substituted in.
		`.foo(item as T)` becomes `.foo(item as int)`
		"""
		require
			.isConstructed
			.genericParams.count == typeArgs.count
			.didBindInt or .isBindingInt
			not .isGenericDef
			.genericDef
			.genericDef.didBindInt or .genericDef.isBindingInt
		body
			_genericDef.unNilReturnTypes(_genericDef to !)
			gpToType = TypeUtil.dictionaryOf(_genericDef.genericParams, typeArgs)

			_baseClass = _baseClass.secondaryConstructedTypeFor(this, gpToType) to Class
			assert _baseInterfaceProxies.count == 0 or _baseInterfaceProxies.count == _baseInterfaces.count
			for i = 0 .. _baseInterfaces.count
				_baseInterfaces[i] = _baseInterfaces[i].secondaryConstructedTypeFor(this, gpToType) to Interface

			# construct the declarations
			_overloads = List<of MemberOverload>()
			newDecls = List<of IBoxMember>()
			# hmmm, is it really necessary to do the nested boxes before the other members?
			for decl in _declsInOrder
				if decl inherits Box
					nd = decl.constructedTypeFor(typeArgs) to IBoxMember
					assert nd <> decl
					newDecls.add(nd)
			for decl in _declsInOrder
				if decl inherits BoxMember
					nd = decl.constructedFor(this, gpToType)
					assert nd <> decl
					newDecls.add(nd)
				else if not decl inherits Box
					newDecls.add(nd)
			_declsInOrder = List<of IBoxMember>()
			_declsByName = Dictionary<of String, IBoxMember>()
			_declsByNameCI = Dictionary<of String, IBoxMember>()
			for decl in newDecls
				if _declsByName.containsKey(decl.name)
					overload = nil to MemberOverload?
					other = _declsByName[decl.name]
					if other inherits MemberOverload
						overload = other
					else if other inherits AbstractMethod
						overload = MemberOverload(other)
						.registerOverload(overload to !)
					else
						throw FallThroughException(other)
					overload.addMember(decl to BoxMember)
				else
					_declsInOrder.add(decl)
					_declsByName[decl.name] = decl
					_declsByNameCI[decl.name.toLower] = decl
			# TODO: can this next statement can be axed since there is a separate "bind inheritance" phase?
			_finishOverloads

	def secondaryConstructedTypeFor(box as Box, gpToType as Dictionary<of GenericParam, IType>) as IType is override
		if _genericParams.count == 0
			return this
		typeArgs = List<of IType>()
		params = .genericParams
		for param in params
			if param inherits GenericParam
				# doesn't work:
				# typeArgs.add(gpToType[param])
				found as GenericParam?
				for key as dynamic in gpToType.keys
					if key.name == param.name
						found = key
				assert found, {'param': param, 'gpToType.keys': gpToType.keys}
				typeArgs.add(gpToType[found to !])
			else
				typeArgs.add(param.secondaryConstructedTypeFor(box, gpToType))
		if .isGenericDef
			return .constructedTypeFor(typeArgs)
		else
			assert .genericDef.isGenericDef  # if this ever fails, we may just need to follow .genericDef back iteratively until we get to the real generic type def
			return .genericDef.constructedTypeFor(typeArgs)

	def cloneCollections
		base.cloneCollections
		_genericParams = List<of IType>(_genericParams)  # TODO: Can I just say _genericParams.clone? Do I need the cast?
		_constructedTypes = nil
		_baseInterfaceProxies = List<of ITypeProxy>(_baseInterfaceProxies)
		_baseInterfaces = List<of Interface>(_baseInterfaces)
		# _overloads = List<of MemberOverload>(_overloads)  # these will be recreated

	def typeForGenericParam(gp as GenericParam) as IType # TODO: is this needed for NilableType?
		"""
		Returns the specific type arg that corresponds to the given generic
		parameter. Used to match the gp's in method, properties, etc. against
		the actual types in a constructed type.
		"""
		require
			.isGeneric
			.genericParams.count
		body
			# TODO: When does this get called? Investigate this.
			return .genericParams[gp.index]

	get containsGenericParameters as bool
		for param in _genericParams
			if param inherits GenericParam
				return true
			if param inherits Box  # CC: and <next if condition>
				if param.containsGenericParameters
					return true
		return false


class Class
	is partial
	inherits Box

	var _baseNode as ITypeProxy?
	var _subclasses = List<of Class>()

	def init(token as IToken, name as String, paramList as List<of IType>, isNames as List<of String>, attribs as AttributeList, baseNode as ITypeProxy?, implementsNodes as List<of ITypeProxy>, docString as String?)
		base.init(token, name, paramList, isNames, attribs, implementsNodes, docString)
		_baseNode = baseNode

	def init(nativeType as NativeType)
		# TODO: fix native
		base.init(TokenFix.empty, ClrTypeProxy.cobraNameForSharpBoxName(nativeType.name), List<of IType>(), List<of String>(), AttributeList(), List<of ITypeProxy>(), nil)
		if nativeType.baseType
			_baseNode = ClrTypeProxy(nativeType.baseType to ClrNativeType)  # TODO: fix native. Change to NativeTypeProxy
		_initNativeType(nativeType)

	def addSubFields
		base.addSubFields
		.addField('baseNode', _baseNode)

	get isCallable as bool is override
		return true
		
	def isDescendantOf(type as IType) as bool is override
		if not .baseClass and _baseNode
			.bindInh
		if .compiler
			type.bindInh
		if this is type
			return true
		if type inherits Interface
			if .isDescendantOfInterface(type)
				return true
		baseClass = .baseClass
		assert baseClass is not this, this  # check for direct cycles
		if baseClass
			return baseClass.isDescendantOf(type)
		else
			return false

	get isReference as bool is override
		return true

	get subclasses from var

	def memberForName(name as String) as IMember?
		# the next assertion fails for Tests\600-misc\404-implement-IEnumerable
		# could not fix. I'm confused. Something to do with generics. So bail on generics:
		# asserting .didBindInt is difficult because .memberForName gets invoked during bindInt
		# if not .isGeneric
		# 	assert .didBindInt  # TODO: is this legit? if so, push up to Container
		# TODO: assert .didBindInh
		m = base.memberForName(name)
		if m is nil and _baseClass
			m = _baseClass.memberForName(name)
		if m is nil
			m = .interfaceMemberForName(name)
		# handle get/set parts like "someProp.get" or "[].set"
		# `computeMatchingBaseMember` in Members.cobra is at least one that returns this
		if m is nil and '.' in name
			if name.endsWith('.get')
				part = 'g'
			else if name.endsWith('.set')
				part = 's'
			else
				throw FallThroughException(name)
			pd = .memberForName(name[:-4])
			if pd inherits ProperDexer
				branch part
					on 'g'
						m = pd.getPart
					on 's'
						m = pd.setPart
				# TODO: cache the above back into the _decls
			# TODO: ? else, throw FallThroughException(...)
		return m

	def _bindBase is override
		if _baseNode
			possible = _baseNode.realType
			baseName = if(_baseNode inherits AbstractTypeIdentifier, (_baseNode to AbstractTypeIdentifier).name, nil)  # CC: if-inherits should work for expressions too
			if possible inherits Class
				_baseClass = possible
			else if possible inherits Interface
				assert baseName
				.throwError('The base "[baseName]" is an interface. Try "implements" instead of "inherits".')
			else if possible inherits Struct
				assert baseName
				.throwError('The base "[baseName]" is a struct. Classes cannot inherit from structs.')
			else
				assert baseName
				.throwError('The base class "[baseName]" is not actually a class, it is a "[possible.englishName]".')
		else
			t = .compiler.objectType to Class
			if this is not t  # don't want Object to inherit Object
				_baseClass = t
		if _baseClass
			_baseClass._subclasses.add(this)

	def _bindInt
		for decl in .declsInOrder
			if decl inherits Initializer
				foundInitializer = true
				break
		if not foundInitializer
			# TODO: this should be changed to provide cover initializers for each of the public, inherited initializers
			.addDecl(Initializer(.token, this, List<of Param>(), ['public'], AttributeList(), ''))
		# Note that the _baseClass is not told to bindInt. That would fail for classes in other namespaces and it's unnecessary
		base._bindInt
		if .isDescendantOf(.compiler.attributeType) and not .name.endsWith('Attribute')
			.compiler.warning(this, 'When attributes are declared, they should be suffixed with "Attribute".')

	def _badInterfaceError(type as IType) is override
		msg = 'Cannot implement "[type.name]" which is a [type.englishName].'
		if type inherits Class
			msg += ' Use "inherits" instead.'
		.throwError(msg)

	def _finishOverloads
		# deal with inheritance and overloads
		assert _baseClass or .isSystemObjectClass
		if _baseClass
			#assert _baseClass.didBindInt
			for decl in List<of IBoxMember>(_declsInOrder)
				if decl inherits Method and not decl inherits Initializer  # TODO: I don't think this captures Indexers. Make a test case if needed, write: if decl.canBeOverloaded or if decl inherits ICanBeOverloaded
					other = _baseClass.memberForName(decl.name)
					if other
						if decl inherits MemberOverload
							overload = decl
						else if decl inherits BoxMember
							overload = MemberOverload(decl)
							.registerOverload(overload)
						else
							throw FallThroughException(decl)
						if other inherits MemberOverload
							for member in other.members
								assert not member inherits MemberOverload
								overload.addInheritedMemberIfNoMatch(member)
						else if other inherits BoxMember
							overload.addInheritedMemberIfNoMatch(other)
						else
							throw FallThroughException(other)
		base._finishOverloads

	get englishName as String is override
		return 'class'


class Interface
	is partial
	inherits Box

	def init(token as IToken, name as String, paramList as List<of IType>, isNames as List<of String>, attribs as AttributeList, baseNodes as List<of ITypeProxy>, docString as String?)
		base.init(token, name, paramList, isNames, attribs, baseNodes, docString)

	def init(nativeType as NativeType)
		base.init(TokenFix.empty, ClrTypeProxy.cobraNameForSharpBoxName(nativeType.name), List<of IType>(), List<of String>(), AttributeList(), List<of ITypeProxy>(), nil)
		_initNativeType(nativeType)

	get englishName as String is override
		return 'interface'

	get isReference as bool is override
		return true

	def isDescendantOf(type as IType) as bool is override
		if this is type
			return true
		if type inherits Interface
			if .isDescendantOfInterface(type)
				return true
		if .superType is type or .superType.isDescendantOf(type)
			return true
		return false

	def memberForName(name as String) as IMember?
		m = base.memberForName(name)
		if m is nil
			m = .interfaceMemberForName(name)
			if m is nil and _baseClass
				m = _baseClass.memberForName(name)
		return m


class Struct
	is partial
	inherits Box

	def init(token as IToken, name as String, paramList as List<of IType>, isNames as List<of String>, attribs as AttributeList, baseName as String?, interfaceNodes as List<of ITypeProxy>, docString as String?)
		base.init(token, name, paramList, isNames, attribs, interfaceNodes, docString)

	def init(nativeType as NativeType)
		base.init(TokenFix.empty, ClrTypeProxy.cobraNameForSharpBoxName(nativeType.name), List<of IType>(), List<of String>(), AttributeList(), List<of ITypeProxy>(), nil)
		_initNativeType(nativeType)

	get englishName as String is override
		return 'struct'

	def isDescendantOf(type as IType) as bool is override
		# TODO: hmmm, almost duplicated from Class
		if not .baseClass # and _baseNode
			.bindInh
		if .compiler
			type.bindInh
		if this is type
			return true
		if type inherits Interface
			if .isDescendantOfInterface(type)
				return true
		baseClass = .baseClass
		# assert baseClass is not this, this  # check for direct cycles
		if baseClass
			return baseClass.isDescendantOf(type)
		else
			return false

	get isCallable as bool is override
		return true

	get isReference as bool is override
		return false

	def memberForName(name as String) as IMember?
		m = base.memberForName(name)
		if m is nil and _baseClass
			m = _baseClass.memberForName(name)
		return m


class MethodSig
	is partial
	inherits Class
	"""
	Example Cobra source:
		sig ComputeSomething(a is int, b as int) as int

	.NET calls these delegates and describes them as type-safe method signatures.
	The "sig" keyword fits nicely with other declaration keywords like "var" "def" and "get".
	And "sig" is a more platform neutral term should we have other non-CLI backends.
	
	MethodSigs are only created when parsing. When reading from a DLL, delegates are merely subclasses of Delegate or MulticastDelegate.
	
	Reference: Pro C# 2008, Chapter 11
	"""

	var _params as List<of Param>
	var _returnTypeProxy as ITypeProxy
	var _returnType as IType?

	def init(token as IToken, parent as IParentSpace?, name as String, params as List<of Param>, returnTypeProxy as ITypeProxy, isNames as List<of String>, attribs as AttributeList, docString as String)
		base.init(token, name, List<of IType>(), isNames, attribs, LibraryTypeProxy('System.MulticastDelegate'), List<of ITypeProxy>(), docString)
		_initParent(parent)
		_params = params
		_returnTypeProxy = returnTypeProxy

	get isShared as bool is override
		# When a sig is declared inside a class, you can say: SomeClass.SomeSig
		# DotExpr needs to know this, hence return true for .isShared
		return true

	get params from var
	
	get returnTypeProxy from var
	
	get returnType from var
	
	get resultType as IType? is override
		return .returnType

	def _bindInh
		base._bindInh
		assert _baseClass
		assert _baseClass.qualifiedName == 'System.MulticastDelegate'
		assert .parentBox or .parentNameSpace

	def _bindInt
		m = Method(.token, this, 'invoke', List<of Param>(.params), .returnType ? .returnTypeProxy, nil, List<of String>(.isNames), AttributeList(), '')
		m.statements.add(ThrowStmt(.token, PostCallExpr(.token, IdentifierExpr(.token, 'Exception'), List<of Expr>()))) # just to avoid a Cobra warning during .bindImp
		.addDecl(m)
		base._bindInt
		for param in .params
			param.bindInt
		if not _returnType
			_returnType = _returnTypeProxy.realType

	def _bindImp
		base._bindImp


class GenericParam
	is partial
	inherits CobraType
	"""
	A generic parameter *is* a type.
	"""

	var _name as String
	var _constraints as List<of GenericConstraint>
	var _index as int
	var _objectClass as Class?
	var _nativeType as NativeType?

	def init(name as String)
		require name.length
		base.init
		_name = name
		_constraints = List<of GenericConstraint>()

	def init(genArgType as NativeType)
		.init(genArgType.name)
		_nativeType = genArgType
		# TODO: scan Constraints

	get name as String is override
		return _name

	get nativeType from var

	get constraints from var

	get englishName as String is override
		return 'generic parameter'

	pro index from var

	get isReference as bool is override
		# Well, it's hard to say if a GenericParam is a reference or value type, but CompareExpr() influences us to say "true".
		# TODO: if there are constraints on the generic param, examine them to determine answer
		return true

	def addMinFields
		base.addMinFields
		.addField('name', _name)

	def addSubFields
		base.addSubFields
		.addField('constraints', _constraints)
		.addField('index', _index)

	def declForName(name as String) as IMember? is override
		for constraint in _constraints
			decl = constraint.declForName(name)
			if decl
				return decl
		return _objectClass.declForName(name)

	def memberForName(name as String) as IMember? is override
		for constraint in _constraints
			member = constraint.memberForName(name)
			if member
				return member
		return _objectClass.memberForName(name)

	def isDescendantOf(type as IType) as bool is override
		if type is .compiler.objectType
			return true
		if type.superType is nil  # the root type
			return true
		for constraint in _constraints
			if constraint.isDescendantOf(type)
				return true
		return false

	def secondaryConstructedTypeFor(box as Box, gpToType as Dictionary<of GenericParam, IType>) as IType is override
		if gpToType.containsKey(this)
			return gpToType[this]
		else
			for key in gpToType.keys
				if key.name == .name
					return gpToType[key]
		throw FallThroughException(this)

	def _bindInt
		base._bindInt
		_objectClass = .compiler.objectClass
		for constraint in _constraints
			constraint.bindInt


class GenericConstraint
	inherits SyntaxNode

	def init(token as IToken)
		base.init(token)

	def isDescendantOf(type as IType) as bool
		return false

	def declForName(name as String) as IBoxMember?
		"""
		Returns nil by default.
		"""
		return nil

	def memberForName(name as String) as IMember?
		"""
		Returns nil by default.
		"""
		return nil

	def _bindInt
		base._bindInt


class GenericClassConstraint
	is partial
	inherits GenericConstraint
	"""
	Represents the generic constraint class
	"""

	def init(token as IToken)
		base.init(token)


class GenericStructConstraint
	is partial
	inherits GenericConstraint
	"""
	Represents the generic constraint class
	"""

	def init(token as IToken)
		base.init(token)


class GenericCallableConstraint
	is partial
	inherits GenericConstraint
	"""
	Represents the generic constraint callable
	"""

	def init(token as IToken)
		base.init(token)


class GenericTypeConstraint
	is partial
	inherits GenericConstraint
	"""
	Represents the generic constraint of a particular type.
	"""

	var _representedType as IType?
	var _typeNode as ITypeProxy

	def init(typeNode as ITypeProxy)
		base.init((typeNode to ISyntaxNode).token)  # CC: could be potential for making arg a compound interface ISyntaxNode+ITypeProxy from the 'Speculative' list
		_typeNode = typeNode

	def isDescendantOf(type as IType) as bool is override
		assert _representedType
		return _representedType.isDescendantOf(type)

# TODO?
#	def declForName(name as String) as IBoxMember? is override
#		assert _representedType
#		return _representedType.declForName(name)

	def memberForName(name as String) as IMember? is override
		assert _representedType
		return _representedType.memberForName(name)

	def _bindInt
		base._bindInt
		if _representedType is nil
			_representedType = _typeNode.realType
			assert _representedType
		if not _representedType inherits Class and not _representedType inherits Interface
			.throwError('A generic type constraint must be a class or an interface. "[_representedType.name]" is not.')


class Extension
	is partial
	inherits Box
	"""
	Example:
		extend String		
			get doubleLength as int
				return .length * 2
	"""

	var _extendedBoxProxy as ITypeProxy
	var _extendedBox as Box?

	def init(token as IToken, extendedBoxProxy as ITypeProxy, isNames as List<of String>, docString as String?)
		base.init(token, '(unnamed extension)', List<of IType>(), isNames, AttributeList(), List<of ITypeProxy>(), docString)
		_name = '(unnamed extension [.serialNum])'
		_extendedBoxProxy = extendedBoxProxy

	def init(nativeType as NativeType)
		# this only for Cobra specific extensions. Example: class Extend_String_FileName
		base.init(TokenFix.empty, ClrTypeProxy.cobraNameForSharpBoxName(nativeType.name), List<of IType>(), List<of String>(), AttributeList(), List<of ITypeProxy>(), nil)
		_initNativeType(nativeType)
		# the real extended type is not this type, but the type of the first argument of any method
		for methInfo in .clrType.getMethods  # TODO: fix native. break this out to a method
			nativeType = ClrNativeType(methInfo.getParameters[0].parameterType)
			break
		_extendedBoxProxy = ClrTypeProxy(nativeType)
		(.compiler.curModule to AssemblyModule).addMustBindInh(this)

	get extendedBox from var

	get isReference as bool is override
		return _extendedBox.isReference

	get englishName as String is override
		return if(_extendedBox, _extendedBox.englishName+' ', '') + 'extension'

	def addDecl(decl as IBoxMember) is override
		base.addDecl(decl)

	def extensionMemberFor(box as Box, name as String) as IMember? is override
		assert .didBindInh
		if _nativeType
			_prepLibraryBox
		else
			.completeMemberConstructionIfNeeded
		if box.isDescendantOf(_extendedBox to !)
			return .declForName(name)
		else
			return nil
			
	def memberForName(name as String) as IMember?
		result = base.memberForName(name)
		if result is nil
			result = .extendedBox.memberForName(name)
		return result

	def symbolForName(name as String, haveThis as bool, firstCall as bool) as IMember?
		result = base.symbolForName(name, haveThis, firstCall)
		if result is nil
			result = .extendedBox.symbolForName(name, haveThis, firstCall)
		return result

	def _bindInh
		base._bindInh

		if _extendedBox is nil
			realType = _extendedBoxProxy.realType
			if realType inherits Box
				_extendedBox = realType
			else
				.throwError('Cannot extend a [realType.name]. You can extend classes, structs and interfaces.')
		_name = '[_extendedBox.name].extension.[.serialNum]'

		# shouldn't need or use inherited types
		_baseClass = nil
		_baseInterfaceProxies = List<of ITypeProxy>()
		_baseInterfaces = List<of Interface>()
		
		# connect up
		_extendedBox.extensions.add(this)
	
	def _bindInt
		base._bindInt
		# TODO: deal with overloads
		sharpName = .sharpRef   # TODO: how to generalize this beyond CLR? idea: change .sharedMethodBacking to refer to a method instead of being a String
		for decl in .declsInOrder
			if decl inherits AbstractMethod
				if decl inherits Initializer
					decl.recordError('Extensions can only contain methods, not initializers.')
				else
					decl.sharedMethodBacking = '[sharpName].[decl.name.capped]'
					decl.isNames.remove('virtual')
					decl.isNames.add('nonvirtual')
					decl.bindInt
			else
				decl.recordError('Extensions can only contain methods.')

	def _bindImp
		base._bindImp
		for decl in .declsInOrder
			decl.bindImp
