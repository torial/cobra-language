use System.Reflection
use System.Runtime.CompilerServices


namespace Cobra.Lang

	interface ITreeBuilder
		def indent
		def outdent
		def addEntry(key as String, value as dynamic?)

	class MustUseResultAttribute
		has AttributeUsage(AttributeTargets.Method, allowMultiple=false)
		inherits Attribute
		pass

	class CobraCore

		shared
		
			## Release info

			get versionDescription as String
				"""
				Returns a textual description of the version such as "X.Y.Z" or "svn-post-X.Y.Z".
				"""
				return 'svn-post-[.version]'
				# return .version.toString
			
			get isOfficialRelease
				return false

			get version as Version
				return Version(0, 8, 0)

			get releaseNum as int
				return 25


			## String Makers
			
			pro printStringMaker as StringMaker
				"""
				Used by `print` statements, string substitutions and .toPrintString methods.
				"""
				get
					return CobraImp._printStringMaker
				set
					CobraImp._printStringMaker = value
			
			pro techStringMaker as StringMaker
				"""
				Used by `assert` failures, `trace` statements and .toTechString methods.
				"""
				get
					return CobraImp._techStringMaker
				set
					CobraImp._techStringMaker = value


			## Program stuff

			get commandLineArgs as List<of String>
				return List<of String>(Environment.getCommandLineArgs)

			get exePath as String
				"""
				Returns the full path of the currently executing exe including directory, file name and extension.
				Use `Path.getDirectoryName()` on this to get the directory containing the current exe.
				"""
				test
					assert '.exe' in CobraCore.exePath
				body
					return Assembly.getEntryAssembly.location

			get printDestination as TextWriter
				"""
				Returns the TextWriter that print statements currently print to.
				This can change via the block version of the `print to` statement.
				"""
				return CobraImp.printDestination

			def printDebuggingTips
				print 'An unhandled exception has occurred.'
				print
				print 'Cobra debugging tips:'
				print '    To get file name and line number information for the stack frames, use:'
				print '        cobra -debug foo.cobra'
				if CobraCore.isRunningOnMono
					print '    If running the executable through "mono" then also use --debug (double dash):'
					print '        mono --debug foo.exe ...'
				print '    To get a post-mortem, HTML-formatted report with more details about your objects:'
				print '        cobra -debug -exception-report foo.cobra'
				print '    For even more information, try:'
				print '        cobra -debug -exception-report -detailed-stack-trace foo.cobra'
				print '    Or use the abbreviations:'
				print '        cobra -d -er -dst foo.cobra'
				# TODO: print '    See also: http://cobra-language.com/docs/debugging'
				print
			

			## Reset
			
			def reset(printDestination as TextWriter)
				"""
				Resets the Cobra run-time support using the argument as the initial print destination on the "print to" stack.
				This is occasionally needed in special circumstances such as running with Pex (http://research.microsoft.com/pex/).
				"""
				CobraImp.reset(printDestination)

			def reset
				"""
				Resets the Cobra run-time support using Console.out.
				"""
				.reset(Console.out)
			

			## Tracer

			var _tracer as Tracer?

			pro tracer as Tracer
				"""
				The global Tracer object used by `trace` statements.
				Via this property, you can set this to your own instance,
				or access the tracer to read or write its properties.
				To turn off tracing, for example, you can write `CobraCore.tracer.isActive = false`.
				"""
				get
					if _tracer is nil
						_tracer = Tracer()
					return _tracer to !
				set
					_tracer = Tracer()


			## Run Tests

			def runAllTests
				"""
				Run all Cobra `test` sections in all assemblies using reflection to locate them.
				"""
				# start = DateTime.now
				_runAllTests(Assembly.getEntryAssembly, Dictionary<of String, String>())
				# duration = DateTime.now.subtract(start)
				# trace duration

			def _runAllTests(ass as Assembly, found as Dictionary<of String, String>)  # CC: found should be Set<of String>
				name = ass.getName.toString
				if found.containsKey(name)
					return
				found.add(name, name)
				if _skipAssemblyNameForTesting(name)  # saves some time
					return

				# print 'Testing assembly:', ass
				for type in ass.getExportedTypes
					members = type.getMember('RunTestsIfNeeded')
					if members and members.length and members[0] inherits MethodInfo
						method = members[0] to MethodInfo
						# trace type, method
						if type.containsGenericParameters
							# TODO: this is quite awful. tests in generic types are being skipped!
							# potential solution 1: move type test out of the type into a "sister" type: private __FooTest
							# potential solution 2: require a constructed type in Cobra: `test Foo<of int> ...` and then put that in a method attribute in the gen C# and use that type
							continue
						method.invoke(type, nil)

				# traverse further assemblies
				for assName in ass.getReferencedAssemblies
					subAss = Assembly.load(assName)
					_runAllTests(subAss to !, found)

			var _skipPrefixes = @['System.', 'Mono.', 'mscorlib,', 'System,']

			def _skipAssemblyNameForTesting(name as String) as bool
				for prefix in _skipPrefixes
					if name.startsWith(prefix)
						return true
				return false


			## Detailed stack trace

			pro maxStackFrames as int
				"""
				When detailed stack trace is on, this value limits the maximum stack depth before
				Cobra will exit with a stack overflow error including a listing of the most
				recent stack frames. The default value is 250. You can set to 0 to disable
				stack overflow detection.
				"""
				get
					return CobraImp._maxStackFrames
				set
					require value == 0 or value > 9
					CobraImp._maxStackFrames = value

			pro numLastMaxStackFrames as int
				"""
				When stack overflow is detected, this value gives the number of most recent stack frames that will be printed.
				"""
				get
					return CobraImp._numLastMaxStackFrames
				set
					require value >= 2
					CobraImp._numLastMaxStackFrames = value
					
			var _maxDumpObjectCount = 250
	
			pro maxDumpObjectCount from var
				"""
				Controls the maximum number of objects dumped  in the exception report.
				Defaults to 250 which can easily result in a 5MB exception report.
				"""

			get hasDetailedStackTrace
				return CobraImp.hasDetailedStackTrace

			def handleUnhandledException(ex as Exception)
				print
				try
					print 'Unhandled Exception: [ex]'
				catch exc as Exception
					print 'Unhandled Exception: CAUGHT EXCEPTION FOR [ex.getType.name].toString: [exc]'
				fileName = 'cobra-exception-report.html'
				print 'Writing exception report to [fileName]...'
				using tw = File.createText(fileName)
					HtmlExceptionReportWriter().writeReport(tw, ex)
				print 'Wrote [fileName]'
				envVarName = 'COBRA_OPEN_HTML_SST_COMMAND'
				cmd = Environment.getEnvironmentVariable(envVarName)
				if cmd
					if cmd.trim.length
						p = System.Diagnostics.Process()
						p.startInfo.fileName = cmd
						p.startInfo.arguments = fileName
						p.startInfo.useShellExecute = false
						p.start
						print '[cmd] [fileName]'
				else
					print 'You can set the environment variable [envVarName]'
					print 'to automatically open the exception report.'

	
			## Type names and tech strings

			def typeName(t as Type) as String
				return CobraImp.typeName(t)

			def toTechString(x as Object?) as String
				return CobraImp.toTechString(x)


			## Will check control flags

			# CC: make a public section/block here
			var _willCheckInvariant = true
				is public
			var _willCheckRequire = true
				is public
			var _willCheckEnsure = true
				is public
			var _willCheckAssert = true
				is public
			var _willCheckNil = true
				is public

			pro willCheckInvariant from var
			pro willCheckRequire from var
			pro willCheckEnsure from var
			pro willCheckAssert from var
			pro willCheckNil from var

			set willCheckAll as bool
				.willCheckInvariant = value
				.willCheckRequire = value
				.willCheckEnsure = value
				.willCheckAssert = value
				.willCheckNil = value


			## Finding cobra command line program

			def runCobraExe(args as String, process as out System.Diagnostics.Process?) as String
				"""
				Runs cobra.exe with the given args, sets the process to the one created for cobra.exe and returns all output including stdio and stderr.
				In addition to examining the output, you should be interested in process.exitCode which will be zero if there was no problems.
				Uses CobraCore.findCobraExe and raises IOException if it cannot be found.
				Uses CobraCore.runAndCaptureAllOutput(p) to run the process.
				"""
				cobraExePath = CobraCore.findCobraExe
				if cobraExePath is nil or cobraExePath == ''
					throw IOException('Cannot locate cobra.exe using CobraCore.findCobraExe. Consider invoking .findCobraExe with additional search paths and passing the result to .runCobraExe.')
				return .runCobraExe(cobraExePath, args, out process)

			def runCobraExe(cobraExePath as String, args as String, process as out System.Diagnostics.Process?) as String
				require cobraExePath.length
				p = System.Diagnostics.Process()
				if CobraCore.isRunningOnMono
					p.startInfo.fileName = 'mono'
					p.startInfo.arguments = cobraExePath + ' ' + args
				else
					p.startInfo.fileName = cobraExePath
					p.startInfo.arguments = args
				# print '[p.startInfo.fileName] [p.startInfo.arguments]'
				process = p
				return CobraCore.runAndCaptureAllOutput(p)

			def findCobraExe as String?
				return .findCobraExe(nil)

			def findCobraExe(extraPaths as IList<of String>?) as String?
				"""
				Finds cobra.exe on the current system by looking in various places:
					* the current directory
					* the directory where the current executable resides
					* the path of the cobra.exe that produced the current executable
					* the path of the COBRA environment variable
					* the system PATH
					* educated guesses like \WINDOWS\Program Files\Cobra\bin and /usr/local/bin
					* the extraPaths argument
				"""
				# check previous cached result first
				if _findCobraCache
					return _findCobraCache
				# check the current directory
				path = _findCobraExe(Environment.currentDirectory)
				if path
					return path
				# check the directory where the current executable resides
				path = _findCobraExe(CobraCore.exePath)
				if path
					return path
				# check for the cobra that created the current executable
				if File.exists(CobraInfo.cobraPath)
					return CobraInfo.cobraPath
				# check COBRA environment variable
				path = Environment.getEnvironmentVariable('COBRA') ? ''
				if path <> ''
					path = _findCobraExe(path)
					if path
						return path
				# check the PATH
				paths = (Environment.getEnvironmentVariable('PATH') ? '').split(Path.pathSeparator)
				for sysPath in paths
					path = _findCobraExe(sysPath)
					if path
						return path
				# check common locations and extraPaths
				morePaths = [
					r'\WINDOWS\Program Files\Cobra\bin',
					r'\Cobra\bin',
					r'/usr/local/bin',
					r'/usr/bin',
					r'/bin',
				]
				if extraPaths
					morePaths.addRange(extraPaths)
				for path in morePaths
					path = _findCobraExe(path)
					if path
						return path
				# cannot find cobra.exe
				return nil

			def clearCobraExeCache
				"""
				The `findCobraExe` method caches its results for subsequent speed.
				This method clears the cache in the event you need to do so.
				"""
				_findCobraCache = nil

			var _findCobraCache as String?

			def _findCobraExe(path as String) as String?
				_findCobraCache = _findCobraExe(path, true)
				return _findCobraCache

			def _findCobraExe(path as String, firstTime as bool) as String?
				if path <> CobraCore.exePath and path.endsWith('cobra.exe')
					# ^ first condition guards against test cases like "invoke-cobra.exe" from endlessly invoking themselves
					if File.exists(path)
						return path
					else
						return nil
				else if Directory.exists(path)
					exe = Path.combine(path, 'cobra.exe')
					if File.exists(exe)
						return exe
					exe = Path.combine(Path.combine(path, 'bin'), 'cobra.exe')
					if File.exists(exe)
						return exe
					if firstTime
						# check for a 'Cobra' subdirectory
						return _findCobraExe(Path.combine(path, 'Cobra'), false)
					else
						return nil
				else
					return nil


			## Other util
			
			var _isRunningOnMono as bool?
			
			get isRunningOnMono as bool
				if _isRunningOnMono is nil
					_isRunningOnMono = $sharp('Type.GetType("Mono.Runtime")') is not nil
				return _isRunningOnMono to !
				
			def runAndCaptureAllOutput(process as System.Diagnostics.Process) as String
				"""
				Example:
					p = System.Diagnostics.Process()
					p.startInfo.fileName = 'some-program'
					p.startInfo.arguments = 'foo bar baz'
					output = CobraCore.runAndCaptureAllOutput(p)
					trace p, p.exitCode, output
				TODO: change to extension method on Process
				"""
				return CobraImp.runAndCaptureAllOutput(process)

			def noOp(args as vari dynamic?) as dynamic?
				"""
				No operation. Primarily used in Cobra's own test suite to consume a local variable to avoid undesired warnings.
				Takes any number of values and returns an undefined value of type `dynamic?` for maximum flexibility.
				"""
				return 0

			var _htmlEncodes = @[['&', '&amp;'], ['<', '&lt;'], ['>', '&gt;'], ['"', '&quot;']]

			def htmlEncode(obj as Object) as String
				"""
				Return the HTML encoded version of the given object.
				Returns the contents of the object if it is an instance of Html.
				This is useful to display a plain ASCII text string on a web page.
				"""
				if obj inherits Html
					return obj.contents
				else
					return .htmlEncode(obj.toString)
			
			def htmlEncode(s as String) as String
				"""
				Return the HTML encoded version of the given string.
				This is useful to display a plain ASCII text string on a web page.
				"""
				test
					rw = HtmlExceptionReportWriter()
					assert rw.htmlEncode('foo') == 'foo'
					assert rw.htmlEncode('3 < 5') == '3 &lt; 5'
				body
					for code in _htmlEncodes
						s = s.replace(code[0], code[1])
					return s


	class CobraDirectString
		is extern
		"""
		Used internally for assert, require and ensure to encode strings that should not be passed to CobraCore.toTechString.
		"""
		def init(s as String)
			pass
		get string as String
			return ''
		
	class Html
		"""
		Represents HTML that doesn't need to be encoded.
		Html.toString returns the contents as-is.
		"""
		var _contents as String
		def init(contents as String)
			_contents = contents
		get contents from var
		def toString as String is override
			return _contents

	class ObjectCatalog

		test
			cat = ObjectCatalog()
			assert cat.maxSerialNum == 0

			a = Object()
			cat.record(a)
			assert cat.maxSerialNum == 1000
			assert cat.contains(a)
			assert cat.serialNumFor(a) == 1000
			assert cat.objectFor(1000) is a

			b = Object()
			cat.record(b)
			assert cat.maxSerialNum == 1001
			assert cat.serialNumFor(a) == 1000
			assert cat.serialNumFor(b) == 1001
			assert cat.objectFor(1000) is a
			assert cat.objectFor(1001) is b

		var _objectToSerialNum = Dictionary<of Object, int>()
		var _serialNumToObject = Dictionary<of int, Object>()
		var _minSerialNum = 0
		var _maxSerialNum = 0

		def init
			pass

		get minSerialNum from var
		
		get maxSerialNum from var

		def contains(obj as Object) as bool
			return _objectToSerialNum.containsKey(obj)

		def contains(serialNum as int) as bool
			return _serialNumToObject.containsKey(serialNum)

		def record(obj as Object)
			ensure .contains(obj)
			if not _objectToSerialNum.containsKey(obj)
				_maxSerialNum = _objectToSerialNum.count + 1000
				_objectToSerialNum.add(obj, _maxSerialNum)
				_serialNumToObject.add(_maxSerialNum, obj)
				if _minSerialNum == 0
					_minSerialNum = _maxSerialNum

		def serialNumFor(obj as Object) as int
			require
				.contains(obj)
			ensure
				result >= 1000
				.contains(result)
			body
				return _objectToSerialNum[obj]

		def objectFor(serialNum as int) as Object
			require
				.contains(serialNum)
			ensure 
				.contains(result)
			body
				return _serialNumToObject[serialNum]

	class CobraInfo
		is extern

		get cobraPath as String is shared
			"""
			The Path of the cobra compiler executable that created this program.
			"""
			pass

	interface IHasSourceSite
		get sourceSite as SourceSite

	class SourceSite
		"""
		A SourceSite instance captures the source location of a statement or expression, as in the
		filename, line number, declaring class name, method name and run-time object. The Cobra
		compiler generates SourceSite instances in various circumstances; for example, the `trace`
		statement.
		"""

		var _fileName as String
		var _lineNum as int
		var _className as String
		var _memberName as String
		var _object as Object

		def init(fileName as String, lineNum as int, className as String, memberName as String, obj as Object)
			_fileName = fileName
			_lineNum = lineNum
			_className = className
			_memberName = memberName
			_object = obj

		def toString as String is override
			#fileName = CobraCore.toTechString(_fileName)
			#className = CobraCore.toTechString(_className)
			#memberName = CobraCore.toTechString(_memberName)
			#obj = CobraCore.toTechString(_object)
			#return '[.getType.name]([fileName], [_lineNum], [className], [memberName], [obj])'
			return '[_fileName]:[_lineNum] in [_className].[_memberName] for object [CobraCore.toTechString(_object)]'

		get fileName from var

		get lineNum from var

		get className from var

		get memberName from var

		get object from var

		get runTimeClassName as String
			return _object.getType.name

		def oneLiner(sep as String) as String
			return .oneLiner(sep, true)

		def oneLiner(sep as String, willOutputDirectoryNames as bool) as String
			test
				si = SourceSite('Foo.cobra', 10, 'Object', 'bar', Object())
				assert si.oneLiner('; ', true) == 'at Foo.cobra:10; in Object.bar'
				si = SourceSite('Foo.cobra', 10, 'Foo', 'bar', Object())
				assert si.oneLiner('; ', true) == 'at Foo.cobra:10; in Foo.bar; subclass Object'
			body
				sb = StringBuilder()
				fileName = if(_fileName.length and not willOutputDirectoryNames, Path.getFileName(_fileName), _fileName)
				sb.append('at [fileName]:[_lineNum][sep]in [_className].[_memberName]')
				if not _object inherits Type
					# I guess that condition would preclude reporting the subclass name in a trace statement in subclasses of Type
					# But then those come with the system anyway (RuntimeType)
					name = .runTimeClassName
					if name <> _className
						sb.append('[sep]subclass [name]')
				return sb.toString

		def htmlForAt as String
			return .htmlForAtArgs(_fileName, _lineNum)

		def htmlForAtArgs(fileName as String, lineNum as int) as String is shared
			"""
			Returns the HTML for the row labeled "at" in the Cobra Exception Report.
			This will be an actual link if the environment variable COBRA_EDIT_LINK is set.
			That's what enables clicking on sources in the report to jump to their location in a text editor.
			"""
			baseName = Path.getFileName(fileName)
			dirName = Path.getDirectoryName(fileName)
			if dirName <> ''
				dirName = ' in ' + (dirName to !)
			s = 'line [lineNum] of [baseName][dirName]'
			editLink = Environment.getEnvironmentVariable('COBRA_EDIT_LINK')
			if editLink
				editLink = editLink.replace('FILE', fileName)  # TODO: url encode the file name
				editLink = editLink.replace('LINE', lineNum.toString)
				s = '<a href="[editLink]">[s]</a>'
			return s

			
	class ExceptionReportWriter
		is abstract
	
		def writeReport(tw as TextWriter, exc as Exception?)
			.writeReport(tw, exc, CobraImp.detailedStackTrace)

		def writeReport(tw as TextWriter, exc as Exception?, frames as Stack<of CobraFrame>) is abstract


	class TextExceptionReportWriter
		inherits ExceptionReportWriter

		def writeReport(tw as TextWriter, exc as Exception?, frames as Stack<of CobraFrame>) is override
			# dump the most recent stack frames last since the text will output top-down and scroll in the shell
			tw.writeLine('Stack trace:')
			if not frames.count
				tw.writeLine('No stack frames.')
			else
				i = 0
				for frame in frames
					frame.dumpText(tw, i)
					i += 1


	class CobraFrame
	
		var _declClassName as String
		var _methodName as String
		var _fileName as String
		var _lineNum as int is public
		var _args as Object[]
		var _locals as Dictionary<of String, dynamic?>
		var _localNamesInOrder as List<of String>
		
		def init(declClassName as String, methodName as String, fileName as String, lineNum as int, args as vari Object)
			"""
			args should have the arg names embedded: "x", x, "y", y
			"""
			_declClassName = declClassName
			_methodName = methodName
			_fileName = fileName
			_lineNum = lineNum
			_args = $sharp(r'(object[])args.Clone()')
			_locals = Dictionary<of String, dynamic?>()
			_localNamesInOrder = List<of String>()
			for j = 0 .. _args.length ++ 2
				.setLocal(_args[j] to String, _args[j+1])

		def setLocal(name as String, value as dynamic?)
			if not _locals.containsKey(name)
				_localNamesInOrder.add(name)
			_locals[name] = value

		def dumpText(tw as TextWriter, i as int)
			nameWidth = 8
			tw.writeLine('\n    [i]. [this]')
			tw.writeLine('        args')
			for j = 0 .. _args.length ++ 2
				tw.write(String.format('               {0} = ', (_args[j] to String).padRight(nameWidth)))
				try
					s = CobraCore.toTechString(_args[j+1])
				catch e as Exception
					s = 'ToString() Exception: ' + e.message
				tw.writeLine(s)
			tw.writeLine('        locals')
			for name in _localNamesInOrder
				if name == 'this'
					continue
				tw.write(String.format('               {0} = ', name.padRight(nameWidth)))
				try
					s = CobraCore.toTechString(_locals[name])
				catch e as Exception
					s = 'ToString() Exception: ' + e.message
				tw.writeLine(s)

		# TODO: move this to HtmlExceptionReportWriter as an extend CobraFrame
		def dumpHtml(tw as TextWriter, i as int, objects as ObjectCatalog, willDumpHtmlFor as WillDumpHtmlForMethod)
			# record objects
			for localValue in _locals.values
				if localValue is not nil and willDumpHtmlFor(localValue)
					objects.record(localValue to !)
			# write frame html
			tw.writeLine
			tw.writeLine('<tr class=frameHead> <td class=number> [i]. </td> <td class=qualifiedMember colspan=4> [_declClassName].[_methodName] </td> </tr> ')
			tw.writeLine('<tr class=frameDetails1> <td class=indent> &nbsp; </td> <td class=label width=1> at: </td> <td class=sourceLocation colspan=3> [SourceSite.htmlForAtArgs(_fileName, _lineNum)] </td> </tr>')
			rowNum = 1
			for j = 0 .. _args.length ++ 2
				name = _args[j] to String
				value = _args[j+1] to dynamic?
				label = if(j==0, 'args:', '')
				tw.write('<tr class=frameDetails[rowNum%2+1]> <td class=indent> &nbsp; </td> <td class=label width=1> [label] </td> <td width=1> [name] </td> <td width=1> &nbsp;=&nbsp; </td>')
				try
					s = CobraCore.htmlEncode(CobraCore.toTechString(value))
				catch e as Exception
					s = 'ToString() Exception: ' + e.message
				if willDumpHtmlFor(value)
					s = '<a class=objectDetails href=#Object[objects.serialNumFor(value to passthrough)]>[s]</a>'
				tw.writeLine('<td> [s] </td> </tr>')
				rowNum += 1
			first = true
			for name in _localNamesInOrder
				if name == 'this'
					continue
				label = if(first, 'locals:', '')
				tw.write('<tr class=frameDetails[rowNum%2+1] valign=top> <td class=indent> &nbsp; </td> <td class=label width=1> [label] </td> <td width=1> [name] </td> <td width=1> &nbsp;=&nbsp; </td>')
				value = _locals[name]
				try
					s = CobraCore.htmlEncode(CobraCore.toTechString(value))
				catch e as Exception
					s = 'ToString() Exception: ' + e.message
				if willDumpHtmlFor(value)
					s = '<a class=objectDetails href=#Object[objects.serialNumFor(value to passthrough)]>[s]</a>'
				tw.writeLine('<td> [s] </td> </tr>')
				first = false
				rowNum += 1
			tw.writeLine('<tr class=blank> <td colspan=4> &nbsp; </td> </tr>')

		def toString as String is override
			return 'def [_declClassName].[_methodName] at line [_lineNum]'

		def copy as CobraFrame
			return .memberwiseClone to CobraFrame

	interface ISet<of T>
		inherits ICollection<of T>, IEnumerable<of T>, ISet

		## Collection type operations

		def addRange(items as IEnumerable<of T>)
		
		## Set operations
	
		def isSubsetOf(s as ISet<of T>) as bool
		def isSupersetOf(s as ISet<of T>) as bool
		def intersection(s as ISet<of T>) as ISet<of T>
		def union(s as ISet<of T>) as ISet<of T>
		def difference(s as ISet<of T>) as ISet<of T>
		def symmetricDifference(s as ISet<of T>) as ISet<of T>
		def toList as List<of T>

		
	class Set<of T>
		implements ISet<of T>, ICollection<of T>, IEnumerable<of T>
		"""
		A Set holds a hashed, unordered collections of items.
		Membership testing and set operations (intersection, union, etc.) are faster than with lists, but order is not preserved.
		Set implements ICollection, so it has the usual collection operations such as `add`, `count` and `contains`.
		It also has set specific operations including `union`, `intersection` and `isSubsetOf`.

		As with other collections, to create a copy of a set, create a new one passing the original to the initializer:
			s = Set<of int>(s)

		TODO:
			[-] List style items
			[ ] Can the methods use .getType instead of hardcoding Set? Then subclasses would get created for example .intersection
			[ ] could use an indexer: s[key].  Does it return bool or T? like NSSet?
			[ ] Test without args: s = Set(s)  (test in C# too)
			[ ] yielded versions of Set operators?
			[ ] unit test CobraCore.toTechString() results
			[ ] ReadOnlySet?
			[ ] Move some method implementations up to ISet extension
		"""
	
		var _data as Dictionary<of T, T>


		## Initialization
	
		def init
			_data = Dictionary<of T, T>()

		def init(capacity as int)
			_data = Dictionary<of T, T>(capacity)

		def init(items as IEnumerable<of T>)
			# CC: ensure for item in items assert .contains(item)    or,
			# CC: ensure for item in items get .contains(item)
			_data = Dictionary<of T, T>()
			for item in items
				_data[item] = item


		## IEnumerable
	
		def getEnumerator as IEnumerator<of T>
			return _data.keys.getEnumerator

		def getEnumerator as System.Collections.IEnumerator
			implements System.Collections.IEnumerable
			return .getEnumerator to System.Collections.IEnumerator
	
	
		## Object
	
		def equals(other as Object?) as bool is override
			# TODO: could this be more efficient?
			if other inherits Set<of T>
				if .count <> other.count
					return false
				for item in this
					if not other.contains(item)
						return false
				for item in other
					if not .contains(item)
						return false
				return true
			else if other inherits ISet
				# TODO: cleanup the following
				if .countOfISet <> other.countOfISet
					return false
				for item in this
					if not other.contains(item)
						return false
				for item2 in other
					if not sharp'item2 is T'
						return false
					if not .contains(item2 to T)
						return false
				return true
			else
				return false

		def getHashCode as int
			code = base.getHashCode
			for item in this
				code ^= item.getHashCode
			return code


		## ICollection
	
		def add(item as T)
			ensure .contains(item)
			_data[item] = item

		def clear
			ensure .count == 0
			_data.clear

		def copyTo(array as T[], arrayIndex as int)
			_data.keys.copyTo(array, arrayIndex)

		get count as int
			ensure result >= 0
			return _data.count
		
		def contains(item as T) as bool
			return _data.containsKey(item)

		get isReadOnly as bool
			return false

		def remove(item as T) as bool
			ensure
				not .contains(item)
				# .contains(item) implies result  TODO: How to say "old this"?
			body
				return _data.remove(item)


		# ISet
		
		get countOfISet as int
			return _data.count

		def contains(item as Object) as bool
			implements ISet
			return if(sharp'item is T', .contains(item to T), false)


		## Set operations
	
		def isSubsetOf(s as ISet<of T>) as bool
			for item in this
				if not s.contains(item)
					return false
			return true

		def isSupersetOf(s as ISet<of T>) as bool
			return s.isSubsetOf(this)

		def intersection(s as ISet<of T>) as ISet<of T>
			"""
			Returns a new set containing only the elements that are in this set and `s`. (AND)
			"""
			r = Set<of T>()
			for item in this
				if s.contains(item)
					r.add(item)
			return r

		def union(s as ISet<of T>) as ISet<of T>
			"""
			Returns a new set containing the elements of that are in this set or `s`. (OR)
			"""
			r = Set<of T>(this)
			r.addRange(s)
			return r
	
		def difference(s as ISet<of T>) as ISet<of T>
			"""
			Returns a new set with elements in this set that are not in `s`.
			"""
			r = Set<of T>()
			for item in this
				if not s.contains(item)
					r.add(item)
			return r

		def symmetricDifference(s as ISet<of T>) as ISet<of T>
			"""
			Returns a new set with elements in either s or t but not both. (XOR)
			"""
			r = Set<of T>()
			for item in this
				if not s.contains(item)
					r.add(item)
			for item in s
				if not .contains(item)
					r.add(item)
			return r


		## List<of T>-inspired Members
	
		def addRange(items as ISet<of T>)
			# ensure all (for item in items get .contains(item))
			for item in items
				.add(item)
	
		def addRange(items as IEnumerable<of T>)
			for item in items
				.add(item)

		#def asReadOnly as ReadOnlyCollection<of T>
			# TODO

		# TODO
		#def convertAll<of TOutput>(converter as Converter<of T, TOutput>) as Set<of TOutput>
		#	newSet = Set<of TOutput>()
		#	for item in this
		#		newSet.add(converter(item))
		#	return newSet

		# TODO
		#def exists(predicate as Predicate<of T>) as bool
		#	for item in this
		#		if predicate(item)
		#			return true
		#	return false
		
		# TODO: find
		# TODO: findAll
		# TODO: forEach (or for)
		# TODO: removeAll
		# TODO: trueForAll

		## Other
		
		def toList as List<of T>
			return List<of T>(this)

	interface ISet
		inherits IEnumerable
		"""
		This interface is to facilitate Set<of>.equals when the generic types are different (which
		does not necessarily restrict the two sets from having the same contents).
		
		Use ISet<of T> instead.
		"""
		get countOfISet as int
		def contains(item as Object) as bool

	class TestSet

		test
			TestSet().run

		def run
			s = Set<of int>()
			assert s.count == 0
			t = Set<of int>()
			assert t.count == 0
			assert s is not t
			assert s == t
		
			s.add(1)
			assert s.contains(1)
			assert not s.contains(2)
			assert s <> t
			assert t.isSubsetOf(s)
			assert s.isSupersetOf(t)
			t.add(1)
			assert s == t
			s.clear
			t.clear
			assert s.count == 0

			u = s.union(t)
			assert t is not u
			assert s.count == 0
			assert t.count == 0
			assert u.count == 0

			s = Set<of int>()
			s.add(1)
			assert s.contains(1)
			assert not s.contains(2)
			
			# remove
			s.remove(1)
			assert s.count == 0
			assert not s.contains(1)

			# double add
			s.add(1)
			s.add(1)
			assert s.count == 1
			assert s.contains(1)

			# make lists and sets from each other
			s = Set<of int>([1, 2])
			assert s.contains(1) and s.contains(2) and s.count == 2
			list = List<of int>(s)
			assert list == [1, 2] or list == [2, 1]

			# repeated element
			s = Set<of int>([1, 1])
			assert s.contains(1) and not s.contains(2) and s.count == 1
			s.add(1)
			assert s.contains(1) and not s.contains(2) and s.count == 1

			# set operations
			r = Set<of int>([1, 2]).intersection(Set<of int>([2, 3]))
			assert r.toList == [2]

			r = Set<of int>([1, 2]).union(Set<of int>([2, 3]))
			list = r.toList
			list.sort
			assert list == [1, 2, 3]
			
			r = Set<of int>([1, 2]).difference(Set<of int>([2, 3]))
			assert r.toList == [1]

			r = Set<of int>([1, 2]).symmetricDifference(Set<of int>([2, 3]))
			assert r.toList == [1, 3] or r.toList == [3, 1]

	extend System.Object

		def toTechString as String
			return CobraImp._techStringMaker.makeString(this)

		def toPrintString as String
			return CobraImp._printStringMaker.makeString(this)

	extend System.Collections.IList

		def swap(i as int, j as int)
			temp = this[i]
			this[i] = this[j]
			this[j] = temp

	class StringMaker
		is abstract
		"""
		StringMaker provides the base capability to create strings from objects.
		Well known subclasses are PrintStringMaker and TechStringMaker.
		
		The main public method is .makeString(x as Object?) as String
		
		Subclasses should set _methodName in .init and override abstract methods like .collectionTypeToString.
		"""
	
		var _level as int
		var _methodName as String
		var _memo = Set<of dynamic>()

		def init
			_methodName = ''  # ideally this wouldn't have to be set here

		get level from var
			"""
			Returns the recursion level of .makeString which starts at 1 and increases.
			Some string makers use this information to alter their output.
			"""

		def makeString(x as Object?, format as String) as String
			"""
			Returns the formatted version of the object.
			This is was created in support of string substitution which can specify format codes such as 'x = [x:N2]'
			Example: sm.makeString(5.0, 'N2')
			"""
			if format.length == 0
				return .makeString(x)
			else
				# Is there a faster way to do this? Some types already have .toString(format as String) overload.
				return String.format('{0:' + format + '}', x) to !

		def makeString(x as Object?) as String
			has MethodImpl(MethodImplOptions.Synchronized)
			if x
				if .isMemoable(x)
					if x in _memo
						return '(Repeated [CobraCore.typeName(x.getType)])'
					_memo.add(x)
			try
				isEnumerable = x inherits System.Collections.IEnumerable
				if isEnumerable, _level += 1
				try
					return _makeString(x)
				finally
					if isEnumerable, _level -= 1
			finally
				if _level < 1, _memo.clear

		def _makeString(x as Object?) as String
			if x is nil
				return .nilToString
	
			if x inherits bool
				return .boolToString(x)

			if x inherits char
				return .charToString(x)

			if x inherits String
				return .stringToString(x)
	
			if _methodName.length
				s = ''
				if .customMethodToString(x to !, inout s)
					return s
	
			if x inherits System.Collections.IList
				return .listToString(x)
	
			if x inherits System.Collections.IDictionary
				return .dictToString(x)
	
			if x inherits ISet
				return .setToString(x)
	
			if x inherits System.Collections.IEnumerable
				# This must come after the above types like IDictionary and ISet.
				return .enumerableToString(x)
	
			if x inherits System.Enum
				return .enumToString(x)
	
			if x inherits StringMaker
				return .stringMakerToString(x)
	
			return .objectToString(x to !)
	
		def isMemoable(x as Object) as bool
			if x inherits String, return false
			if x inherits IEnumerable, return true
			return false

		def boolToString(b as bool) as String
			return if(b, 'true', 'false')

		def charToString(c as char) as String
			return c.toString

		def collectionTypeToString(t as Type) as String is abstract
	
		var _customMethodsCache = Dictionary<of Type, MethodInfo?>()
	
		def customMethodToString(x as Object, s as inout String) as bool
			# There's a nice article on speeding up dynamic dispatch at http://www.codeproject.com/KB/cs/fast_dynamic_properties.aspx
			# The technique below is likely slower than what's in that article.
			type = x.getType
			methodInfo as MethodInfo?
			if not _customMethodsCache.tryGetValue(type, out methodInfo)
				methodInfo = type.getMethod(_methodName)
				_customMethodsCache[type] = methodInfo
			if methodInfo
				try
					s = (methodInfo.invoke(x, nil) to String?) ? ''
				catch exc as TargetInvocationException
					# target invocation exceptions are themselves, not very interesting
					# their inner exception describes the problem
					throw exc.innerException to !
				return true
			else
				return false

		def dictToString(dict as System.Collections.IDictionary) as String
			sb = StringBuilder()
			sb.append(.collectionTypeToString(dict.getType) + '{')
			sep = ''
			hasKeys = false
			for key in dict.keys
				sb.append(sep)
				sb.append(.makeString(key))
				sb.append(': ')
				sb.append(.makeString(dict[key]))
				sep = ', '
				hasKeys = true
			if not hasKeys, sb.append(':')
			sb.append('}')
			return sb.toString
	
		def enumToString(en as Enum) as String
			return en.toString
	
		def enumerableToString(en as System.Collections.IEnumerable) as String
			sb = StringBuilder()
			sb.append(.collectionTypeToString(en.getType) + r'[')
			sep = ''
			for item in en
				sb.append(sep)
				sb.append(.makeString(item))
				sep = ', '
			sb.append(']')
			return sb.toString
	
		def listToString(list as System.Collections.IList) as String
			sb = StringBuilder()
			sb.append(.collectionTypeToString(list.getType) + r'[')
			sep = ''
			for item in list
				sb.append(sep)
				sb.append(.makeString(item))
				sep = ', '
			sb.append(']')
			return sb.toString
	
		def nilToString as String
			return 'nil'
	
		def objectToString(obj as Object) as String
			return obj.toString
			
		def setToString(s as ISet) as String
			sb = StringBuilder()
			sb.append(.collectionTypeToString(s.getType) + '{')
			sep = ''
			hasItems = false
			for item in s
				sb.append(sep)
				sb.append(.makeString(item))
				sep = ', '
				hasItems = true
			if not hasItems, sb.append(',')
			sb.append('}')
			return sb.toString
	
		def stringToString(s as String) as String
			return s
	
		def charToCobraLiteral(c as char) as String
			return 'c' + .stringToCobraLiteral(c.toString)

		def stringToCobraLiteral(s as String) as String
			# TODO: not complete. and upon completing a single pass would be better
			s = s.replace('\n', '\\n')
			s = s.replace('\r', '\\r')
			s = s.replace('\t', '\\t')
			s = "'" + s + "'"  # TODO: could be more sophisticated with respect to ' and "
			return s
	
		def stringMakerToString(sm as StringMaker) as String
			return '[sm.getType.name]([.stringToCobraLiteral(sm.toString)])'
	
		def testCases(cases as IList) is protected
			verbose = false
			if verbose
				print
				print .getType.name
			for case as IList in cases
				if verbose
					print case[0], '==> ' stop
					if case[1] inherits IList
						sep = ''
						for item in case[1] to IList
							print sep + item.toString stop
							sep = ' OR '
						print
					else
						print case[1]
				input = case[0]
				answer = .makeString(input)
				if verbose, print '        ' + answer
				if case[1] inherits IList
					# when there is more than one expected, the test is that one of them is given
					for expected in case[1] to IList
						if answer == expected
							found = true
							break
					assert found, {'input': input, 'answer': answer, 'expected': case[1]}
				else
					expected = case[1]
					assert answer == expected
			# test formatting
			assert .makeString(6.0, 'N2') in ['6.00', '6,00']


	class PrintStringMaker
		inherits StringMaker
		"""
		.toPrintString only quotes strings if they are inside collections such as a list or dictionary.
		This is like Python's str() behavior which has worked well in practice.
		"""
	
		def makePrintString(x as Object?) as String
			test
				cases = [
					[nil, 'nil'],
					[true, 'true'],
					[false, 'false'],
					[c'x', 'x'],
					[5, '5'],
					['aoeu', 'aoeu'],
					[[], ns'[]'],
					[[1, 2], ns'[1, 2]'],
					[[[1, 2], [3, 4]], ns'[[1, 2], [3, 4]]'],
					[['x', 'x'], ns"['x', 'x']"],
					[['x', 'x', 'x'], ns"['x', 'x', 'x']"],
					[{:}, '{:}'],
					[{'a': 1, 'b': 2}, ["{'a': 1, 'b': 2}", "{'b': 2, 'a': 1}"]],
					[{'x': [1, 2]}, ns"{'x': [1, 2]}"],
					[{,}, '{,}'],
					[{1, 2}, ['{1, 2}', '{2, 1}']],
					[{'aoeu', 'asdf'}, ["{'aoeu', 'asdf'}", "{'asdf', 'aoeu'}"]],
					[FB.Foo, 'Foo'],
					[FB.Bar, 'Bar'],
					[Object(), 'System.Object'],
					[TestDefaultToString(), 'Test Default To String'],
					[CustomToString(), '-- to print string --'],
					[CustomToString(), '-- to print string --'],
					[EnumerableToString(), ns'[1, 2, 3]'],
					[@[1, 2, 3], ns'[1, 2, 3]'],
				]
				list = []
				list.add(list)
				cases.add([list, ns'[(Repeated List<of Object>)]'])
				innerList = [1]
				outerList = [innerList, innerList, innerList]
				cases.add([outerList, ns'[[1], (Repeated List<of int>), (Repeated List<of int>)]'])
				PrintStringMaker().testCases(cases)

				n = NestedToString()
				answer = r'[[1, 2, 3], [1, 2, 3]]'
				assert PrintStringMaker().makeString(n) == answer
				assert Cobra.Lang.CobraCore.printStringMaker.makeString(n) == answer
				assert '[n]' == answer
			body
				return .makeString(x)
	
		def init
			base.init
			_methodName = 'ToPrintString'
	
		def collectionTypeToString(t as Type) as String is override
			return ''
	
		def stringToString(s as String) as String is override
			if .level == 1
				return s
			else
				return .stringToCobraLiteral(s)
	
	
	class TechStringMaker
		inherits StringMaker
		"""
		TechStringMaker stands for "technical string maker" and is used for inspection and debugging.
		
		It's the default string maker for the AssertException (and its subclasses such as RequireException)
		and the trace statement.
		
		It provides more information about collections and enumerations.

		It recovers from exceptions when making strings so that debugging can proceed.
		
		Idea: Could use a flag to control if _makeString recovers from exceptions.
		
		Idea: TechStringMaker should look for .toPrintString after looking for .toTechString.
		"""
	
		def makeTechString(x as Object?) as String
			test
				cases = [
					[nil, 'nil'],
					[true, 'true'],
					[false, 'false'],
					[c'x', "c'x'"],
					[5, '5'],
					['aoeu', "'aoeu'"],
					[[], ns'List<of Object>[]'],
					[[1, 2], ns'List<of int>[1, 2]'],
					[[[1, 2], [3, 4]], ns'List<of List<of int>>[List<of int>[1, 2], List<of int>[3, 4]]'],
					[['x', 'x'], ns"List<of String>['x', 'x']"],
					[['x', 'x', 'x'], ns"List<of String>['x', 'x', 'x']"],
					[{:}, 'Dictionary<of Object, Object>{:}'],
					[{'a': 1, 'b': 2}, ["Dictionary<of String, int>{'a': 1, 'b': 2}", "{'b': 2, 'a': 1}"]],
					[{'x': [1, 2]}, ns"Dictionary<of String, List<of int>>{'x': List<of int>[1, 2]}"],
					[{,}, 'Set<of Object>{,}'],
					[{1, 2}, ['Set<of int>{1, 2}', 'Set<of int>{2, 1}']],
					[{'aoeu', 'asdf'}, ["Set<of int>{'aoeu', 'asdf'}", "Set<of int>{'asdf', 'aoeu'}"]],
					[FB.Foo, 'FB.Foo enum'],
					[FB.Bar, 'FB.Bar enum'],
					[Object(), 'System.Object'],
					[TestDefaultToString(), 'Test Default To String (TestDefaultToString)'],
					[CustomToString(), '-- to tech string --'],
					[CustomToString(), '-- to tech string --'],
					[EnumerableToString(), ns'EnumerableToString[1, 2, 3]'],
					[@[1, 2, 3], ns'Int32[][1, 2, 3]'],
				]
				list = []
				list.add(list)
				cases.add([list, ns'List<of Object>[(Repeated List<of Object>)]'])
				innerList = [1]
				outerList = [innerList, innerList, innerList]
				cases.add([outerList, ns'List<of List<of int>>[List<of int>[1], (Repeated List<of int>), (Repeated List<of int>)]'])
				TechStringMaker().testCases(cases)
			body
				return .makeString(x)
	
		def init
			base.init
			_methodName = 'ToTechString'
	
		def _makeString(x as Object?) as String
			test
				s = TechStringMaker().makeString(BadToTechString())
				assert s == '(Exception on a BadToTechString: InvalidOperationException: foo)'
			body
				try
					return base._makeString(x)
				catch exc as Exception
					return '(Exception' + if(x, ' on a [x.getType.name]', '') + ': [exc.getType.name]: [exc.message])'

		def enumToString(en as Enum) as String is override
			# Example: 'Color.Red enum'
			# as opposed to just 'Red'
			return en.getType.name + '.' + en.toString + ' enum'
	
		def collectionTypeToString(t as Type) as String is override
			return CobraCore.typeName(t)
	
		def objectToString(obj as Object) as String is override
			# Examples: '5 (Int64)'  'System.Object'  'Void Compute (MethodInfo)'
			s = obj.toString
			if .isInterestingType(obj.getType)
				typeName = obj.getType.name
				if not typeName in s and not obj inherits CobraDirectString
					s = '[s] ([typeName])'
			return s
	
		def charToString(c as char) as String is override
			return .charToCobraLiteral(c)

		def stringToString(s as String) as String is override
			return .stringToCobraLiteral(s)
	
		def isInterestingType(t as Type) as bool
			test
				b = TechStringMaker()
				assert not b.isInterestingType(5.getType)
				assert not b.isInterestingType(c'a'.getType)
				assert not b.isInterestingType(true.getType)
				assert b.isInterestingType(IDisposable)
			body
				if t is Int32, return false
				if t is Char, return false
				if t is Boolean, return false
				return true
	
	
	## For testing
	
	enum FB
		Foo
		Bar

	
	class TestDefaultToString
	
		def toString as String is override
			# return something different than the class name to tease out the different behavior that toTechString exhibits in this case (which is to add the class name to the .toString output)
			return 'Test Default To String'


	class NestedToString

		def toPrintString as String
			sb = StringBuilder(r'[')
			sep = ''
			for row in [[1, 2, 3], [1, 2, 3]]
				sb.append('[sep][row]')
				sep = ', '
			sb.append(']')
			return sb.toString


	class CustomToString

		def toPrintString as String
			return '-- to print string --'
	
		def toTechString as String
			return '-- to tech string --'


	class EnumerableToString
		implements System.Collections.IEnumerable
		
		def getEnumerator as System.Collections.IEnumerator
			return [1, 2, 3].getEnumerator


	class BadToTechString

		def toTechString as String
			throw InvalidOperationException('foo')

	class TestAid

		def testGenMethod1<of T>(t as T)
			pass

		def testGenMethod2<of T>(t as T) as T
			return t

		shared
		
			def testGenMethod3<of T>(t as T)
				pass

			def testGenMethod4<of T>(t as T) as T
				return t
