"""
The code in this file should not .throwError, record warnings, etc.
All of that happens during .bindFoo phases.
"""


##
## Compiler
##

class Compiler is partial

	def computeOutNameJava as String
		outName =''
		if .options.boolValue('test')
			outName = _modules.last.javaFileName
		else if .options.containsKey('out')
			outName = .options.getDefault('out', '')
		if outName == '', outName = .defaultOutName to !
		if outName.endsWith('.java') or outName.endsWith('.JAVA'), outName = outName[:-5]
		if outName.endsWith('.cobra') or outName.endsWith('.COBRA'), outName = outName[:-6]
		_baseExeFileName = outName

		outName = Utils.forceExtension(outName, '.class')
		_fullExeFileName = outName
		return outName
		
	def writeJava
		Node.setCompiler(this)
		try
			pass
			_moduleFileName_to_curlyToCobraLineNum = Dictionary<of String, Dictionary<of int, int>>()
			for _curModule in _modules
				if not _curModule.fileName.endsWith('SystemInterfaces.cobra')
					javaToCobraLineNum = _curModule.writeJavaDef
					_moduleFileName_to_curlyToCobraLineNum[_curModule.fileName] = javaToCobraLineNum
					_moduleFileName_to_curlyToCobraLineNum[Path.getFullPath(_curModule.fileName)] = javaToCobraLineNum
		finally
			Node.setCompiler(nil)

	def writeJavaTestInvocation
		# TODO
		pass

	def compileJava
		.compileJava('')

	def compileJava(extraJavacOptions as String)
		require
			.modules.count
		body
			if .verbosity >= 2, print 'Compiling generated code'
			options = .options

			# locate the Java compiler
			compilerPath = options.getDefault('native-compiler', '') to String
			if compilerPath <> ''
				if File.exists(compilerPath)
					pass
				else if File.exists(compilerPath+'.exe')
					compilerPath += '.exe'
				else
					print 'Cannot find compiler specified by -native-compiler argument: [compilerPath]'
					throw StopCompilation(this)
			else
				compilerPath = if(Utils.isRunningOnUnix, 'javac', 'javac.exe')
			
			optChar = '-'
			
			# exeNames
			outName = .computeOutNameJava

			# compute backEndOptions
			backEndOptions = ''
			# -optimize isn't supported by JVM, but it could potentially be used by Cobra itself
			
			# TODO:
#			for refer in .loadedReferences  # don't take the library references from options, because the references can grow
#				backEndOptions += ' "[optChar]r:[refer]"'

			debug = options.getDefault('debug', '') to String
			if debug.length
				# TODO: mono does not support full and pdbonly afaik
				assert debug in ['-', '+', 'full', 'pdbonly'], debug
				backEndOptions += ' [optChar]g' + if(debug=='-', ':none', '')

			# TODO: not until the java backend is more mature
			# backEndOptions += ' -nowarn'
			
			backEndOptions += ' ' + extraJavacOptions
			
			nativeArgs = .options.getDefault('native-compiler-args', '') to String
			if nativeArgs.length
				if nativeArgs.length > 2 and nativeArgs[0]=="'" and nativeArgs[nativeArgs.length-1]=="'"
					# on Windows, you should really use double quotes instead of single, but
					# we try to compensate here.
					nativeArgs = nativeArgs[1:-1]
				backEndOptions += ' ' + nativeArgs

			for libPath in .options.getStringList('library-directory')
				backEndOptions += ' ' + '-classpath "[libPath]"'

			# Cobra.Lang.dll is in the same directory as cobra.exe
			libPath = Path.getDirectoryName(CobraCore.exePath) to !
			backEndOptions += ' ' + '-classpath "[libPath]"'

			# .java files
			javaFileNameList = List<of String>()
			for module in _modules[1:]
				if module.javaFileName.length
					javaFileNameList.add(module.javaFileName)

			# compilation command
			if _verbosity
				print 'Compiling to produce [outName]'

			# TODO: need to encapsulate this in CobraCore to avoid .NET dependency
			p = System.Diagnostics.Process()
			p.startInfo.fileName = compilerPath
			javaFileNames = (for fileName in javaFileNameList get '"' + fileName + '"').join(' ')
			p.startInfo.arguments = '[backEndOptions] [javaFileNames]'
			if _verbosity >= 2
				print '[p.startInfo.fileName] [p.startInfo.arguments]'
			output = CobraCore.runAndCaptureAllOutput(p)
			# TODO: check p.exitCode, especially if output is empty
			_parseJavaCompilerOutput(output)

			if .errors.count
				_exitFromErrors

			_deleteIntermediateFiles

	def _parseJavaCompilerOutput(output as String)
		for line in output.split(c'\n')
			line = line.trim
			if not line.length, continue
			if JavaCompilationMessage.willSkipMessage(line)
				continue
			else
				if _verbosity >= 3
					print 'javac message: [line]'
				_addMessage(JavaCompilationMessage(line, this))
			

##
## Node
##

class Node is partial

	def writeJavaDef(sw as CurlyWriter)
		require .didBindInt or .didBindImp
		pass


class SyntaxNode is partial

	def writeJavaDef(sw as CurlyWriter)
		base.writeJavaDef(sw)
		sw.node(this)


interface INamedNode is partial

	get javaName as String
		"""
		Return the name that should be used in Java source code.
		"""


class NamedNode is partial

	get javaName as String
		return _name

	get javaRef as String
		return .javaName


##
## Module
##

class Module is partial

	var _javaFileName = ''

	get javaFileName from var

	get javaSource as String
		if _javaFileName.length
			return File.readAllText(_javaFileName)
		else
			throw FallThroughException('csFileName is blank')

	def writeJavaDef as Dictionary<of int, int>? is abstract

	def writeJavaTestInvocation(sw as CurlyWriter)
		pass


class SharpModule is partial  # Sharp Module

	def writeJavaDef as Dictionary<of int, int>? is override
		assert false
		return nil


class JavaModule is partial
	"""
	The purpose of a Java module is to allow the programmer to include .java source for Cobra to
	incorporate in the final compilation.
	"""

	cue init(fileName as String, verbosity as int)
		base.init(fileName, verbosity, '')
		_javaFileName = fileName

	def writeJavaDef as Dictionary<of int, int>? is override
		if false
			# kind of silly, but it works:
			d = Dictionary<of int, int>()
			for i in 1 : File.readAllText(_javaFileName).count(c'\n')+1
				d[i] = i
			return d	
		return nil


class AssemblyModule is partial

	get javaSource as String is override
		return '(no Java source for [this])'

	def writeJavaDef as Dictionary<of int, int>? is override
		return nil


class CobraModule is partial

	get javaFileName as String is override
		if _javaFileName == '' and not _fileName.endsWith('SystemInterfaces.cobra')
			_javaFileName = _fileName + '.java'
		return _javaFileName

	def writeJavaDef as Dictionary<of int, int>? is override
		file = File.createText(.javaFileName)
		using sw = CurlyWriter(file, CurlyLineNumberTreatment.Comment)
			.compiler.addIntermediateFile(_javaFileName)
			sw.start(.fileName)
			sw.write('// [_javaFileName]\n')
			sw.write('// Generated by Cobra\n')  # TODO: put version number here
			sw.write('// on [DateTime.now]\n')
			# TODO: list op sys
			sw.write('\n')

			# TODO DELME sw.write('using Cobra.Lang = Cobra.Lang[.compiler.embedRunTimeSuffix];\n')
			
			.topNameSpace.writeJavaDef(sw)
			d = sw.curlyToCobraLineNum
		return d

	def writeJavaTestInvocation(sw as CurlyWriter) is override
		# TODO: .topNameSpace.writeJavaTestInvocation(sw)
		pass


##
## Container and friends
##

interface IParentSpace is partial
	
	get javaRef as String


class Container<of TMember> is partial

	get javaInit as String  # TODO: is abstract
		return ''
		
	get javaNameComponent as String
		"""
		Returns a string that can be used in a Java identifier. That means it cannot have special symbols such as period or left bracket.
		"""
		ensure result.length > 0  # TODO? Move to interface
		return .javaRef

	var _javaRef as String?

	get javaRef as String is override
		if _javaRef is nil and .didBindImp
			_javaRef = _computeJavaRef
			return _javaRef to !
		else
			return _computeJavaRef

	get javaParamRef as String
		return .javaRef

	get _computeJavaRef as String
		if .parent
			s = .parent.javaRef
			# TODO: delme
			#if s.length and not s.endsWith('::')  # C# has weird "global::" name
			#	s += '.'
			s += .javaName
		else
			s = .javaName
		return s

	def writeJavaIsNames(sw as CurlyWriter)
		# TODO: look up Java access levels
		
		# TODO: cache this somewhere
		accessLevels = ['public', 'protected', 'internal', 'protected internal', 'private']
		# CC: accessLevels = 'public,protected,internal,protected internal,private'.split(c',')
			# same names in both Cobra and C#

		# TODO:
		# if isNames is nil
		#	isNames = _isNames
		isNames = List<of String>()
		isNames.addRange(_isNames)
		if .defaultAccessLevel.length
			found = false
			for level as String in accessLevels  # CC: axe as
				if level in isNames
					found = true
			if not found
				isNames.insert(0, .defaultAccessLevel)
		isNameJava = {
			# only have to specify the ones that are different
			'shared': 'static',
			'nonvirtual': '',
		}
		sep = ''
		for name in isNames
			name = Utils.getSS(isNameJava to passthrough, name, name) to !
			sw.write(sep)
			sw.write(name)
			sep = ' '
		if sep.length, sw.write(' ')

	def writeJavaTestInvocation(sw as CurlyWriter)
		pass


interface IMember is partial

	def writeJavaDef(sw as CurlyWriter)
		"""
		Write the Java code for this member declaration to the given CurlyWriter.
		"""

	def writeJavaTestInvocation(sw as CurlyWriter)
		"""
		Write the Java call to the test method for this member.
		"""


##
## Namespace
##

class NameSpace is partial

	get javaSuffix as String
		# TODO: not sure how -embed-run-time is going to work on JVM or if it's even needed
		value as Object?
		if not .addOnValues.tryGetValue('JavaSuffix', out value)
			suffix = if(.fullName == 'Cobra.Lang', .compiler.embedRunTimeSuffix, '')
			.addOnValues['javaSuffix'] = suffix
			return suffix
		else
			return value to String

	get javaInit as String is override  # TODO: remove when not a type
		assert false
		return ''

	get javaRef as String is override
		return .fullName + .javaSuffix

	get javaQualifier as String
		ensure result.endsWith('.')
		return .fullName + .javaSuffix + '.'
	
	def writeJavaDef(sw as CurlyWriter) is override
		assert not .isUnified
		base.writeJavaDef(sw)
		# TODO: how to handle namespaces in Cobra
		#if not .isRoot
		#	sw.writeAndIndent('namespace [.name][.javaSuffix] {\n\n')
		for ud in _useDirectives
			ud.writeJavaDef(sw)
		for decl in _declsInOrder
			if decl inherits Box
				.compiler.boxStack.push(decl)
			decl.writeJavaDef(sw)
			if decl inherits Box
				.compiler.boxStack.pop
		# TODO
		#if not .isRoot
		#	sw.dedentAndWrite('} // namespace [.name]\n')

	def writeJavaTestInvocation(sw as CurlyWriter) is override
		for decl in _declsInOrder
			decl.writeJavaTestInvocation(sw)
	

class UseDirective is partial

	pass


##
## Types
##

class BasicLibraryType is partial

	get javaInit as String
		throw NoSourceGenerationException(this)

	get javaName as String
		throw NoSourceGenerationException(this)

	get javaNameComponent as String
		throw NoSourceGenerationException(this)

	get javaParamRef as String
		throw NoSourceGenerationException(this)

	get javaRef as String
		throw NoSourceGenerationException(this)

	def writeJavaDef(sw as CurlyWriter)
		throw NoSourceGenerationException(this)

	def writeJavaTestInvocation(sw as CurlyWriter)
		throw NoSourceGenerationException(this)


interface IType is partial

	get javaInit as String

	get javaNameComponent as String
		"""
		Returns a string that refers to this type and is suitable for embedding in a larger
		identifier (meaning there will be no punction, spaces or Java comments).
		"""

	get javaRef as String
		"""
		Returns a string that refers to this type.
		Examples: 'int'  'List<String>'  'object'
		"""

	get javaParamRef as String
		"""
		# TODO: update doc string to reflect Java accurately
		Returns a string that refers to this type including any necessary parameter declaration
		specification such as Java 'params' or 'out'. Invoked by Param.writeJavaDef.
		"""


class CobraType is partial

	get javaInit as String is abstract

	get javaName as String
		return .name

	get javaNameComponent as String
		name = .name
		i = name.indexOf('/*')  # example: /*dynamic*/object
		if i <> -1
			j = name.indexOf('*/', i)
			name = name[:i] + name[j+2:]
		name = name.replace('.', '_').replace('<', '_').replace('>', '_').replace(', ', '_')
		return name

	get javaRef as String
		return .javaName

	get javaParamRef as String
		return .javaRef

	def writeJavaTestInvocation(sw as CurlyWriter)
		pass


class BoolType is partial

	get javaInit as String is override
		return 'false'


class CharType is partial

	get javaInit as String is override
		return '(char)0'


class DynamicType is partial

	get javaInit as String is override
		return 'null'

	get javaName as String is override
		return '/*dynamic*/java.lang.Object'


class FloatType is partial

	get javaName as String is override
		return _nativeType.fullName


class IntType is partial

	get javaName as String is override
		return _nativeType.fullName


class NilableType is partial

	get javaInit as String is override
		return 'null'

	get javaRef as String is override
		return _wrappedType.javaRef + if(not _wrappedType.isReference, '?', '')


class NilType is partial

	get javaInit as String is override
		return 'null'

	get javaRef as String is override
		return '/*nil*/java.lang.Object'


class AbstractNumberType is partial

	get javaInit as String is override
		return '0'


class PassThroughType is partial

	get javaInit as String is override
		return 'null'

	get javaRef as String is override
		return '/*passthrough*/java.lang.Object'


class StreamType is partial

	get javaInit as String is override
		return 'new Cobra.Lang.EmptyStream<[.theWrappedType.javaRef]>()'

	get javaRef as String is override
		assert .didBindInh and .didBindInt
		return '/*[.name]*/[.box.javaRef]'


class VoidType is partial

	get javaInit as String is override
		throw Exception('Cannot init a void type.')


class WrappedType is partial

	get javaInit as String is override
		return _wrappedType.javaInit


class ArrayType is partial

	get javaRef as String is override
		return '[_wrappedType.javaRef]' + r'[]'

	get javaInit as String is override
		return 'null'


class VariType is partial

	get javaRef as String is override
		return '[_wrappedType.javaRef]' + r'[]'

	get javaParamRef as String is override
		return 'params ' + .javaRef


class UnspecifiedType is partial
	
	get javaInit as String is override
		# TODO: throw Exception('Not expecting code gen for unspecified types.')
		return '!UnspecifiedType!'


##
## Enums
##

# TODO


##
## Boxes
##


class Box is partial

	get javaNameComponent as String is override
		name = .javaName
		i = name.indexOf('/*')  # example: /*dynamic*/object
		if i <> -1
			j = name.indexOf('*/', i)
			name = name[:i] + name[j+2:]
		# qualified types and generics need cleanup
		for ch in '.<>, '
			name = name.replace(ch, c'_')
		return name

	get javaThis as String
		"""
		Returns 'this' as you would expect.
		Overridden by Extension.
		"""
		return 'this'

	get javaKeyWord as String is abstract

	get javaName as String is override
		return _name.replace('<of', '<')

	get _computeJavaRef as String is override
		if _genericParams.count
			sb = StringBuilder()
			# generic
			name = .rootName
			sb.append(name)
			sb.append('<')
			sep = ''
			for param in _genericParams
				sb.append(sep)
				sb.append(param.javaRef)
				sep = ', '
			sb.append('>')
			java = sb.toString
		else
			java = .javaName
		if .parentNameSpace and not .parentNameSpace.isRoot
			java = .parentNameSpace.javaQualifier + java
		else if .parentBox
			java = .parentBox.javaRef + '.' + java
		return java

	def writeJavaDef(sw as CurlyWriter)
		base.writeJavaDef(sw)
		if .isExtern, return
		.compiler.boxStack.push(this)
		try
			assert not .isConstructed
			.writeJavaAttribs(sw)
			.writeJavaIsNames(sw)
			sw.write('[.javaKeyWord] ')
			.writeJavaDefName(sw)
			.writeJavaInheritance(sw)
	
			sep = ''
			for inter in _baseInterfaces
				sw.write(sep)
				sw.write(inter.javaRef)
				sep = ', '
	
			if _genericParams.count
				sw.indent
				for param in _genericParams
					if param inherits GenericParam
						param.writeJavaConstraint(sw)
				sw.dedent
	
			sw.writeAndIndent('{\n')
			.writeJavaInvariantMethod(sw)
			for tm in _testMethods
				.compiler.boxMemberStack.push(tm)
				try,     tm.writeJavaDef(sw)
				finally, .compiler.boxMemberStack.pop
			for decl in _declsInOrder
				if not .willWriteDeclJavaDef(decl), continue
				.compiler.boxMemberStack.push(decl)
				try
					decl.writeJavaDef(sw)
				finally
					.compiler.boxMemberStack.pop
			if .compiler.includeTests
				.writeJavaTest(sw)
			sw.dedentAndWrite('} // [.javaKeyWord] [.name]\n')
			sw.write('\n')
		finally
			.compiler.boxStack.pop

	def willWriteDeclJavaDef(decl) as bool
		return true

	def writeJavaAttribs(sw as CurlyWriter)
		for attrib in _attribs
			attrib.writeJavaDef(sw)

	def writeJavaDefName(sw as CurlyWriter)
		sw.write('[.rootName]')
		if _genericParams.count
			sw.write('<')
			sep = ''
			for param in _genericParams
				sw.write(sep)
				param.writeJavaDef(sw)
				sep = ', '
			sw.write('>')

	def writeJavaInheritance(sw as CurlyWriter)
		"""
		Class uses this to write its base class declaration.
		No box uses this to write interface implementation--that's handled in the Box class.
		"""
		pass

	get javaInvariantVisibility as String is abstract

	def writeJavaInvariantMethod(sw as CurlyWriter)
		if .compiler.options['contracts'] <> 'none'
			sw.write('\nint _ih_invariantGuard;\n\n')
		if .compiler.options['contracts'] <> 'methods'
			return
		sw.write('\n[.javaInvariantVisibility] void invariant_[.rootName]() {\n')
		sw.indent
		if _baseClass and (not _baseClass.isFromBinaryLibrary or _baseClass.declForName('invariant_[_baseClass.rootName]'))
			sw.write('invariant_[_baseClass.rootName]();\n')
		.writeJavaInvariantChecks(sw)
		sw.dedent
		sw.write('}\n\n')

	def writeAllJavaInvariantChecks(sw as CurlyWriter)
		"""
		Writes all Java invariant checks including inherited. In support of -contracts:inline
		"""
		_writeAllJavaInvariantChecks(sw, this)

	def _writeAllJavaInvariantChecks(sw as CurlyWriter, box as Box)
		if box.baseClass and not box.baseClass.isFromBinaryLibrary
			_writeAllJavaInvariantChecks(sw, box.baseClass to !)
		box.writeJavaInvariantChecks(sw)
		
	def writeJavaInvariantChecks(sw as CurlyWriter)
		"""
		Writes the Java invariant checks just for this class.
		"""
		for expr in _invariants
			javaThis = '[.javaName].class'
			sw.write('if (!')
			expr.writeJavaDef(sw)
			sw.write(')\n')
			sw.indent
			sw.write('throw new Cobra.Lang.InvariantException([expr.javaSourceSite(.name, "invariant", javaThis)], ')
			expr.writeJavaBreakdown(sw)
			sw.write('[javaThis], null);\n')
			sw.dedent

	def writeJavaTest(sw as CurlyWriter)
		pass

	var _didWriteJavaTestInvocation = false

	def writeJavaTestInvocation(sw as CurlyWriter) is override
		# used by the test option
		if _didWriteJavaTestInvocation
			return
		if .isExtern
			return
		if .isGenericDef  # sorry, but static methods always require a type arg even if you don't need it. workaround. make another class with a 'test' section that tests the generic class TODO: make Cobra do this, but then watch for use of the generic param!
			return
		assert .parentNameSpace
		sw.write('\t\t[.javaRef].RunTestsIfNeeded();\n')
		_didWriteJavaTestInvocation = true

	get newForJavaTest as String
		return ''


class Class is partial

	get javaInit as String is override
		return 'null'

	get javaInvariantVisibility as String is override
		return 'protected'

	get javaKeyWord as String is override
		return 'class'

	def writeJavaInheritance(sw as CurlyWriter) is override
		sw.write(' extends ')
		if _baseClass
			sw.write(_baseClass.javaRef)
			didWrite = true
		if didWrite
			if _baseInterfaces.count
				sw.write(', ')
			else
				sw.write(' ')

	get newForJavaTest as String is override
		return if(not _baseClass.isExtern, ' new', '')


class Interface is partial

	get javaInit as String is override
		return 'null'

	get javaInvariantVisibility as String is override
		throw ShouldNotCallException(.getType)

	get javaKeyWord as String is override
		return 'interface'

	def writeJavaInheritance(sw as CurlyWriter) is override
		if _baseInterfaces.count
			sw.write(' extends ')

	def writeJavaInvariantMethod(sw as CurlyWriter) is override
		# Even when invariants are inherited by the classes and structs that implement them,
		# the code gen for the interface invariant does not go "here", inside the Java interface definition.
		pass

	def writeJavaTest(sw as CurlyWriter) is override
		# Static methods can't be put in interfaces. However, at some point Cobra should support
		# tests for interfaces which could then be run against the classes that implement them.
		# Just requires more code gen smarts.
		pass

	def writeJavaTestInvocation(sw as CurlyWriter) is override
		pass


class Mixin is partial

	get javaName as String
		name = base.javaName
		if .canHaveStatements
			name += 'Mixin'
		return name
		
	get javaKeyWord as String is override
		return if(.canHaveStatements, 'class', 'interface')

	def willWriteDeclJavaDef(decl) as bool is override
		return not decl inherits BoxVar

	def writeJavaDef(sw as CurlyWriter)
		# write the interface
		_canHaveStatements = false
		base.writeJavaDef(sw)


class Struct is partial

	get javaInit as String is override
		return ''  # blank to indicate there is no valid init

	get javaInvariantVisibility as String is override
		return 'private'

	get javaKeyWord as String is override
		return 'struct'

	def writeJavaInheritance(sw as CurlyWriter) is override
		if _baseInterfaces.count
			sw.write(' extends ')


class MethodSig is partial

	pass # TODO STUB


class GenericParam is partial

	get javaInit as String is override
		# TODO: ack. does Java have anything like this?
		return 'default([_name])'

	def writeJavaDef(sw as CurlyWriter)
		base.writeJavaDef(sw)
		sw.write(.name)

	def writeJavaConstraint(sw as CurlyWriter)
		if _constraints.count
			# TODO
			sw.write(' where [_name] :  ')
			sep = ''
			for constraint in _constraints
				sw.write(sep)
				constraint.writeJavaDef(sw)
				sep = ', '
			sw.write('\n')


class GenericClassConstraint is partial

	def writeJavaDef(sw as CurlyWriter) is override
		sw.write('class')


class GenericStructConstraint is partial

	def writeJavaDef(sw as CurlyWriter) is override
		sw.write('struct')


class GenericCallableConstraint is partial

	def writeJavaDef(sw as CurlyWriter) is override
		sw.write('new()')


class GenericTypeConstraint is partial

	def writeJavaDef(sw as CurlyWriter) is override
		sw.write(_representedType.javaRef)


class Extension is partial

	pass # TODO STUB


##
## Vars
##

interface IVar is partial

	get javaAssignmentNames as List<of String>?
		"""
		Return the Java names to assign to above and beyond the javaName.
		This in support of if-inherits.
		"""

class AbstractLocalVar is partial

	get javaAssignmentNames as List<of String>
		return [_backEndName]
		# return List<of String>(_useBackEndNameStack)

	get javaName as String is override
		if _ifInheritsStack.count
			if _type.isReference
				return '(([_ifInheritsStack.peek.javaRef])[_backEndName])'
			else
				# could it be a subclass? no. value types are structs and cannot be subclassed so this must be `if i` where `i` is nullable struct
				return '[.name].Value'  # Nullable<of T>.Value
		else
			return _backEndName
		# return _useBackEndNameStack.peek to !


class Param is partial

	def writeJavoDef(sw as CurlyWriter)
		base.writeJavaDef(sw)
		if .type.isReference and not .type inherits NilableType
			sw.write(r'[Cobra.Lang.NotNull] ')
		branch .direction
			on Direction.In, pass
			on Direction.InOut, sw.write('ref ')
			on Direction.Out, sw.write('out ')
		sw.write('[.type.javaParamRef] [.javaName]')

	def writeJavaDefSansReferenceLabels(sw as CurlyWriter)
		"""
		Writes the parameter declaration but without Java "out" or "ref"--these are not available for
		contract methods (require_foo and ensure_foo) because contracts cannot modify arguments.
		"""
		# skip the [NotNull] as well since it's not really needed
		sw.write('[.type.javaRef] [.javaName]')		


class LocalVar is partial

	pass


class ResultVar is partial

	get javaName as String is override
		return _backEndName


##
## Members
##


class BoxMember is partial

	var _javaExtraIsNames as Set<of String>?

	pro javaExtraIsNames from var
	
	get javaThis as String
		return if(.isShared, 'typeof([.parentBox.javaName])', .parentBox.javaThis)

	def writeJavaNotNull(sw as CurlyWriter)
		if .resultType.isReference and not .resultType inherits NilableType
			sw.writeLine(r'[' + .javaNotNullPrefix + 'Cobra.Lang.NotNull]')

	get javaNotNullPrefix as String
		# TODO
		# 2007-12-22 Writing the attribute like [return: NotNull] is problematic because MemberInfo.getCustomAttributes()
		# will not see it. At least not on Novell Mono 1.2.4. I don't know if that is a bug or a "feature".
		#return 'return: '
		return ''

	def writeJavaTest(sw as CurlyWriter)
		if _testMethod
			_testMethod.writeJavaDef(sw)

	def writeJavaTestInvocation(sw as CurlyWriter)
		if _testMethod
			sw.write('[_testMethod.javaName]();\n')

	def writeJavaParams(sw as CurlyWriter)
		.writeJavaParams(sw, '()')

	def writeJavaParams(sw as CurlyWriter, parens as String)
		require parens.length==2 or parens==''
		if parens.length
			sw.write(parens[0])
		sep = ''
		for param in .params
			sw.write(sep)
			param.writeJavaDef(sw)
			sep = ', '
		if parens.length
			sw.write(parens[1].toString+' ')

	def writeJavaIsNames(sw as CurlyWriter)
		# TODO:
		# if isNames is nil
		#	isNames = _isNames
		
		# TODO:
		isNameJava = {
			# only have to specify the ones that are different
			'shared': 'static',
			'nonvirtual': '',
		}
		wroteNames = Set<of String>()
		sep = ''
		for name in _isNames
			name = Utils.getSS(isNameJava, name, name) to !
			sw.write(sep)
			sw.write(name)
			sep = ' '
			wroteNames.add(name)
		if _javaExtraIsNames
			for name in _javaExtraIsNames
				if name not in wroteNames
					sw.write(sep)
					sw.write(name)
					sep = ' '
		if sep.length
			sw.write(' ')

	def writeJavaAttribs(sw as CurlyWriter)
		for attrib in _attribs
			attrib.writeJavaDef(sw)


class BoxEvent is partial

	# TODO:
	
	get javaName as String is override
		return .name.capitalized

	def writeJavaDef(sw as CurlyWriter) is override
		base.writeJavaDef(sw)
		.writeJavaAttribs(sw)
		.writeJavaIsNames(sw)
		sw.write('event ')
		sw.write(.handlerType.javaRef)
		sw.write(' [.javaName]')
		sw.write(';\n')


class BoxField is partial

	get _backEndName as String
		name = .name
		if not name.startsWith('_')
			name = name.capitalized
		return name


class BoxConst is partial

	def writeJavaDef(sw as CurlyWriter) is override
		base.writeJavaDef(sw)
		.writeJavaAttribs(sw)
		.writeJavaIsNames(sw)
		sw.write('const ')
		sw.write(_type.javaRef)
		sw.write(' [_backEndName] = ')
		_initExpr.writeJavaDef(sw)
		sw.write(';\n')


class BoxVar is partial

	get javaAssignmentNames as List<of String>
		return [_backEndName]
		# return List<of String>(_useBackEndNameStack)

	get javaName as String is override
		if _ifInheritsStack.count
			if _type.isReference
				return '(([_ifInheritsStack.peek.javaRef])[_backEndName])'
			else
				# could it be a subclass? no. value types are structs and cannot be subclassed so this must be `if i` where `i` is nullable struct
				return '[_backEndName].Value'  # Nullable<of T>.Value
		else
			return .name
		# return _useBackEndNameStack.peek to !

	def writeJavaDef(sw as CurlyWriter) is override
		base.writeJavaDef(sw)
		.writeJavaAttribs(sw)
		.writeJavaIsNames(sw)
		sw.write(_type.javaRef)
		sw.write(' [_backEndName]')
		if _initExpr
			sw.write(' = ')
			_initExpr.writeJavaDef(sw)
		else if .type.isReference and not .type.nonNil inherits GenericParam
			javaInit = .type.javaInit
			if javaInit.length
				sw.write(' = ')
				sw.write(javaInit)
		sw.write(';\n')


class AbstractMethod is partial

	get javaGenericParams as String
		"""
		Can return, for example, '<TKey,TValue>' or ''.
		"""
		ensure ' ' not in result
		return ''

	def writeJavaDef(sw as CurlyWriter)
		base.writeJavaDef(sw)
		.compiler.codeMemberStack.push(this)
		try
			.innerWriteJavaDef(sw)
		finally
			.compiler.codeMemberStack.pop

	def innerWriteJavaDef(sw as CurlyWriter)
		pass
	
	def writeJavaImp(sw as CurlyWriter)
		.compiler.codeMemberStack.push(this)
		try
			sw.writeAndIndent('{\n')
			.writeJavaImpHeader(sw)
			if .compiler.hasDetailedStackTraceOption
				.writeJavaDSTHead(sw)
			for param in _params
				.writeJavaParamCheck(param, sw)
			if _requirePart and _requirePart.willGenerateCode
				_requirePart.writeJavaDef(sw)
			.writeJavaLocals(sw, nil, false)
			willEnsure = _ensurePart and _ensurePart.willGenerateCode
			if willEnsure
				sw.write('boolean _lh_canEnsure = false;\n')
				# have to set `out` parameters or C# will error on them being passed in the `finally` for the ensure,
				# even though the _lh_canEnsure guard logically prevents problems at run-time
				for param in _params
					if param.isOut
						javaInit = param.type.javaInit
						if not javaInit.length
							# TODO/HACK: yes we need something like this (or a way to convice C# that the out param reference in `finally` really is okay),
							# but it should be something less hackish, like an attribute
							javaInit = 'DateTime.Today'
						sw.write('[param.javaName] = [javaInit];')
				if _backEndResultVarName.length  # set in _bindImp
					sw.write('[_returnType.javaRef] [_backEndResultVarName]')
					if _returnType.javaInit.length
						sw.write('= [_returnType.javaInit]')
					sw.write(';\n')
				sw.writeAndIndent('try {\n')
			for stmt in _stmts, stmt.writeJavaStmt(sw)
			if willEnsure
				if not stmt inherits ReturnStmt and not stmt inherits ThrowStmt
					sw.write('_lh_canEnsure = true;\n')
				sw.dedentAndWrite('} finally { // ensure\n')
				sw.indentAndWrite('if (_lh_canEnsure) {\n')
				sw.indent
				_ensurePart.writeJavaDef(sw)
				sw.dedentAndWrite('}\n')
				sw.dedentAndWrite('}\n')
			if .compiler.hasDetailedStackTraceOption
				.writeJavaDSTTail(sw)
			.writeJavaImpFooter(sw)
			sw.dedent
			sw.write('}\n')
			sw.write('\n')
		finally
			.compiler.codeMemberStack.pop

	def writeJavaImpHeader(sw as CurlyWriter)
		pass
		
	def writeJavaImpFooter(sw as CurlyWriter)
		pass
		
	def writeJavaPassArgs(sw as CurlyWriter)
		.writeJavaPassArgs(sw, '()', false)

	def writeJavaPassArgs(sw as CurlyWriter, parens as String, excludeOutArgs as bool)
		require parens.length==2 or parens==''
		if parens.length
			sw.write(parens[0])
		sep = ''
		for param in _params
			if excludeOutArgs and param.isOut
				continue
			sw.write(sep)
			sw.write(param.javaName)
			sep = ', '
		if parens.length
			sw.write(parens[1])

	def writeJavaLocals(sw as CurlyWriter, locals as List<of LocalVar>?, open as bool)
		if open
			sw.writeAndIndent('{\n')
		# record the `old` expressions for `ensure`
		.writeJavaOldAssignments(sw)
		if locals is nil
			locals = _locals
		if locals.count
			sw.write('// locals\n')
			for local in locals
				if not local.isImplicit
					sw.write('[local.type.javaRef] [local.javaName]')
					init = local.type.javaInit
					if init.length, sw.write(' = [init]')
					sw.write(';\n')

	def writeJavaRequireParamDecls(sw as CurlyWriter)
		sep = ''
		for param in .params
			if param.isOut
				# a requirement cannot say anything useful about a parameter that is output only
				continue
			sw.write(sep)
			param.writeJavaDefSansReferenceLabels(sw)  # no `inout/ref` label since a contract cannot modify reference arguments
			sep = ', '
		
	def writeJavaOldAssignments(sw as CurlyWriter)
		if .isOverride and .matchingBaseMember
			(.matchingBaseMember to AbstractMethod).writeJavaOldAssignments(sw)
		for oldExpr in _oldExprs
			oldExpr.writeJavaAssignment(sw)

	def writeJavaEnsureArgs(sw as CurlyWriter)
		if .backEndResultVarName.length
			sw.write('[.backEndResultVarName]')
			sep = [',']
		else
			sep = ['']
		_writeJavaOldArgs(sw, sep)
		if .params.count
			sw.write(sep[0])
		.writeJavaPassArgs(sw, '', false)  # these have to come last, because they might include a C# "params" which has to be last

	def _writeJavaOldArgs(sw as CurlyWriter, sep as List<of String>)
		if .isOverride and .matchingBaseMember
			assert .matchingBaseMember is not this
			(.matchingBaseMember to AbstractMethod)._writeJavaOldArgs(sw, sep)
		for oldExpr in _oldExprs
			sw.write(sep[0])
			sw.write(oldExpr.javaVarName)
			sep[0] = ', '

	def writeJavaEnsureParamDecls(sw as CurlyWriter)
		if .backEndResultVarName.length
			sw.write('[.resultType.javaRef] [.backEndResultVarName]')
			sep = [',']
		else
			sep = ['']
		_writeJavaOldParamDecls(sw, sep)
		# these have to come last, because they might include a C# "params" which has to be last
		for param in .params
			sw.write(sep[0])
			param.writeJavaDefSansReferenceLabels(sw)  # no `out` or `inout/ref` labels since a contract cannot modify reference arguments
			sep[0] = ', '

	def _writeJavaOldParamDecls(sw as CurlyWriter, sep as List<of String>)
		if .isOverride and .matchingBaseMember
			assert .matchingBaseMember is not this
			(.matchingBaseMember to AbstractMethod)._writeJavaOldParamDecls(sw, sep)
		for oldExpr in _oldExprs
			sw.write(sep[0])
			sw.write('[oldExpr.type.javaRef] [oldExpr.javaVarName]')
			sep[0] = ', '

	def writeJavaParamCheck(param as Param, sw as CurlyWriter)
		if .isCompilerGenerated, return
		if param.type.isReference and not param.type inherits NilableType and not param.isOut
			if .compiler.options.boolValue('include-nil-checks')
				sw.write('if (Cobra.Lang.CobraCore._willCheckNil && [param.javaName]==null) throw new System.ArgumentNullException("[param.name]");\n')

	def writeJavaDSTHead(sw as CurlyWriter)
		if not .canHaveDetailedStackTrace
			return
		# could be a neat option, -trace-methods, but maybe done with events:
		# sw.writeLine('Console.WriteLine(">> [.parentBox.name].[.name]");')
		sw.write('Cobra.Lang.CobraImp.PushFrame("[.parentBox.name]", "[.name]", [Utils.javaStringLiteralFor(.token.fullPathName)], [.token.lineNum]')
		if not .isShared
			sw.write(', "this", [.compiler.curBox.javaThis]')
		for param in .params
			if not param.isImplicit and not param.isOut
				sw.write(', "[param.name]", [param.javaName]')
		sw.write(');\n')
		sw.writeAndIndent('try {\n')

	def writeJavaDSTTail(sw as CurlyWriter)
		if not .canHaveDetailedStackTrace
			return
		# sw.writeLine('Console.WriteLine("<< [.parentBox.name].[.name]");')
		# this catch all clashes with yield statements. which is why .canHaveDetailedStackTrace returns false if a method has a yield statement.
		sw.dedentAndWrite('} catch (java.lang.Exception) {\n')
		sw.indent
		sw.write('Cobra.Lang.CobraImp.CaughtUncaughtException();\n')
		sw.write('throw;\n')
		sw.dedentAndWrite('} finally {\n')
		sw.indent
		sw.write('Cobra.Lang.CobraImp.PopFrame();\n')
		sw.dedentAndWrite('}\n')


class Initializer is partial

	def innerWriteJavaDef(sw as CurlyWriter)
		base.innerWriteJavaDef(sw)
		.writeJavaAttribs(sw)
# delme		first = if(_stmts.count, _stmts[0], nil)
# delme		callInitializer as String? = nil
/#
delme
		if first inherits DotExpr
			if first.left inherits ThisOrBaseLit
				if (firstRight = first.right) inherits IDotRightExpr
					if firstRight.name == 'init'
						callInitializer = (first.left to ThisOrBaseLit).asJava
						args = firstRight.args
						Stmt.inInitCall = true
						didSetInInitCall = true
#/
		.writeJavaIsNames(sw)
		sw.write(' [.parentBox.rootName]')
		.writeJavaParams(sw)
/#
delme
		if callInitializer
			sw.writeAndIndent('\n')
			sw.write(': [callInitializer](')
			sep = ''
			for arg in args
				sw.write(sep)
				arg.writeJavaDef(sw)
				sep = ', '
			sw.write(') ')
			sw.dedent
			if didSetInInitCall
				assert Stmt.inInitCall  # make sure it wasn't reset somewhere else
				Stmt.inInitCall = false
#/
		.writeJavaImp(sw)
		if _requirePart, _requirePart.writeJavaMethod(sw)
		if _ensurePart, _ensurePart.writeJavaMethod(sw)
		if .compiler.includeTests
			.writeJavaTest(sw)

	def writeJavaImpHeader(sw as CurlyWriter)
		base.writeJavaImpHeader(sw)
		if .isStructMember and .compiler.options['contracts'] <> 'none'
			sw.write('\n_ih_invariantGuard = 0;\n\n')  # otherwise C# complains: Field "STRUCTNAME._ih_invariantGuard" must be fully assigned before control leaves the constructor
		

class Method is partial

	get javaGenericParams as String is override
		params = .parentBox.extendedMethodGenericParams(_genericParams)
		if params.count
			sb = StringBuilder()
			sb.append('<')
			sep = ''
			for param in params
				sb.append(sep)
				sb.append(param.javaName)
				sep = ','
			sb.append('>')
			return sb.toString
		else
			return ''

	def innerWriteJavaDef(sw as CurlyWriter)
		base.innerWriteJavaDef(sw)
		.writeJavaNotNull(sw)
		.writeJavaAttribs(sw)
		name = .javaName
		returnType = _returnType ? .compiler.voidType
		if _implementsType
			name = _implementsType.javaRef + '.' + name
		.writeJavaIsNames(sw)
		sw.write('[returnType.javaRef] [name][.javaGenericParams]')
		.writeJavaParams(sw)
		if .genericParams.count
			sw.indent
			for param in .genericParams
				if param inherits GenericParam
					param.writeJavaConstraint(sw)
			sw.dedent
		if not .parentBox.canHaveStatements
			sw.write(';\n')
		else
			if .isAbstract, sw.writeLine(';')
			else, .writeJavaImp(sw)
			if _requirePart, _requirePart.writeJavaMethod(sw)
			if _ensurePart, _ensurePart.writeJavaMethod(sw)
			if .compiler.includeTests, .writeJavaTest(sw)

	def writeJavaImpHeader(sw as CurlyWriter)
		base.writeJavaImpHeader(sw)
		if .isMain
			if .compiler.hasExceptionReportOption
				sw.writeLine('try { // Exception Report')
				sw.indent
			else if .compiler.options.boolValue('debugging-tips')
				sw.writeLine('try { // -debugging-tips')
				sw.indent
		if .isMain and .compiler.options.boolValue('include-tests')
			sw.writeLine('Cobra.Lang.CobraCore.RunAllTests();  // turn off with -include-tests:no (see cobra -h)')

	def writeJavaImpFooter(sw as CurlyWriter)
		base.writeJavaImpFooter(sw)
		if .isMain
			if .compiler.hasExceptionReportOption
				sw.dedent
				sw.writeLine('} catch (java.lang.Throwable _lh_exceptionReportThrowable) { Cobra.Lang.CobraCore.HandleUnhandledException(_lh_exceptionReportThrowable); }')
			else if .compiler.options.boolValue('debugging-tips')
				sw.dedent
				sw.writeLine('} catch (java.lang.Throwable _lh_debuggingTipsThrowable) {')
				sw.indent
				sw.writeLine('Cobra.Lang.CobraCore.PrintDebuggingTips();')
				sw.writeLine('throw _lh_debuggingTipsThrowable.fillInStackTrace();')
				sw.dedent
				sw.writeLine('}')

	get javaName as String is override
		return .name.capitalized


class ProperDexer is partial

	# TODO
	pass


class ProperDexerXetter is partial

	# TODO
	pass


class Property is partial

	# TODO
	pass


class Indexer is partial

	# TODO
	pass


class MemberOverload is partial

	pass


class TestMethod is partial

	get javaName as String is override
		if _forMember
			name = 'test_' + _forMember.name.capitalized.replace('Cue.', '_cue_')
			if .overloadId <> -1
				name += '_ol_[.overloadId]'
			return name
		else
			return 'test_[_forBox.javaKeyWord]_'+_forBox.javaNameComponent


class ContractPart is partial

	# TODO
	pass


class RequirePart is partial

	# TODO
	pass


class EnsurePart is partial

	# TODO
	pass


##
## Statements
##

# uu

class Stmt is partial

	def javaSourceSite as String
		"""
		Returns a Java "new SourceSite(...)" expression with the correct arguments for the current code generation.
		"""
		if .compiler.codeMemberStack.count
			codeMember = .compiler.curCodeMember
			return .javaSourceSite(codeMember.parentBox.name, codeMember.name, .javaThis)
		else
			# example: var _x = someExpr ...
			return .javaSourceSite(.compiler.curBox.name, .compiler.curBoxMember.name, .javaThis)
		
	def javaSourceSite(boxName as String, memberName as String, javaThis as String) as String
		"""
		Returns a Java "new SourceSite(...)" expression with the correct arguments for the current code generation.
		The arguments to this method allow for some explicit control in special circumstances, such as `invariant`.
		"""
		require
			boxName.length
			memberName.length
			javaThis.length
		body
			boxName = Utils.javaStringLiteralFor(boxName)
			memberName = Utils.javaStringLiteralFor(memberName)
			tok = .token
			fileName = tok.fileName
			if not Path.isPathRooted(fileName)
				fileName = Path.combine(Environment.currentDirectory, fileName)
			fileName = Utils.javaStringLiteralFor(fileName)
			return 'new Cobra.Lang.SourceSite([fileName], [tok.lineNum], [boxName], [memberName], [javaThis])'

	get javaThis as String
		if _inInitCall  # C# won't allow 'this' in a base constructor call -- TODO
			return '"(uninitialized [.compiler.curBox.name] instance)"'
		else if .compiler.codeMemberStack.count
			return .compiler.curCodeMember.javaThis
		else
			assert .compiler.boxMemberStack.count
			# so not a code member
			return '"(uninitialized [.compiler.curBox.name] instance)"'

	def writeJavaSetLine(sw as CurlyWriter)
		if _canSetLine and .token.lineNum > 0
			sw.write('Cobra.Lang.CobraImp._curFrame._lineNum = [.token.lineNum];\n')

	def writeJavaStmt(sw as CurlyWriter)
		assert .didBindImp
		sw.node(this)
		.writeJavaSetLine(sw)
		.writeJavaDef(sw)


class AssertStmt is partial

	def writeJavaDef(sw as CurlyWriter)
		base.writeJavaDef(sw)
		if not .compiler.options.boolValue('include-asserts')
			return
		sw.write('if (Cobra.Lang.CobraCore._willCheckAssert && !')
		_expr.writeJavaDef(sw)
		sw.write(') ')
		sw.indent
		sw.write('throw new Cobra.Lang.AssertException([.javaSourceSite], ')
		_expr.writeJavaBreakdown(sw)
		sw.write('[.javaThis], ')
		if _info
			_info.writeJavaDef(sw)
		else
			sw.write('null')
		sw.write(');\n')
		sw.dedent


class BlockStmt is partial

	def writeJavaDef(sw as CurlyWriter)
		base.writeJavaDef(sw)
		.writeJavaDef(sw, true, nil)

	def writeJavaDef(sw as CurlyWriter, close as bool)
		.writeJavaDef(sw, close, nil)

	def writeJavaDef(sw as CurlyWriter, top as String?)
		.writeJavaDef(sw, true, top)

	def writeJavaDef(sw as CurlyWriter, close as bool, top as String?)
		sw.node(this)
		sw.write(' {\n')
		sw.indent
		if top, sw.write(top)
		if _ifInheritsVar
			#typeName = _ifInheritsType.javaRef
			#newName = '_lh_' + _ifInheritsVar.name + '_' + _ifInheritsType.javaNameComponent
			#sw.write('[typeName] [newName] = ([typeName])[_ifInheritsVar.javaName];\n')
			#_ifInheritsVar.useBackEndNameStack.push(newName)
			ifInheritsCount = _ifInheritsVar.ifInheritsStack.count  # AssignExpr could pop our _ifInheritsType. We detect that with the count.
			_ifInheritsVar.ifInheritsStack.push(_ifInheritsType)
		for stmt in _stmts, stmt.writeJavaStmt(sw)
		if _ifInheritsVar and _ifInheritsVar.ifInheritsStack.count > ifInheritsCount
			#_ifInheritsVar.useBackEndNameStack.pop
			_ifInheritsVar.ifInheritsStack.pop
		if close
			sw.dedent
			sw.write('}\n')


class BranchStmt is partial

	def writeJavaDef(sw as CurlyWriter)
		base.writeJavaDef(sw)
		if _expr.type.isDynamic
			# if the expression is dynamic, then use an if-else ladder with CobraImp.Equals(
			sw.writeLine('// branch [_expr.toCobraSource]')
			
			varName = '_lh_branch_[.serialNum]'
			sw.write('[_expr.type.javaRef] [varName] = ')
			_expr.writeJavaDef(sw)
			sw.writeLine(';')
						
			elseWord = ''
			for onPart in _onParts
				sw.write('[elseWord]if (')
				sep = ''
				for e in onPart.exprs
					sw.write(sep)
					sw.write('Cobra.Lang.CobraImp.Equals([varName], ')
					e.writeJavaDef(sw, false)
					sw.write(')')
					sep = ' || '
				sw.write(')')
				onPart.block.writeJavaDef(sw)
				elseWord = 'else '
			if _elsePart
				sw.write('else ')
				_elsePart.writeJavaDef(sw)
		else
			# for any other kind of expression, use a Java switch
			sw.write('switch(')
			_expr.writeJavaDef(sw)
			sw.write(') {\n')
			sw.indent
			for onPart in _onParts
				sep = ''
				for e in onPart.exprs
					sw.write(sep)
					sw.write('case ')
					e.writeJavaDef(sw)
					sw.write(': ')
					sep = '\n'
				onPart.block.writeJavaDef(sw)
				if not onPart.block.stmts.count or not onPart.block.stmts.last inherits ReturnStmt
					sw.write('break;\n')
			if _elsePart
				sw.write('default: ')
				_elsePart.writeJavaDef(sw)
				sw.write('break;\n')
			sw.dedent
			sw.write('}\n')


class BreakStmt is partial

	def writeJavaDef(sw as CurlyWriter)
		base.writeJavaDef(sw)
		sw.write('break;\n')


class ContinueStmt is partial

	def writeJavaDef(sw as CurlyWriter)
		base.writeJavaDef(sw)
		sw.write('continue;\n')


class ExpectStmt is partial

	def writeJavaDef(sw as CurlyWriter)
		base.writeJavaDef(sw)
		exceptionTypeRef = _exceptionType.javaRef
		gotRightExceptionVarName = '_lh_expect_[_varNumber-1]'  # lh => "local helper"
		sw.write('boolean [gotRightExceptionVarName] = false;\n')
		sw.write('try ')
		_block.writeJavaDef(sw)
		sw.writeAndIndent('catch ([exceptionTypeRef]) {\n')
		sw.write('// exactly what is expected\n')
		sw.write('[gotRightExceptionVarName] = true;\n')
		sw.dedentAndWrite('}\n')
		if _exceptionType inherits Box and not (_exceptionType to Box).isSystemExceptionClass
			wrongExceptionVarName = '_lh_expect_[_varNumber]'
			assert gotRightExceptionVarName <> wrongExceptionVarName
			sw.writeAndIndent('catch (java.lang.Throwable [wrongExceptionVarName]) {\n')
			sw.write('throw new Cobra.Lang.ExpectException(typeof([exceptionTypeRef]), [wrongExceptionVarName]);\n')
			sw.dedentAndWrite('}\n')
		sw.write('if (![gotRightExceptionVarName]) throw new Cobra.Lang.ExpectException([exceptionTypeRef].getClass(), null);\n')


class ForStmt is partial

	pass


class OldForNumericStmt is partial

	def writeJavaDef(sw as CurlyWriter)
		base.writeJavaDef(sw)
		varName = _var.javaName
		trackLocals = .compiler.willTrackLocals
		if trackLocals
			sw.write('for (Cobra.Lang.CobraImp.SetLocal("[.var.name]", [varName]=')
		else
			sw.write('for ([varName]=')
		_start.writeJavaDef(sw)
		if trackLocals
			sw.write(')')
		if _var.type.isDynamic
			sw.write('; Cobra.Lang.CobraImp.DynamicCompare([varName], ')
			_stop.writeJavaDef(sw, false)
			sw.write(')[if(_dir==1, "<", ">")]0')
			opName = if(_dir==1, 'op_Addition', 'op_Subtraction')
			sw.write('; [varName]=Cobra.Lang.CobraImp.DynamicOp("[opName]", [varName], ')
			if _step, _step.writeJavaDef(sw, false)
			else, sw.write('1')
			sw.write(')')
		else
			sw.write('; [varName]')
			sw.write(if(_dir==1, '<', '>'))
			_stop.writeJavaDef(sw)
			sw.write('; ')
			if _step
				if _dir==1, sw.write('[varName]+=')
				else, sw.write('[varName]-=')
				_step.writeJavaDef(sw)
			else
				if _dir==1, sw.write('[varName]++')
				else, sw.write('[varName]--')
		sw.write(')')
		_block.writeJavaDef(sw)


class ForNumericStmt is partial

	def writeJavaDef(sw as CurlyWriter)
		base.writeJavaDef(sw)
		if _var.type.isDynamic, _writeJavaDefForDynamic(sw)
		else, _writeJavaDefForStatic(sw)
	
	def _writeJavaDefForDynamic(sw as CurlyWriter)
		# TODO: this is the old numeric for loop behavior. 
		varName = _var.javaName
		trackLocals = .compiler.willTrackLocals
		if trackLocals, sw.write('for (Cobra.Lang.CobraImp.SetLocal("[.var.name]", [varName]=')
		else, sw.write('for ([varName]=')
		_start.writeJavaDef(sw)
		if trackLocals
			sw.write(')')
		sw.write('; Cobra.Lang.CobraImp.DynamicCompare([varName], ')
		_stop.writeJavaDef(sw, false)
		sw.write(')[if(_dir==1, "<", ">")]0')
		opName = if(_dir==1, 'op_Addition', 'op_Subtraction')
		sw.write('; [varName]=Cobra.Lang.CobraImp.DynamicOp("[opName]", [varName], ')
		if _step, _step.writeJavaDef(sw, false)
		else, sw.write('1')
		sw.write(')')
		sw.write(')')
		_block.writeJavaDef(sw)

	def _writeJavaDefForStatic(sw as CurlyWriter)
		"""
		Pseudo example:
			Cobra:
				for x in start : stop : step
					statements
			C#:
				{
				type _lh_start_1 = start;
				type _lh_stop_2 = stop;
				type _lh_step_3 = step;
				int _lh_dir_4 = (_lh_stop_2 - _lh_start_1) < 0 ? -1 : +1;
				for (x = start; (_lh_dir_4==-1) ? x > stop : x < stop; x += step) {
					statements
				}
				}
		Note that it's important that the C# code gen uses a for() loop so that
		the "continue" statement still increments the control variable.
		
		In the case that the 'stop' or 'step' are integer literals, no variables are needed for them.
		TODO: If 'stop' or 'step' are const or readonly, same thing.
		"""
		trackLocals = .compiler.willTrackLocals
		sw.write('{ // for [.var.name] in [.start.toCobraSource] : [.stop.toCobraSource]' + if(.step, ' : [.step.toCobraSource]', '') + '\n')
		javaVar = _var.javaName
		javaStart = '_lh_start_[.serialNum]'
		javaStop = '_lh_stop_[.serialNum]'
		javaStep = '_lh_step_[.serialNum]'
		javaDir = '_lh_dir_[.serialNum]'
		javaType = _var.type.javaRef

		sw.write('[javaType] [javaStart] = ')
		.start.writeJavaDef(sw)
		sw.write(';\n')
		
		if .stop inherits IntegerLit
			javaStop = (.stop to IntegerLit).asJava
		else
			sw.write('[javaType] [javaStop] = ')
			.stop.writeJavaDef(sw)
			sw.write(';\n')

		isSimpleStep = false
		step = .step
		if step is nil
			javaStep = '1'
			isSimpleStep = true
		else if step inherits IntegerLit
			javaStep = step.asJava
			isSimpleStep = step.value > 0
		else
			sw.write('[javaType] [javaStep] = ')
			step.writeJavaDef(sw)
			sw.write(';\n')

		if not isSimpleStep
			sw.write('int [javaDir] = [javaStep] < 0 ? -1 : +1;\n')

		sw.write('for(')
		if trackLocals, sw.write('Cobra.Lang.CobraImp.SetLocal("[.var.name]", [javaVar] = [javaStart])')
		else, sw.write('[javaVar] = [javaStart]')		
		if isSimpleStep, sw.write('; [javaVar] < [javaStop] ; ')
		else, sw.write('; ([javaDir]==1) ? [javaVar] < [javaStop] : [javaVar] > [javaStop]; ')
		if trackLocals, sw.write('Cobra.Lang.CobraImp.SetLocal("[.var.name]", [javaVar] += [javaStep])')
		else, sw.write('[javaVar] += [javaStep]')		
		sw.write(') ')

		_block.writeJavaDef(sw, false)

		sw.dedent
		sw.write('}\n')
		sw.write('} // for [.var.name]\n')


class ForEnumerableStmt is partial

	def writeJavaDef(sw as CurlyWriter)
		base.writeJavaDef(sw)
		# in a C# foreach, (1) you must declare a new variable, (2) you cannot reassign it and (3) you cannot access it after the loop
		# these constraints don't exist in Cobra
		helperName = '_lh_for_[_var.name]_[_varNumber]'
		sw.write('foreach ([_var.type.javaRef] [helperName] in ')

		# TODO: the javaRef of a type is not qualified and there is no using System.Collections;
		# _what.writeJavaDefInContext(sw, false)
		if _what.type.isDynamic
			sw.write('Cobra.Lang.CobraImp.GetEnumerable(')
			_what.writeJavaDef(sw, false)
			sw.write(')')
		else
			_what.writeJavaDef(sw, false)

		sw.write(')')
		stmt = '[.var.javaName] = [helperName]'
		if .compiler.willTrackLocals
			stmt = 'Cobra.Lang.CobraImp.SetLocal("[.var.name]", [stmt])'
		stmt += ';\n'
		_block.writeJavaDef(sw, stmt)


class IfStmt is partial

	def writeJavaDef(sw as CurlyWriter)
		# if you're looking for if-inherits related code gen, see BlockStmt
		base.writeJavaDef(sw)
		sw.write('if (')
		_cond.writeJavaDef(sw, false)
		sw.write(')')
		_trueStmts.writeJavaDef(sw, false)
		sw.dedent
		if _falseStmts
			sw.write('} else')
			_falseStmts.writeJavaDef(sw, false)
			sw.dedent
		sw.write('}\n')


class ListenOrIgnoreStmt is partial

	def writeJavaDef(sw as CurlyWriter)
		base.writeJavaDef(sw)
		_event.writeJavaDef(sw, false)
		sw.write(' [.javaOperator] ')
		_target.writeJavaDef(sw, false)
		sw.writeLine(';')

	get javaOperator as String is abstract


class ListenStmt is partial

	get javaOperator as String is override
		return '+='


class IgnoreStmt is partial

	get javaOperator as String is override
		return '-='


class PassStmt is partial

	pass


class PrintStmt is partial

	def writeJavaDef(sw as CurlyWriter)
		base.writeJavaDef(sw)
		if _destination
			_destination.writeJavaDef(sw, true)
			methodName = if(_stop, 'Write', 'WriteLine')
			sw.write('.[methodName](')
		else
			methodName = if(_stop, 'PrintStop', 'PrintLine')
			sw.write('Cobra.Lang.CobraImp.[methodName](')
		sep = ''
		for arg in _args
			sw.write('[sep]Cobra.Lang.CobraImp._printStringMaker.MakeString(')
			arg.writeJavaDef(sw)
			sw.write(')')
			sep = '+" "+'
		sw.writeLine(');')


class PrintRedirectStmt is partial

	def writeJavaDef(sw as CurlyWriter)
		base.writeJavaDef(sw)
		sw.write('Cobra.Lang.CobraImp.PushPrintTo(')
		_destination.writeJavaDef(sw, false)
		sw.write(');\n')
		sw.write('try')
		_block.writeJavaDef(sw)
		sw.write('finally {\n')
		sw.indent
		sw.write('Cobra.Lang.CobraImp.PopPrintTo();\n')
		sw.dedent
		sw.write('}\n')


class RaiseStmt is partial

	def writeJavaDef(sw as CurlyWriter)
		base.writeJavaDef(sw)
		name = .name.capitalized
		localName = '_lh_event_[.serialNum]'
		sw.writeLine('// raise [.name] ...')
		sw.write('{ [_eventType.javaRef] [localName] = this.[name]; if ([localName]!=null) [localName](')
		sep = ''
		for expr in _args
			sw.write(sep)
			expr.writeJavaDef(sw, false)
			sep = ', '
		sw.write('); }\n')


class ReturnStmt is partial

	def writeJavaDef(sw as CurlyWriter)
		base.writeJavaDef(sw)
		ensurePart = .compiler.curCodeMember.ensurePart
		willEnsure = ensurePart and ensurePart.willGenerateCode
		if willEnsure
			sw.write('_lh_canEnsure = true;\n')
		if _expr
			if willEnsure and _backEndResultVarName and _backEndResultVarName.length
				sw.write('return [_backEndResultVarName]=')
				_expr.writeJavaDefInContext(sw)
				sw.write(';\n')
			else
				sw.write('return ')
				_expr.writeJavaDefInContext(sw, false)
				sw.write(';\n')
		else
			sw.write('return;\n')


##
## Expressions
##

# uu

class Expr is partial

/#
	TODO axe or be content with SharpGenerator version.
	def needsContextCast as bool
		"""
		Returns true if this expression needs to be cast within its context.
		One example, is that a dynamically typed expression requires such casting.
		"""
		type = .type
		if type.isDynamic, return true
		if type inherits IntType
			if type.size < 32, return true
		return false
#/

	def writeJavaDefInContext(sw as CurlyWriter)
		.writeJavaDefInContext(sw, true)

	def writeJavaDefInContext(sw as CurlyWriter, parens as bool)
		"""
		When an expression is used where a particular type is expected, such as:
			# assignment
			x = y
			# argument passing
			obj.foo(x, y)
			obj[x, y]
		it may need C# typecasting--particularly if it is dynamic typed expression.
		This method relies on having had its .contextType set beforehand.
		This method should be invoked instead of `writeJavaDef` in any situation where .contextType was set.
		"""
		cast = _contextType and .needsContextCast
		if cast
			if parens, sw.write('(')
			sw.write('([_contextType.javaRef])(')
		.writeJavaDef(sw)
		if cast
			sw.write(')')
			if parens, sw.write(')')

	def writeJavaDef(sw as CurlyWriter) is override
		base.writeJavaDef(sw)
		branch .direction
			on Direction.In,    pass
			on Direction.Out,   sw.write('out ')  # TODO
			on Direction.InOut, sw.write('ref ')  # TODO
		.writeJavaDef(sw, true)

	def writeJavaDef(sw as CurlyWriter, parens as bool)
		pass

	def writeJavaStmt(sw as CurlyWriter) is override
		assert .didBindImp
		sw.node(this)
		.writeJavaSetLine(sw)
		.writeJavaDef(sw, false)
		sw.write(';\n')

	def writeJavaBreakdown(sw as CurlyWriter)
		sw.write(r'new object[] { 0')
		.writeJavaBreakdownItems(sw)
		sw.write('}, ')

	get willWriteJavaBreakdownItems as bool
		return _direction <> Direction.Out

	def writeJavaBreakdownItems(sw as CurlyWriter)
		if .willWriteJavaBreakdownItems
			src = Utils.javaStringLiteralFor(.toCobraSource)
			sw.write(', [src], ')
			.writeJavaDefForBreakdown(sw)

	def writeJavaDefForBreakdown(sw as CurlyWriter)
		.writeJavaDef(sw)


class NameExpr is partial

	get asJava as String
		return _definition.javaName


class AsExpr is partial

	def writeJavaStmt(sw as CurlyWriter) is override
		# this happens for declarations like "i as int"
		sw.write('// [_name] as [_type.name]\n')

	def writeJavaDef(sw as CurlyWriter, parens as bool) is override
		sw.write(.asJava)


class AnonymousMethodExpr is partial

	# TODO
	pass


class LambdaExpr is partial

	# TODO	
	pass


class CallExpr is partial

	def writeJavaDef(sw as CurlyWriter, parens as bool) is override
		assert .superNode inherits DotExpr
		name = .name
		if _definition inherits BoxMember and (_definition to BoxMember).binaryName
			name = (_definition to BoxMember).binaryName to !
		else
			name = name.capitalized
		sw.write('[name]')
		if _genericArgTypes and _genericArgTypes.count
			sw.write('<')
			sep = ''
			for genericArgType in _genericArgTypes
				sw.write(sep + genericArgType.javaRef)
				sep = ', '
			sw.write('>')
		sw.write('(')
		sep = ''
		for arg in _args
			sw.write(sep)
			arg.writeJavaDefInContext(sw)
			sep = ', '
		sw.write(')')

	def writeJavaBreakdownItems(sw as CurlyWriter) is override
		# leaving out the base call is intentional:
		# base.writeJavaBreakdownItems(sw)
		sw.write(', +1')
		for expr in _args
			expr.writeJavaBreakdownItems(sw)
		sw.write(', -1')


class EnumCallExpr is partial

	def writeJavaDef(sw as CurlyWriter, parens as bool) is override
		if parens, sw.write('(')
		if _args.count == 0
			sw.write('default([_definition.javaRef])')
		else
			sep = ''
			for member in _members
				sw.write(sep)
				sw.write(member.javaRef)
				sep = '|'
		if parens, sw.write(')')

	def writeJavaBreakdownItems(sw as CurlyWriter)
		base.writeJavaBreakdownItems(sw)
		sw.write(', +1')
		for member in _members
			sw.write(', ')
			sw.write(member.javaRef)
		sw.write(', -1')


class ForExpr is partial

	# TODO
	pass


class IdentifierExpr is partial

	def writeJavaDef(sw as CurlyWriter, parens as bool) is override
		# recall that this cannot be the right side of "foo.bar" since that is a MemberExpr
		java = .javaQualification + .javaName
		if _requiresGetClass, java = java + '.getClass()'
		sw.write(java)

	get javaQualification as String
		qual = ''
		if .definition inherits IVar
			# the only definition that has no parentNameSpace in practice is IVar
			pass
		else
			pn = .definition.parentNameSpace
			if pn, qual = pn.javaQualifier
		return qual
		
	get javaName as String
		assert .didBindImp
		assert .namedDefinition
		assert not .type inherits UnspecifiedType
		if .superNode inherits DotExpr
			assert this is not (.superNode to DotExpr).right  # should be a CallExpr or MemberExpr instead
		defi = .namedDefinition
		return defi.javaName

	def _requiresGetClass as bool
		# C# often requires typeof(Foo) instead of just plain Foo
		if not .isTypeReference, return false
		superNode = .superNode
		if superNode inherits DotExpr, return false
		if superNode inherits InheritsExpr, return false
		if superNode inherits PostCallExpr
			if superNode.expr is this
				return false
		return true

	def writeJavaStmt(sw as CurlyWriter) is override
		assert .isCalling
		sw.write('[_name]();')

	get javaAssignmentNames as List<of String>?
		require
			.didBindImp
			.namedDefinition
		body
			if _definition inherits IVar
				return _definition.javaAssignmentNames
			else
				return nil

	def writeJavaDefForBreakdown(sw as CurlyWriter) is override
		name = .javaQualification + .javaName
		# _requiresGetClass may return false, but in the java def breakdown, .getClass is always required
		if .isTypeReference, name = name + '.getClass()'
		sw.write(name)


class IfExpr is partial

	def writeJavaDef(sw as CurlyWriter, parens as bool) is override
		cond, tpart, fpart = .cond, .tpart, .fpart
		cast = tpart.type <> fpart.type
		# TODO: is this true?: Java doesn't do the "greatest common denominator" thing like Cobra does, so some casting is in order
		sw.write('(')
		cond.writeJavaDef(sw)
		sw.write('?')
		if cast, sw.write('([.type.javaRef])(')
		tpart.writeJavaDef(sw)
		if cast, sw.write(')')
		sw.write(':')
		if cast, sw.write('([.type.javaRef])(')
		fpart.writeJavaDef(sw)
		if cast, sw.write(')')
		sw.write(')')

	def writeJavaBreakdownItems(sw as CurlyWriter)
		base.writeJavaBreakdownItems(sw)

		sw.write(', +1') # indent

		cond, tpart, fpart = .cond, .tpart, .fpart
		cond.writeJavaBreakdownItems(sw)
		# only one of the target expressions is actually evaluated

		# tpart:
		src = Utils.javaStringLiteralFor(tpart.toCobraSource)
		sw.write(', [src], new Cobra.Lang.CobraDirectString(')
		cond.writeJavaDefForBreakdown(sw)
		sw.write(' ? Cobra.Lang.CobraCore.ToTechString(')
		tpart.writeJavaDefForBreakdown(sw)
		sw.write(') : "(not-evaluated)")')

		# fpart:
		src = Utils.javaStringLiteralFor(fpart.toCobraSource)
		sw.write(', [src], new Cobra.Lang.CobraDirectString(')
		cond.writeJavaDefForBreakdown(sw)
		sw.write(' ? "(not-evaluated)" : Cobra.Lang.CobraCore.ToTechString(')
		fpart.writeJavaDefForBreakdown(sw)
		sw.write('))')

		sw.write(', -1') # dedent


class IndexExpr is partial

	def writeJavaDef(sw as CurlyWriter, parens as bool) is override
		if _target.type.isDynamic
			sw.write('Cobra.Lang.CobraImp.GetIndexerValue(')
			_target.writeJavaDef(sw, false)
			for expr in _args
				sw.write(', ')
				expr.writeJavaDef(sw, false)
			sw.write(')')
			return
		if parens, sw.write('(')
		if _target inherits IdentifierExpr
			if _target.isKindOf(.compiler.typeType)
				# here we're favoring "Foo[]" being an array type rather than a shared indexer
				sw.write(_target.name)
				handled = true
		if not handled
			_target.writeJavaDef(sw)
		sw.write(r'[')
		sep = ''
		for expr in _args
			sw.write(sep)
			expr.writeJavaDefInContext(sw)
			sep = ', '
		sw.write(']')
		if parens, sw.write(')')

	def writeJavaBreakdownItems(sw as CurlyWriter)
		base.writeJavaBreakdownItems(sw)
		sw.write(', +1')
		_target.writeJavaBreakdownItems(sw)
		for expr in _args
			expr.writeJavaBreakdownItems(sw)
		sw.write(', -1')


class IsNilExpr is partial

	def writeJavaDef(sw as CurlyWriter, parens as bool) is override
		if parens, sw.write('(')
		sw.write('(')
		_expr.writeJavaDef(sw)
		sw.write(')')
		sw.write('==null')
		if parens, sw.write(')')

	def writeJavaBreakdownItems(sw as CurlyWriter)
		base.writeJavaBreakdownItems(sw)
		_expr.writeJavaBreakdownItems(sw)


class IsNotNilExpr is partial

	def writeJavaDef(sw as CurlyWriter, parens as bool) is override
		if parens, sw.write('(')
		sw.write('(')
		_expr.writeJavaDef(sw)
		sw.write(')')
		sw.write('!=null')
		if parens, sw.write(')')

	def writeJavaBreakdownItems(sw as CurlyWriter)
		base.writeJavaBreakdownItems(sw)
		_expr.writeJavaBreakdownItems(sw)


##
## Temporary
##

# uu

class AssemblyDecl is partial

	def writeJavaTestInvocation(sw as CurlyWriter)
		pass

class IntegerLit is partial

	def asJava as String
		return 'TODO'

class EnumMember is partial

	def writeJavaTestInvocation(sw as CurlyWriter)
		pass

class Extension is partial

	get javaKeyWord as String is override
		return ''
	
	get javaInvariantVisibility as String is override
		return ''

class OldExpr is partial

	def writeJavaAssignment(args as vari dynamic)
		pass

	get javaVarName as String
		return ''
		
class Utils is partial

	shared

		def javaStringLiteralFor(args as vari dynamic) as String
			# TODO:
			for arg in args, return arg
			return ''

class ThisOrBaseLit is partial

	def asJava as String
		return 'this'

class ContractPart is partial

	def writeJavaMethod(args as vari dynamic)
		pass
