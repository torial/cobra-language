"""
The code in this file should not .throwError, record warnings, etc.
All of that happens during .bindFoo phases.
"""


##
## Compiler
##

class Compiler is partial

	def writeJava
		Node.setCompiler(this)
		try
			pass
			_moduleFileName_to_curlyToCobraLineNum = Dictionary<of String, Dictionary<of int, int>>()
			for _curModule in _modules
				if not _curModule.fileName.endsWith('SystemInterfaces.cobra')
					javaToCobraLineNum = _curModule.writeJavaDef
					_moduleFileName_to_curlyToCobraLineNum[_curModule.fileName] = javaToCobraLineNum
					_moduleFileName_to_curlyToCobraLineNum[Path.getFullPath(_curModule.fileName)] = javaToCobraLineNum
		finally
			Node.setCompiler(nil)

	def writeJavaTestInvocation
		pass

	def compileJava
		.compileJava('')

	def compileJava(extraJavacOptions as String)
		require
			.modules.count
		body
			print 'Not compiling Java yet...'


##
## Node
##

class Node is partial

	def writeJavaDef(sw as CurlyWriter)
		require .didBindInt or .didBindImp
		pass


class SyntaxNode is partial

	def writeJavaDef(sw as CurlyWriter)
		base.writeJavaDef(sw)
		sw.node(this)


interface INamedNode is partial

	get javaName as String
		"""
		Return the name that should be used in Java source code.
		"""


class NamedNode is partial

	get javaName as String
		return _name

	get javaRef as String
		return .javaName


##
## Module
##

class Module is partial

	var _javaFileName = ''

	get javaFileName from var

	get javaSource as String
		if _javaFileName.length
			return File.readAllText(_javaFileName)
		else
			throw FallThroughException('csFileName is blank')

	def writeJavaDef as Dictionary<of int, int>? is abstract

	def writeJavaTestInvocation(sw as CurlyWriter)
		pass


class SharpModule is partial  # Sharp Module

	def writeJavaDef as Dictionary<of int, int>? is override
		assert false
		return nil


class JavaModule inherits NativeModule is partial
	"""
	The purpose of a Java module is to allow the programmer to include .java source for Cobra to
	incorporate in the final compilation.
	"""

	cue init(fileName as String, verbosity as int)
		base.init(fileName, verbosity, '')
		_javaFileName = fileName

	def writeJavaDef as Dictionary<of int, int>? is override
		if false
			# kind of silly, but it works:
			d = Dictionary<of int, int>()
			for i in 1 : Utils.countChars(File.readAllText(_javaFileName), c'\n')+1
				d[i] = i
			return d	
		return nil


class AssemblyModule is partial

	get javaSource as String is override
		return '(no Java source for [this])'

	def writeJavaDef as Dictionary<of int, int>? is override
		return nil


class CobraModule is partial

	get javaFileName as String is override
		if _javaFileName == '' and not _fileName.endsWith('SystemInterfaces.cobra')
			_javaFileName = _fileName + '.java'
		return _javaFileName

	def writeJavaDef as Dictionary<of int, int>? is override
		file = File.createText(.javaFileName)
		using sw = CurlyWriter(file, CurlyLineNumberTreatment.PoundLine)
			.compiler.addIntermediateFile(_javaFileName)
			sw.start(.fileName)
			sw.write('// [_javaFileName]\n')
			sw.write('// Generated by Cobra\n')  # TODO: put version number here
			sw.write('// on [DateTime.now]\n')
			# TODO: list op sys
			sw.write('\n')

			# TODO DELME sw.write('using Cobra.Lang = Cobra.Lang[.compiler.embedRunTimeSuffix];\n')
			
			.topNameSpace.writeJavaDef(sw)
			d = sw.curlyToCobraLineNum
		return d

	def writeJavaTestInvocation(sw as CurlyWriter) is override
		# TODO: .topNameSpace.writeJavaTestInvocation(sw)
		pass


##
## Container and friends
##

interface IParentSpace is partial
	
	get javaRef as String


class Container<of TMember> is partial

	get javaInit as String  # TODO: is abstract
		return ''
		
	get javaNameComponent as String
		"""
		Returns a string that can be used in a Java identifier. That means it cannot have special symbols such as period or left bracket.
		"""
		ensure result.length > 0  # TODO? Move to interface
		return .javaRef

	var _javaRef as String?

	get javaRef as String is override
		if _javaRef is nil and .didBindImp
			_javaRef = _computeJavaRef
			return _javaRef to !
		else
			return _computeJavaRef

	get javaParamRef as String
		return .javaRef

	get _computeJavaRef as String
		if .parent
			s = .parent.javaRef
			# TODO: delme
			#if s.length and not s.endsWith('::')  # C# has weird "global::" name
			#	s += '.'
			s += .javaName
		else
			s = .javaName
		return s

	def writeJavaIsNames(sw as CurlyWriter)
		# TODO: look up Java access levels
		
		# TODO: cache this somewhere
		accessLevels = ['public', 'protected', 'internal', 'protected internal', 'private']
		# CC: accessLevels = 'public,protected,internal,protected internal,private'.split(c',')
			# same names in both Cobra and C#

		# TODO:
		# if isNames is nil
		#	isNames = _isNames
		isNames = List<of String>()
		isNames.addRange(_isNames)
		if .defaultAccessLevel.length
			found = false
			for level as String in accessLevels  # CC: axe as
				if level in isNames
					found = true
			if not found
				isNames.insert(0, .defaultAccessLevel)
		isNameJava = {
			# only have to specify the ones that are different
			'shared': 'static',
			'nonvirtual': '',
		}
		sep = ''
		for name in isNames
			name = Utils.getSS(isNameJava to passthrough, name, name) to !
			sw.write(sep)
			sw.write(name)
			sep = ' '
		if sep.length, sw.write(' ')

	def writeJavaTestInvocation(sw as CurlyWriter)
		pass


interface IMember is partial

	def writeJavaDef(sw as CurlyWriter)
		"""
		Write the Java code for this member declaration to the given CurlyWriter.
		"""

	def writeJavaTestInvocation(sw as CurlyWriter)
		"""
		Write the Java call to the test method for this member.
		"""


##
## Namespace
##

class NameSpace is partial

	get javaSuffix as String
		# TODO: not sure how -embed-run-time is going to work on JVM or if it's even needed
		value as Object?
		if not .addOnValues.tryGetValue('JavaSuffix', out value)
			suffix = if(.fullName == 'Cobra.Lang', .compiler.embedRunTimeSuffix, '')
			.addOnValues['javaSuffix'] = suffix
			return suffix
		else
			return value to String

	get javaInit as String is override  # TODO: remove when not a type
		assert false
		return ''

	get javaRef as String is override
		return .fullName + .javaSuffix

	get javaQualifier as String
		ensure result.endsWith('.')
		return .fullName + .javaSuffix + '.'
	
	def writeJavaDef(sw as CurlyWriter) is override
		assert not .isUnified
		base.writeJavaDef(sw)
		# TODO: how to handle namespaces in Cobra
		#if not .isRoot
		#	sw.writeAndIndent('namespace [.name][.javaSuffix] {\n\n')
		for ud in _useDirectives
			ud.writeJavaDef(sw)
		for decl in _declsInOrder
			if decl inherits Box
				.compiler.boxStack.push(decl)
			decl.writeJavaDef(sw)
			if decl inherits Box
				.compiler.boxStack.pop
		# TODO
		#if not .isRoot
		#	sw.dedentAndWrite('} // namespace [.name]\n')

	def writeJavaTestInvocation(sw as CurlyWriter) is override
		for decl in _declsInOrder
			decl.writeJavaTestInvocation(sw)
	

class UseDirective is partial

	pass


##
## Types
##

class BasicLibraryType is partial

	get javaInit as String
		throw NoSourceGenerationException(this)

	get javaName as String
		throw NoSourceGenerationException(this)

	get javaNameComponent as String
		throw NoSourceGenerationException(this)

	get javaParamRef as String
		throw NoSourceGenerationException(this)

	get javaRef as String
		throw NoSourceGenerationException(this)

	def writeJavaDef(sw as CurlyWriter)
		throw NoSourceGenerationException(this)

	def writeJavaTestInvocation(sw as CurlyWriter)
		throw NoSourceGenerationException(this)


interface IType is partial

	get javaInit as String

	get javaNameComponent as String
		"""
		Returns a string that refers to this type and is suitable for embedding in a larger
		identifier (meaning there will be no punction, spaces or Java comments).
		"""

	get javaRef as String
		"""
		Returns a string that refers to this type.
		Examples: 'int'  'List<String>'  'object'
		"""

	get javaParamRef as String
		"""
		# TODO: update doc string to reflect Java accurately
		Returns a string that refers to this type including any necessary parameter declaration
		specification such as Java 'params' or 'out'. Invoked by Param.writeSharpDef.
		"""


class CobraType is partial

	get javaInit as String is abstract

	get javaName as String
		return .name

	get javaNameComponent as String
		name = .name
		i = name.indexOf('/*')  # example: /*dynamic*/object
		if i <> -1
			j = name.indexOf('*/', i)
			name = name[:i] + name[j+2:]
		name = name.replace('.', '_').replace('<', '_').replace('>', '_').replace(', ', '_')
		return name

	get javaRef as String
		return .javaName

	get javaParamRef as String
		return .javaRef

	def writeJavaTestInvocation(sw as CurlyWriter)
		pass


class BoolType is partial

	get javaInit as String is override
		return 'false'


class CharType is partial

	get javaInit as String is override
		return '(char)0'


class DynamicType is partial

	get javaInit as String is override
		return 'null'

	get javaName as String is override
		return '/*dynamic*/java.lang.Object'


class FloatType is partial

	get javaName as String is override
		return _nativeType.fullName


class IntType is partial

	get javaName as String is override
		return _nativeType.fullName


class NilableType is partial

	get javaInit as String is override
		return 'null'

	get javaRef as String is override
		return _wrappedType.javaRef + if(not _wrappedType.isReference, '?', '')


class NilType is partial

	get javaInit as String is override
		return 'null'

	get javaRef as String is override
		return '/*nil*/java.lang.Object'


class AbstractNumberType is partial

	get javaInit as String is override
		return '0'


class PassThroughType is partial

	get javaInit as String is override
		return 'null'

	get javaRef as String is override
		return '/*passthrough*/java.lang.Object'


class StreamType is partial

	get javaInit as String is override
		return 'new Cobra.Lang.EmptyStream<[.theWrappedType.javaRef]>()'

	get javaRef as String is override
		assert .didBindInh and .didBindInt
		return '/*[.name]*/[.box.javaRef]'


class VoidType is partial

	get javaInit as String is override
		throw Exception('Cannot init a void type.')


class WrappedType is partial

	get javaInit as String is override
		return _wrappedType.javaInit


class ArrayType is partial

	get javaRef as String is override
		return '[_wrappedType.javaRef]' + r'[]'

	get javaInit as String is override
		return 'null'


class VariType is partial

	get javaRef as String is override
		return '[_wrappedType.javaRef]' + r'[]'

	get javaParamRef as String is override
		return 'params ' + .javaRef


class UnspecifiedType is partial
	
	get javaInit as String is override
		# TODO: throw Exception('Not expecting code gen for unspecified types.')
		return '!UnspecifiedType!'


##
## Enums
##

# TODO


##
## Boxes
##



class Box is partial

	get javaNameComponent as String is override
		name = .javaName
		i = name.indexOf('/*')  # example: /*dynamic*/object
		if i <> -1
			j = name.indexOf('*/', i)
			name = name[:i] + name[j+2:]
		# qualified types and generics need cleanup
		for ch in '.<>, '
			name = name.replace(ch, c'_')
		return name

	get javaThis as String
		"""
		Returns 'this' as you would expect.
		Overridden by Extension.
		"""
		return 'this'

	get javaKeyWord as String is abstract

	get javaName as String is override
		return _name.replace('<of', '<')

	get _computeJavaRef as String is override
		if _genericParams.count
			sb = StringBuilder()
			# generic
			name = .rootName
			sb.append(name)
			sb.append('<')
			sep = ''
			for param in _genericParams
				sb.append(sep)
				sb.append(param.javaRef)
				sep = ', '
			sb.append('>')
			java = sb.toString
		else
			java = .javaName
		if .parentNameSpace and not .parentNameSpace.isRoot
			java = .parentNameSpace.javaQualifier + java
		else if .parentBox
			java = .parentBox.javaRef + '.' + java
		return java

	def writeJavaDef(sw as CurlyWriter)
		base.writeJavaDef(sw)
		if .isExtern, return
		.compiler.boxStack.push(this)
		try
			assert not .isConstructed
			.writeJavaAttribs(sw)
			.writeJavaIsNames(sw)
			sw.write('[.javaKeyWord] ')
			.writeJavaDefName(sw)
			.writeJavaInheritance(sw)
	
			sep = ''
			for inter in _baseInterfaces
				sw.write(sep)
				sw.write(inter.javaRef)
				sep = ', '
	
			if _genericParams.count
				sw.indent
				for param in _genericParams
					if param inherits GenericParam
						param.writeJavaConstraint(sw)
				sw.dedent
	
			sw.writeAndIndent('{\n')
			.writeJavaInvariantMethod(sw)
			if _testMethod
				_testMethod.writeJavaDef(sw)
			for decl in _declsInOrder
				if not .willWriteDeclJavaDef(decl), continue
				.compiler.boxMemberStack.push(decl)
				try
					decl.writeJavaDef(sw)
				finally
					.compiler.boxMemberStack.pop
			if .compiler.includeTests
				.writeJavaTest(sw)
			sw.dedentAndWrite('} // [.javaKeyWord] [.name]\n')
			sw.write('\n')
		finally
			.compiler.boxStack.pop

	def willWriteDeclJavaDef(decl) as bool
		return true

	def writeJavaAttribs(sw as CurlyWriter)
		for attrib in _attribs
			attrib.writeJavaDef(sw)

	def writeJavaDefName(sw as CurlyWriter)
		sw.write('[.rootName]')
		if _genericParams.count
			sw.write('<')
			sep = ''
			for param in _genericParams
				sw.write(sep)
				param.writeJavaDef(sw)
				sep = ', '
			sw.write('>')

	def writeJavaInheritance(sw as CurlyWriter)
		"""
		Class uses this to write its base class declaration.
		No box uses this to write interface implementation--that's handled in the Box class.
		"""
		pass

	get javaInvariantVisibility as String is abstract

	def writeJavaInvariantMethod(sw as CurlyWriter)
		if .compiler.options['contracts'] <> 'none'
			sw.write('\nint _ih_invariantGuard;\n\n')
		if .compiler.options['contracts'] <> 'methods'
			return
		sw.write('\n[.javaInvariantVisibility] void invariant_[.rootName]() {\n')
		sw.indent
		if _baseClass and (not _baseClass.isFromBinaryLibrary or _baseClass.declForName('invariant_[_baseClass.rootName]'))
			sw.write('invariant_[_baseClass.rootName]();\n')
		.writeJavaInvariantChecks(sw)
		sw.dedent
		sw.write('}\n\n')

	def writeAllJavaInvariantChecks(sw as CurlyWriter)
		"""
		Writes all Java invariant checks including inherited. In support of -contracts:inline
		"""
		_writeAllJavaInvariantChecks(sw, this)

	def _writeAllJavaInvariantChecks(sw as CurlyWriter, box as Box)
		if box.baseClass and not box.baseClass.isFromBinaryLibrary
			_writeAllJavaInvariantChecks(sw, box.baseClass to !)
		box.writeJavaInvariantChecks(sw)
		
	def writeJavaInvariantChecks(sw as CurlyWriter)
		"""
		Writes the Java invariant checks just for this class.
		"""
		for expr in _invariants
			javaThis = '[.javaName].class'
			sw.write('if (!')
			expr.writeJavaDef(sw)
			sw.write(')\n')
			sw.indent
			sw.write('throw new Cobra.Lang.InvariantException([expr.javaSourceSite(.name, "invariant", javaThis)], ')
			expr.writeJavaBreakdown(sw)
			sw.write('[javaThis], null);\n')
			sw.dedent

	def writeJavaTest(sw as CurlyWriter)
		# Running tests from the static initializer seems like a good idea, but has been problematic at various times on both .NET and Mono, so no more:
		# sw.write('\nstatic [.rootName]() { RunTestsIfNeeded(); }\n')
		# -- er, it turned out that the problem was likely -dst on SourceSite. Consequently we could try returning to static initializers to trigger tests.
		sw.write('\nprivate static bool __didStartTests = false;\n')
		newWord = .newForJavaTest
		sw.write('\npublic static[newWord] void RunTestsIfNeeded() { if (!__didStartTests) RunTests(); }\n')
		sw.write('\npublic static[newWord] void RunTests()')
		sw.writeAndIndent(' {\n')
		sw.write('__didStartTests = true;\n')
		sw.write('Cobra.Lang.CobraImp.TestBegan("[.name]");\n')
		if _testMethod
			sw.write('[_testMethod.javaName]();\n')
		for decl in _declsInOrder
			decl.writeJavaTestInvocation(sw)
		sw.write('Cobra.Lang.CobraImp.TestEnded("[.name]");\n')
		sw.dedentAndWrite('}\n')

	var _didWriteJavaTestInvocation = false

	def writeJavaTestInvocation(sw as CurlyWriter) is override
		# used by the test option
		if _didWriteJavaTestInvocation
			return
		if .isExtern
			return
		if .isGenericDef  # sorry, but static methods always require a type arg even if you don't need it. workaround. make another class with a 'test' section that tests the generic class TODO: make Cobra do this, but then watch for use of the generic param!
			return
		assert .parentNameSpace
		sw.write('\t\t[.javaRef].RunTestsIfNeeded();\n')
		_didWriteJavaTestInvocation = true

	get newForJavaTest as String
		return ''


class Class is partial

	get javaInit as String is override
		return 'null'

	get javaInvariantVisibility as String is override
		return 'protected'

	get javaKeyWord as String is override
		return 'class'

	def writeJavaInheritance(sw as CurlyWriter) is override
		sw.write(' extends ')
		if _baseClass
			sw.write(_baseClass.sharpRef)
			didWrite = true
		if didWrite
			if _baseInterfaces.count
				sw.write(', ')
			else
				sw.write(' ')

	get newForJavaTest as String is override
		return if(not _baseClass.isExtern, ' new', '')


class Interface is partial

	get javaInit as String is override
		return 'null'

	get javaInvariantVisibility as String is override
		throw ShouldNotCallException(.getType)

	get javaKeyWord as String is override
		return 'interface'

	def writeJavaInheritance(sw as CurlyWriter) is override
		if _baseInterfaces.count
			sw.write(' extends ')

	def writeJavaInvariantMethod(sw as CurlyWriter) is override
		# Even when invariants are inherited by the classes and structs that implement them,
		# the code gen for the interface invariant does not go "here", inside the Java interface definition.
		pass

	def writeJavaTest(sw as CurlyWriter) is override
		# Static methods can't be put in interfaces. However, at some point Cobra should support
		# tests for interfaces which could then be run against the classes that implement them.
		# Just requires more code gen smarts.
		pass

	def writeJavaTestInvocation(sw as CurlyWriter) is override
		pass


class Mixin is partial

	get javaName as String
		name = base.javaName
		if .canHaveStatements
			name += 'Mixin'
		return name
		
	get javaKeyWord as String is override
		return if(.canHaveStatements, 'class', 'interface')

	def willWriteDeclJavaDef(decl) as bool is override
		return not decl inherits BoxVar

	def writeJavaDef(sw as CurlyWriter)
		# write the interface
		_canHaveStatements = false
		base.writeJavaDef(sw)


class Struct is partial

	get javaInit as String is override
		return ''  # blank to indicate there is no valid init

	get javaInvariantVisibility as String is override
		return 'private'

	get javaKeyWord as String is override
		return 'struct'

	def writeJavaInheritance(sw as CurlyWriter) is override
		if _baseInterfaces.count
			sw.write(' extends ')


##
## Temporary
##

class AssemblyDecl is partial

	def writeJavaTestInvocation(sw as CurlyWriter)
		pass

class BoxMember is partial

	def writeJavaTestInvocation(sw as CurlyWriter)
		pass

class EnumMember is partial

	def writeJavaTestInvocation(sw as CurlyWriter)
		pass

class GenericParam is partial

	get javaInit as String is override
		return ''

	def writeJavaConstraint(sw as CurlyWriter)
		pass

class Expr is partial

	def javaSourceSite(args as vari dynamic) as dynamic?
		return nil
	
	def writeJavaBreakdown(sw as CurlyWriter)
		pass

class Extension is partial

	get javaKeyWord as String is override
		return ''
	
	get javaInvariantVisibility as String is override
		return ''
