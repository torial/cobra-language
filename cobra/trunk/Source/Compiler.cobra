use System.Reflection


class StopCompilation
	inherits Exception
	"""
	Thrown by the compiler when it must stop compilation due to errors. This can happen at the end
	of the phases:
		* parsing
		* bind interface
		* bind implementation
		* code gen
	"""

	var _comp as Compiler

	def init(comp as Compiler)
		_comp = comp


class UnexpectedInvocationException
	inherits SystemException
	"""
	Throw this when a class is not expecting a particular method to be invoked at runtime
	(even though it inherits it or must implement it for an interface).
	"""

	def init(obj as Object)
		base.init('Not expecting invocation.')


enum PlatformEnum
	Microsoft
	Novell


class Compiler
	implements ITypeProvider, IWarningRecorder, IErrorRecorder
	"""
	General notes:

	To cope with nesting, the compiler keeps a stack of the three types of things that can be nested. Items are pushed and popped off these stacks during each of the "bind interface" and "bind implementation" phases. The three stacks are:
		* nameSpaceStack - namespaces
		* boxStack - boxes are classes, structs and interfaces
		* codeMemberStack - methods, properties and inits
	"""

	var _nextSerialNum as int is shared
	var _serialNum as int
	var _verbosity as int
	var _options as Options
	var _willPrintSuccessMsg = true
	var _htmlWriter as HtmlWriter?
	
	var _globalNS as NameSpace
	var _modules as List<of Module>
	var _firstFileName as String?

	var _curModule as Module?  # set during bindInt and bindImp
	var _nodeStack as Stack<of INode>
	var _nameSpaceStack as Stack<of NameSpace>
	var _boxStack as Stack<of Box>
	var _boxMemberStack as Stack<of IBoxMember>
	var _codeMemberStack as Stack<of AbstractMethod>

	# TODO: could collapse these down to IsBindingEnum: None, Use, Int, Inh. Or PhaseEnum: None, Parsing, BindingUse, DidBindUse, BindingInh, DidBindInh, BindingInt, DidBindInt, BindingImp, DidBindImp, Generating, DidGenerate
	var _isBindingUse as bool
	var _isBindingInh as bool
	var _isBindingInt as bool
	var _isBindingImp as bool

	var _errors as List<of SourceException>
	var _warnings as List<of SourceException>
	var _messages as List<of SourceException>  # all errors and warnings
	var _messagesPerSourceLine as IDictionary<of String, List<of SourceException>>  # key is 'filename:lineNum'
	
	var _intermediateFileNames as List<of String>
	var _baseExeFileName as String = ''
	var _fullExeFileName as String = ''

	# caches
	var _clrPrimitiveToITypeCache as IDictionary<of System.Type, IType>?


	def init(verbosity as int)
		.init(verbosity, nil)

	def init(verbosity as int, initialModules as IList<of Module>?)
		_nextSerialNum += 1
		_serialNum = _nextSerialNum
		_verbosity = verbosity
		_modules = List<of Module>()
		_options = Options()
		_globalNS = NameSpace(Token.empty, '(global)')
		_nodeStack = Stack<of INode>()
		_nameSpaceStack = Stack<of NameSpace>()
		_boxStack = Stack<of Box>()
		_boxMemberStack = Stack<of IBoxMember>()
		_codeMemberStack = Stack<of AbstractMethod>()
		_messages = List<of SourceException>()
		_messagesPerSourceLine = Dictionary<of String, List<of SourceException>>()
		_errors = List<of SourceException>()
		_warnings = List<of SourceException>()
		_intermediateFileNames = List<of String>()
		if initialModules
			if false # TODO: not working yet
				for mod in initialModules
					if mod inherits AssemblyModule
						ns = mod.topNameSpace
						assert not ns.superNameSpace
						ns.unifyInto(_globalNS)
					# TODO: handle CobraModule too
					_modules.add(mod)

	def toString as String is override
		return '[.getType.name]([_serialNum])'

	get verbosity from var

	get includeTests as bool
		return .options.boolValue('include-tests')

	get isBindingUse from var

	get isBindingInh from var

	get isBindingInt from var

	get isBindingImp from var

	get clrPrimitiveToITypeCache from var
		"""
		Returns a cache mapping CLR types to their corresponding ITypes.
		Populated and used by ClrTypeProxy.
		"""

	get globalNS from var

	get modules from var

	pro options from var

	pro willPrintSuccessMsg from var
	
	get nodeStack from var

	get nameSpaceStack from var

	get boxStack from var

	get curBox as Box
		require .boxStack.count
		return _boxStack.peek to !

	get curBoxMember as IBoxMember
		require .boxMemberStack.count
		return _boxMemberStack.peek to !

	get boxMemberStack from var

	get curCodeMember as AbstractMethod
		require .codeMemberStack.count
		return _codeMemberStack.peek to !

	get codeMemberStack from var

	get errors from var

	get warnings from var

	get messages from var

	pro htmlWriter from var
		"""
		Set this to support the output-html command line option.
		"""

	get hasDetailedStackTraceOption as bool
		return _options.boolValue('detailed-stack-trace')

	get willTrackLocals as bool
		# the box stack can be empty because of assembly; has SomeAttr
		if .boxStack.count
			# the code member stack can be empty due to class variables (ex: var _x = 1)
			return .hasDetailedStackTraceOption and (.codeMemberStack.count == 0 or .curCodeMember.box.canHaveDetailedStackTrace)
		else
			return false

	get hasExceptionReportOption as bool
		return .options.boolValue('exception-report')

	def recordError(error as SourceException)
		"""
		Node call this to record errors.
		"""
		if error inherits NodeMultiException
			for exc in error.exceptions
				_addMessage(exc)
		else
			_addMessage(error)

	def addIntermediateFile(path as String)
		_intermediateFileNames.add(path)
		
	get cobraExeDir as String
		"""
		Returns the directory where cobra.exe is residing.
		Related resources such as CobraLang.cs reside there.
		"""
		return Path.getDirectoryName(Assembly.getEntryAssembly.location) to !  # actually could be nil: if you stuck Cobra in the root dir, the .getDirectoryName docs say it will return nil

	def compileFilesNamed(paths as IList<of String>)
		.compileFilesNamed(paths)

	def compileFilesNamed(paths as IList<of String>, writeTestInvocation as bool)
		if .options.boolValue('reveal-internal-exceptions')
			_compileFilesNamed(paths, writeTestInvocation)
			.printMessages
			return
		else
			try
				_compileFilesNamed(paths, writeTestInvocation)
			catch StopCompilation
				throw
			catch exc as Exception
				# unexpected exception -- only StopCompilation should be thrown
				if exc inherits SourceException
					if exc.hasSourceSite
						.recordError(InternalError(exc.fileName, exc.lineNum, exc.message, exc))
					else
						.recordError(InternalError(exc.message, exc))
				else if exc inherits AssertException
					sn as SyntaxNode?
					if exc.this inherits SyntaxNode
						sn = exc.this to SyntaxNode
					else if exc.info inherits SyntaxNode
						sn = exc.info to SyntaxNode
					if sn
						.recordError(InternalError(sn.token.fileName, sn.token.lineNum, exc.message, exc))
					else
						.recordError(InternalError(exc.message, exc))
				else
					.recordError(InternalError(exc.message, exc))
				.printMessages
				throw StopCompilation(this)
			success
				.printMessages

	def _compileFilesNamed(paths as IList<of String>, writeTestInvocation as bool)
		.parseFilesNamed(paths)
		.bindUse
		.bindInh
		.bindInt
		.bindImp
		.writeSharp
		if writeTestInvocation
			.writeSharpTestInvocation
			.compileSharp('/main:RunTests')
		else
			.compileSharp			

	def testifyFilesNamed(fileNames as IList<of String>, options as Options, resultsWriter as IndentedWriter, verbose as bool)
		"""
		Compiles the given fileNames in support of "testify".
		Sets .options to the options arg.
		Will raise StopCompilation when an error occurs.
		"""
		.options = options
		bar = '----------------------------------------------------------------------------------------------------'
		.parseFilesNamed(fileNames)
		assert .modules.count
		if verbose
			.dumpModulesForTestify(resultsWriter, 'Modules after parsing')
			print bar

		if verbose
			print 'Bind use:'
		.bindUse
		if verbose
			print 'Bind inheritance:'
		.bindInh
		if verbose
			print 'Bind interface:'
		.bindInt
		if verbose
			.dumpModulesForTestify(resultsWriter, 'Modules after binding interface')
			print 'Bind implementation:'
		.bindImp
		if verbose
			.dumpModulesForTestify(resultsWriter, 'Modules after binding implementation')
			print bar
			print 'Generated C#:'
		.writeSharp
		if verbose
			for module in .modules
				if not module.isCobraLibrary
					Utils.printSource(module.sharpSource)
			print bar
			print 'Compile C#:'
		.compileSharp
		.printMessages
		print bar

	def parseFilesNamed(filenames as IList<of String>) as List<of Module>
		"""
		Returns the modules for the newly parsed files.
		Also, extends _modules with those modules.
		"""
		require
			filenames.count or .options.buildStandardLibrary
		ensure
			true
		body
			_firstFileName = if(.options.buildStandardLibrary, 'Cobra.Lang.dll', filenames[0])

			embedRunTime = .options.boolValue('embed-run-time')
			
			if not embedRunTime
				# then reference it
				if not .options.containsKey('reference')
					.options['reference'] = List<of String>()
				refs = .options['reference'] to List<of String>
				libName = 'Cobra.Lang.dll'
				if libName not in refs
					if .verbosity
						print 'Adding reference to [libName]'
					refs.add(libName)

			if _modules.count == 0  # attempt at caching modules during testify. incomplete.
				.writeSharpInfoClass
				.readSystemTypes
				.readAssemblyTypes

			if true # _modules.count == 0
				path = Path.combine(.cobraExeDir, 'CobraInfo.cs')
				assert File.exists(path)
				filenames.insert(0, path)

				if embedRunTime
					path = Path.combine(.cobraExeDir, 'SystemInterfaces.cobra')
					assert File.exists(path)
					filenames.insert(1, path)

					path = Path.combine(.cobraExeDir, 'CobraLang.cobra')
					assert File.exists(path)
					filenames.insert(2, path)

					path = Path.combine(.cobraExeDir, 'CobraLang.cs')
					assert File.exists(path)
					filenames.insert(3, path)

			modules = List<of Module>()
			Node.setCompiler(this)
			try
				for filename in filenames
					if filename.endsWith('.cs')
						if _verbosity
							print 'Noting  [filename]'  # extra space to line up with 'Parsing [filename]'
						modules.add(SharpModule(filename, _verbosity))
					else
						parser = Parser()
						parser.verbosity = _verbosity
						parser.typeProvider = this
						parser.warningRecorder = this
						parser.errorRecorder = this
						parser.globalNS = _globalNS
						# @@ TODO: assert _globalNS is parser.nameSpaceStack[0]
						try
							module = parser.parseFileNamed(filename)
						catch SourceException
							pass
						success
							# There could still be parse errors that were recorded, but not thrown.
							# But that's okay because _errors.count is checked further below.
							modules.add(module)
			finally
				Node.setCompiler(nil)
			if _errors.count
				_exitFromErrors
			else
				assert modules.count
				_modules.addRange(modules)
			return modules


	##
	## ITypeProvider
	##

	var _anyIntType as AnyIntType?
	var _boolType as BoolType?
	var _charType as CharType?
	var _decimalType as DecimalType?
	var _dynamicType as DynamicType?
	var _floatType as FloatType?
	var _intTypes			=  Dictionary<of int, IntType>()
	var _nilType as NilType?
	var _numberType as NumberType?
	var _passThroughType as PassThroughType?
	var _unspecifiedType as UnspecifiedType?
	var _voidType as VoidType?
	var _variTypes as Dictionary<of INode, VariType>?

	def typeForName(name as String) as IType
		assert false, 'TODO'
		return .intType

	def typeOrNilForName(name as String) as IType?
		assert false, 'TODO'
		return nil

	get anyIntType as AnyIntType
		if _anyIntType is nil
			_anyIntType = AnyIntType()
		return _anyIntType to !

	get boolType as BoolType
		if _boolType is nil
			_boolType = BoolType()
		return _boolType to !

	get charType as CharType
		if _charType is nil
			_charType = CharType()
		return _charType to !

	get decimalType as DecimalType
		if _decimalType is nil
			_decimalType = DecimalType()
		return _decimalType to !

	get dynamicType as DynamicType
		if _dynamicType is nil
			_dynamicType = DynamicType()
		return _dynamicType to !

	def intType as IntType
		return .intType(true, 32)

	def intType(signed as bool, size as int) as IntType
		require size in @[8, 16, 32, 64] # CC: inherit from interface
		key = if(signed, -1, +1) * size
		type as IntType?
		if _intTypes.tryGetValue(key, out type)
			return type to !
		else
			type = _intTypes[key] = IntType(signed, size, .anyIntType)
			return type to !
		
	get floatType as FloatType
		if _floatType is nil
			_floatType = FloatType()
		return _floatType to !

	get nilType as NilType
		if _nilType is nil
			_nilType = NilType()
		return _nilType to !

	get numberType as NumberType
		if _numberType is nil
			_numberType = NumberType()
		return _numberType to !

	get passThroughType as PassThroughType
		if _passThroughType is nil
			_passThroughType = PassThroughType()
		return _passThroughType to !

	get typeType as IType
		return .libraryClass('System.Type')

	get unspecifiedType as UnspecifiedType
		if _unspecifiedType is nil
			_unspecifiedType = UnspecifiedType()
		return _unspecifiedType to !

	get voidType as VoidType
		if _voidType is nil
			_voidType = VoidType()
		return _voidType to !

	def variType(type as IType) as VariType
		if _variTypes is nil
			_variTypes = Dictionary<of INode, VariType>()
		else if _variTypes.containsKey(type)
			return _variTypes[type]
		_variTypes[type] = vt = VariType(type)
		return vt


	## More type stuff

	def nilableType(t as IType) as NilableType
		"""
		Returns a NilableType wrapper for t, unless t is already a NilableType in which case
		it is returned directly.
		"""
		if t inherits NilableType
			return t
		else
			return NilableType(t).bindAll to NilableType  # CC: axe cast after "as this"

	def readSystemTypes
		# TODO: support targeting a specific CLR version, but not under 2.0
		.readAssembly(Assembly.load('mscorlib.dll') to !)
	
		# TODO: .readAssembly(Assembly.loadFrom('System.dll') to !)
		#       gives: Unhandled Exception: System.IO.FileNotFoundException: Could not load file or assembly 'System.dll' or one of its dependencies. The system cannot find the file specified.
	
		t = $sharp('typeof(System.Diagnostics.Process)') to System.Type
		.readAssembly(t.assembly) # System.dll

	def readAssemblyTypes
		if .options.containsKey('reference')
			# Here be "reflectionOnlyLoad" code... which does not work on Mono 1.2.4
			# The run-time error message says:
			#   ** (./cobra.exe:24284): WARNING **: Cannot resolve dependency to assembly 'System, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089' because it has not been preloaded. When using the ReflectionOnly APIs, dependent assemblies must be pre-loaded or loaded on demand through the ReflectionOnlyAssemblyResolve event.
			# But hooking ReflectionOnlyAssemblyResolve has no effect as it never gets called.
			# Looks like others are having problems too:
			#   http://csammisrun.net/shaim/viewtopic.php?t=29&sid=e46dc962b1e4d14a5210ae2852ac7d87
			# General references:
			# * "Reflection Only Assembly Loading" blog entry by Junfeng Zhang
			#   http://blogs.msdn.com/junfeng/archive/2004/08/24/219691.aspx
			# * http://forums.microsoft.com/MSDN/ShowPost.aspx?PostID=2485940&SiteID=1
			#   Justin Pinnix from MSFT says "Once our assembly resolver finds your DLL, it calls
			#   Assembly.LoadFrom().  So, even though your code calls Assembly.Load, we still
			#   call Assembly.LoadFrom"
			# TODO: try this out on MS .NET and if it works there, use it there
			# TODO: file a Mono bug report (or ping an existing one)
			# curDomain = AppDomain.currentDomain
			# $sharp('curDomain.ReflectionOnlyAssemblyResolve += _resolveEvent')
			
			i = 0
			references = .options['reference'] to List<of String>
			for reference in List<of String>(references)
				if .verbosity > 0
					print 'Loading reference:', reference
				if false
					# Does not work on Novell Mono. See notes above.
					referredAss = Assembly.reflectionOnlyLoadFrom(reference)
					# TODO: handle all the exceptions from Assembly.loadFrom
				else
					if not CobraCore.isRunningOnMono and not reference.endsWith('.dll') and not reference.endsWith('.exe')
						# On Microsoft .NET 2.0, excluding the extension is problematic
						reference += '.dll'
						references[i] = reference
					if File.exists(reference)
						# try current directory
						referredAss = Assembly.loadFrom(reference)
					else
						# TODO: the problem with -lib: in both Cobra and C# is that it has no effect on runtime,
						# you must still register the DLLs in the GAC or copy them into the same dir as the .exe
						# because the -lib: paths are not passed into executable.
						# So should Cobra copy the .dll's into the target directory (if their paths are not in MONO_PATH)?
						searchPaths = .options.getDefault('library-directory', List<of String>()) to List<of String>
						# TODO: ?: searchPaths.add(Path.getDirectoryName(Assembly.getExecutingAssembly.location))  # try Cobra's directory - also should be added to .options.'library-directory' not to a local var
						found = false
						for searchPath in searchPaths
							combinedPath = Path.combine(searchPath, reference)
							for ext in ['', '.dll', '.exe']
								path = combinedPath + ext
								if File.exists(path)
									referredAss = Assembly.loadFrom(path)
									found = true
									break
							if found
								break
						if not found
							# try system wide (GAC)
							if reference.endsWith('.dll')
								reference = reference[:-4]
							referredAss = Assembly.loadWithPartialName(reference)  # TODO: Holy crap! loadWithPartialName is marked obsolete, but I know of no other way to support a library reference like "compiler /r:System.Data.dll myprog.ext" as C#, Cobra, etc. do. If they remove this method, we're screwed!
					# TODO: handle all the exceptions from Assembly.loadFrom
				if referredAss
					.readAssembly(referredAss, reference <> 'Cobra.Lang.dll')
				else
					_addMessage(SourceException('Cannot locate assembly reference "[reference]".'))
				i += 1

	def _resolveEvent(sender as Object, args as ResolveEventArgs) as Assembly?
		return nil
		
	def readAssembly(ass as Assembly)
		.readAssembly(ass, false)

	def readAssembly(ass as Assembly, skipCobra as bool)
		"""
		Reads the contents of an assembly (.DLL) so that they are accessible to the program.
		In other words, this method reads libraries.
		"""
		verbosity = .verbosity
		if verbosity
			print 'Reading assembly:  [ass] at [ass.location]'  # extra space lines up with 'Loading reference:'
		namespaceQualNameToNameSpaceObject = Dictionary<of String, NameSpace>()
		module = AssemblyModule(ass, .globalNS)
		_modules.add(module)
		skipCobra = false
		for type in ass.getExportedTypes
			if skipCobra and type.namespace and (type.namespace == 'Cobra' or type.namespace.startsWith('Cobra.'))
				# this is a huge hack to get around the repetition of the Cobra run-time support which gets embedded in both programs and libraries
				# TODO: this should go away
				continue
			if type.namespace == 'System.Configuration'
				# TODO
				# having various problems with System.Configuration
				continue
			if type.baseType and 'System.Configuration.dll' in type.baseType.assembly.location
				# TODO
				# this class is in System.dll but its base class is not there nor in mscorlib
				# instead its in an optional DLL called System.Configuration.dll that you don't even have to reference/link to 
				# one example class that is like this is ApplicationSettingsGroup
				# how does that work???
				# maybe look at attributes. check for TypeForwardedToAttribute or something else
				continue
			if '__CompilerGenerated' in type.name  # TODO: does that work in .NET?
				continue
			if type.isNested or type.declaringType
				# these will be scanned by Box._scanNestedTypes
				# print '### skipping [type.name] in [type.namespace]. isNested=[type.isNested], declaringType=[type.declaringType]'
				continue
			if type.namespace is nil or type.namespace == ''
				# happens for classes etc. that are not declared in a namespace
				curNameSpace = module.topNameSpace
			else
				namespaceName = type.namespace to !
				if namespaceQualNameToNameSpaceObject.containsKey(namespaceName) 
					curNameSpace = namespaceQualNameToNameSpaceObject[namespaceName]
				else
					curNameSpace = module.topNameSpace
					for name in type.namespace.split(c'.')
						curNameSpace = curNameSpace.getOrMakeNameSpaceNamed(Token.empty, name)
						assert not curNameSpace.isUnified
					namespaceQualNameToNameSpaceObject[namespaceName] = curNameSpace
			if verbosity >= 3
				print '  Reading type [type.name] in namespace "[namespaceName]"'
			if type.isClass
				curNameSpace.addDecl(Class(type))
			else if type.isInterface
				curNameSpace.addDecl(Interface(type))
			else if type.isEnum
				curNameSpace.addDecl(EnumDecl(curNameSpace, type, List<of String>(), ''))  # TODO: isNames; docString?
			else if type.isValueType
				curNameSpace.addDecl(Struct(type))
			else if type.isAnsiClass
				# The Enum class is an example that returns false for .isClass but true for .isAnsiClass
				curNameSpace.addDecl(Class(type))
			else
				throw FallThroughException(type)

	def fixNilableMemberSigs
		# TODO: this really needs to go in a separate file that the compiler reads each time

		# TODO: look to see if what the Spec# team put together can be leveraged instead of recreating all this work!
		# fix up member sigs regarding nilable
		# hard coded below. TODO: read from a Cobra config file
		_fix('System.Object', 'toString getType memberwiseClone')
			# ^ regarding .toString, not technically true, but common enough and life is too painful when the return type is nilable
		_fix('System.Console', 'out')
		_fix('System.String', 'padLeft padRight replace substring toLower toUpper trim')
		_fix('System.Type', 'assembly name toString')
			# namespace can return nil if the Type is a generic parameter
		_fix('System.Environment', 'commandLine currentDirectory newLine version')
		_fix('System.Exception', 'message')
		_fix('System.Collections.Generic.IEnumerable<of>', r'getEnumerator')
		_fix('System.Collections.Generic.IList<of>', r'[] getRange')
		_fix('System.Collections.Generic.List<of>', r'[] getRange')
		_fix('System.Collections.Generic.IDictionary<of,>', r'[] keys values')
		_fix('System.Collections.Generic.Dictionary<of,>', r'[]')
		_fix('System.Collections.Generic.KeyValuePair<of,>', r'key value')
		_fix('System.IO.File', 'create createText open openRead openText openWrite readAllBytes readAllLines readAllText')
		_fix('System.IO.FileSystemInfo', 'name fullName')
		_fix('System.IO.TextWriter', 'newLine')
		_fix('System.IO.Path', 'combine getFullPath')
			# getDirectoryName does return String?
			# getFileName does return String?
			# TODO: Add something like CobraUtils.getDirectoryName and .getFileName that return String instead
		# args: System.IO.Path.combine(arg1 as String, arg2 as String) as String
		_fix('System.Text.StringBuilder', 'toString')
		_fix('System.Text.RegularExpressions.Regex', 'match replace')
		_fix('System.Diagnostics.Process', 'processName')
		_fix('System.Reflection.Assembly', 'getEntryAssembly getExecutingAssembly location')
		_fix('System.Reflection.MemberInfo', 'name')
		_fix('System.Reflection.FieldInfo', 'fieldType')
		_fix('System.Reflection.ParameterInfo', 'parameterType')
		_fix('System.Reflection.PropertyInfo', 'propertyType')

		# TODO: I don't think sigs outside the "standard lib" can be specified
		# HttpUtility.htmlEncode htmlDecode urlEncode urlDecode

		# TODO: shouldn't need the following. see comment in _fixSubs
		_fix('System.IO.StringWriter', 'toString')

	def _fix(className as String, memberNames as String)
		try
			type = .libraryType(className) to ?
		catch AssertException
			type = nil
		if type is nil
			print 'WARNING: Cannot find [className].'  # TODO: make a real warning
		if type inherits Box
			type.membersToUnNil = memberNames
		else
			print 'WARNING: Cannot fix [className] which is not a class/struct/interface. (type=[type])'  # TODO: make a real warning

	##
	## Binding
	##

	def bindUse
		require
			not .isBindingUse
			not .isBindingInh
			not .isBindingInt
			not .isBindingImp
		body
			if .verbosity >= 2
				print 'Binding use directives'
			_isBindingUse = true
			try
				Node.setCompiler(this)
				try
					for _curModule in _modules
						try
							_curModule.bindUse
						catch ce as SourceException
							.recordError(ce)
				finally
					Node.setCompiler(nil)
			finally
				_isBindingUse = false
			if _errors.count
				_exitFromErrors

	var _basicTypes as List<of PrimitiveType>?

	get basicTypes as IList<of PrimitiveType>
		if _basicTypes is nil
			_basicTypes = List<of PrimitiveType>()
			_basicTypes.addRange([.anyIntType, .boolType, .charType, .decimalType, .floatType])
			for signed in [true, false]
				for size in [8, 16, 32, 64]
					_basicTypes.add(.intType(signed, size))
		return _basicTypes to !

	def bindInh
		require
			not .isBindingUse
			not .isBindingInh
			not .isBindingInt
			not .isBindingImp
		body
			if .verbosity >= 2
				print 'Binding inheritance'
			_isBindingInh = true
			try
				Node.setCompiler(this)
				try
					for basicType in .basicTypes
						basicType.bindInh
					for _curModule in _modules
						try
							_curModule.bindInh
						catch ce as SourceException
							.recordError(ce)
					stringClass = .libraryClass('System.String')
					objectClass = .libraryClass('System.Object')
					assert stringClass.isDescendantOf(objectClass)
					assert stringClass.isDescendantOf(stringClass)
				finally
					Node.setCompiler(nil)
			finally
				_isBindingInh = false
			if _errors.count
				_exitFromErrors
	
	def bindInt
		require
			not .isBindingUse
			not .isBindingInh
			not .isBindingInt
			not .isBindingImp
		body
			if .verbosity >= 2
				print 'Binding interface'
			_isBindingInt = true
			try
				Node.setCompiler(this)
				try
					.fixNilableMemberSigs
					for basicType in .basicTypes
						basicType.bindInt
					for _curModule in _modules
						try
							_curModule.bindInt
						catch ce as SourceException
							.recordError(ce)
				finally
					Node.setCompiler(nil)
			finally
				_isBindingInt = false
			if _errors.count
				_exitFromErrors

	def bindImp
		require
			not .isBindingUse
			not .isBindingInh
			not .isBindingInt
			not .isBindingImp
		body
			if .verbosity >= 2
				print 'Binding implementation'
			# TODO: bindImp to all existing types
			_isBindingImp = true
			try
				Node.setCompiler(this)
				try
					for _curModule in _modules
						try
							_curModule.bindImp
						catch ce as SourceException
							.recordError(ce)
				finally
					Node.setCompiler(nil)
			finally
				_isBindingImp = false
			if _errors.count
				_exitFromErrors

	def symbolForName(name as String, canBeMember as bool, haveThis as bool) as IMember?
		"""
		name - obvious.
		canBeMember - the symbol can be a member of the current box
			TODO: can this be retired now that there is findLocal?
		haveThis - if false, symbols like methods, properties, etc. will not be returned while enums, nested classes, etc. could be.
		"""
		require
			name.length
		body
			# TODO: remove canBeMember arg
			assert _curModule
			
			# check for generic parameters in methods
			if not haveThis and not name[0].isLower
				if _codeMemberStack.count and _codeMemberStack.peek inherits Method
					m = (_codeMemberStack.peek to Method).genericParamForName(name) to IMember?
					if m
						return m

			# check the current box which will ask its namespace which will ask its `use` directives
			if _boxStack.count
				#print '>> .compiler.symbolForName([name], [canBeMember], [haveThis])'
				if name[0].toString.toLower==name[0] and name[0]>=c'a' and name[0]<=c'z'  # CC: if name[0].isLower
					assert false, 'use findLocal instead. [name]'
					return nil
				m = _boxStack.peek.symbolForName(name, haveThis)
				#print '<< .compiler.symbolForName returning', m
				#print
				return m
			else
				# example is an enum directly in a namespace with a ClrType instance created from clrType.getUnderlyingType
				return ((_curModule to dynamic).topNameSpace).symbolForName(name)  # TODO: cast is kind of weird, but SharpModule has no .topNameSpace

	def dumpModulesForTestify(output as IndentedWriter)
		.dumpModulesForTestify(output, 'Modules')

	def dumpModulesForTestify(output as IndentedWriter, title as String)
		print '[title]:'
		output.indent
		try
			print to output
				i = 1
				for module in _modules
					print '[i]. ' stop
					if module.isCobraLibrary
						print to output, module
					else
						module.writeDeepString(output)
					i += 1
		finally
			output.dedent

	def _exitFromErrors
		require .errors.count
		.printMessages
		throw StopCompilation(this)

	def printMessages
		if .htmlWriter
			.printHtmlMessages
		else
			.printConsoleMessages
		Environment.exitCode = if(.errors.count, 1, 0)

	def printHtmlMessages
		require .htmlWriter
		dest = .htmlWriter to !
		dest.writeHtml('<table class=messages cellpadding=2 cellspacing=2>[dest.newLine]\n')
		dest.writeHtml('<tr class=headings> <td class=heading> File </td> <td class=heading> Line </td> <td class=heading> Type </td> <td class=heading> Message </td> </tr>\n')
		for msg in _messages
			msg.writeHtmlTo(dest)
		dest.writeHtml('</table>[dest.newLine]')
		if _errors.count
			dest.writeHtml('<span class=compilationFailed>[_compilationFailedMessage()]</span><br>\n')  # CC: axe ()s
		else
			dest.writeHtml('<span class=compilationSucceeded>Compilation succeeded - [_warnings.count] warning[if(_warnings.count==1,'','s')]</span><br>\n')

	def printConsoleMessages
		willColor = .options.boolValue('color')
		savedColor = Console.foregroundColor
		if CobraCore.isRunningOnMono  # bug on mono: the initial Console.foregroundColor is not necessarily accurate (at least in bash on Terminal.app on Mac OS X 10.4.10 on Mono 1.2.4)
			savedColor = ConsoleColor.Black  # this is really just a guess and possibly a bad one. should be controllable via a cmd line option or argument
		for obj in _messages
			if willColor and obj.isError
				Console.foregroundColor = ConsoleColor.Red
				restoreColor = true
			print obj.consoleString
			if restoreColor
				Console.foregroundColor = savedColor
				restoreColor = false
		if _errors.count
			if willColor
				Console.foregroundColor = ConsoleColor.Red
			print _compilationFailedMessage()  # CC: axe ()s
			if willColor
				Console.foregroundColor = savedColor
		else
			didPrint = false
			if willColor
				Console.foregroundColor = ConsoleColor.Blue
			if _willPrintSuccessMsg or _warnings.count
				print 'Compilation succeeded' stop
				didPrint = true
			if _warnings.count
				print ' - [_warnings.count] warning[if(_warnings.count==1,'','s')]'
			else
				if didPrint
					print
			if willColor
				Console.foregroundColor = savedColor

	def _compilationFailedMessage as String
		return 'Compilation failed - [_errors.count] error[if(_errors.count==1,'','s')], [_warnings.count] warning[if(_warnings.count==1,'','s')]'
	
	##
	## Services to nodes
	##

	def canNameBeUndottedMember(name as String) as bool
		"""
		Returns true if the given name is the kind of name that can reference a box member without
		using the dot operator. Returns true if the name starts with an underscore or capital
		letter. The underscored names are typically protected data fields or methods while the
		uppercase names would be enums or (in the future) nested boxes.
		"""
		return name.startsWith('_') or Utils.isCapped(name)

	def findLocal(name as String) as AbstractLocalVar?
		"""
		Finds a local parameter or variable in the current code member.
		"""
		require
			.isBindingImp
			.codeMemberStack.count
		body
			return .codeMemberStack.peek.findLocal(name)

	def clrType(qualifiedName as String) as System.Type
		# eventually this method will be key in targeting different versions of the CLR
		# suppose you are on .NET 3.0 and want to target .NET 2.0
		return sharp'Type.GetType(qualifiedName)' to System.Type

	def libraryType(qualifiedName as String) as IType
		"""
		Used to retrieve types such as System.String.
		Example:
			.compiler.libraryType('System.String')
		"""
		return _libraryType(qualifiedName)

	def libraryBox(qualifiedName as String) as Box
		"""
		Returns a box from the standard library such as 'System.Object' or 'System.Collections.Generic.IEnumerable<of>'.
		"""
		return _libraryType(qualifiedName) to Box

	def libraryClass(qualifiedName as String) as Class
		"""
		Returns a class from the standard library such as 'System.Object' or 'System.Collections.Generic.Dictionary<of,>'.
		"""
		return _libraryType(qualifiedName) to Class

	var _libraryTypeCache = Dictionary<of String, IType>()

	def _libraryType(qualifiedName as String) as IType
		type as IType?
		if _libraryTypeCache.tryGetValue(qualifiedName, out type)
			return type to !
		names = qualifiedName.split(c'.')
		type = _libraryType(names to passthrough)
		_libraryTypeCache[qualifiedName] = type to !
		return type to !
		
	def _libraryType(names as vari String) as IType
		ns as IContainer = _globalNS
		thing as IContainer? = nil
		for name in names
			possible = (thing ? ns).declForName(name)
			assert possible, name
			if possible inherits IContainer
				thing = possible
			else
				assert false, [name, possible.getType.name, possible]
		if thing inherits IType
			if thing.name<>names[names.length-1] # TODO: add this as an ensure as well
				print 'names=' stop
				print CobraCore.toTechString(names)
				print 'thing=[thing]'
				assert false
			return thing
		else
			throw FallThroughException('found [name], but it is not an IType. it is [thing]')
	
	def suggestionFor(name as String) as String? is shared
		require name.length
		# CC: return _unknownSuggestions.getDefault(name, nil)
		if _unknownSuggestions.containsKey(name)
			return _unknownSuggestions[name]
		else
			return nil

	def warning(node as ISyntaxNode, msg as String)
		require msg.length
		.warning(CobraWarning(node.token, msg))

	def warning(cw as CobraWarning)
		require not cw.isError
		_addMessage(cw)

	shared
		var _unknownSuggestions = {
		# literals
		'null':		'nil',
		'NULL':		'nil',
		'None':		'nil',
		'Nothing':	'nil',
		'True':		'true',
		'False':	'false',

		# Python
		'self':		'this',
		'super':	'base',
		
		# C#
		'using':	'use',

		# operators (word ones anyway)
		'isa':		'inherits',
		'new':		'SomeClass() or SomeClass(arg1,arg2) without new',

		# constructs
		#'lambda':	'def(args) ...',  # TODO

		# statements
		'do':		'post while <condition>',
		'elif':		'else if',
		'elseif':	'else if',
		'foreach':	'for',
		'throw':	'raise',

		# types
		'boolean':	'bool',
		'double':	'float',
		'single':	'float32',
		'str':		'String',
		# TODO: various int types like short, byte, long
		}

	get unknownSuggestions from var


	##
	## Services to this
	##

	def _addMessage(message as SourceException)
		# Cobra can sometimes generate duplicate messages. Specifically, a constructed type might generate a message that its generic def did.
		# Also, assert statements whose conditions cause C# warnings will get duplicate warnings because of the expression breakdown.
		# Yeah, ideally, this would be fixed, but sometimes that's harder than just removing the duplicates:
		key = if(message.hasSourceSite, '[message.fileName]:[message.lineNum]', '')
		if _messagesPerSourceLine.containsKey(key)
			for se in _messagesPerSourceLine[key]
				if se.message.toLower == message.message.toLower
					if Utils.isDevMachine or .verbosity >= 3
						print 'Skipping duplicate message:', message.consoleString
					return
		else
			_messagesPerSourceLine[key] = List<of SourceException>()
		_messagesPerSourceLine[key].add(message)
		_messages.add(message)
		if message.isError
			_errors.add(message)
		else
			_warnings.add(message)

	##
	## Generating and compiling C#
	##

	var _moduleFileName_to_sharpToCobraLineNum as Dictionary<of String, Dictionary<of int, int>?>?

	def writeSharp
		Node.setCompiler(this)
		try
			_moduleFileName_to_sharpToCobraLineNum = Dictionary<of String, Dictionary<of int, int>>()
			for _curModule in _modules
				if not _curModule.fileName.endsWith('SystemInterfaces.cobra')
					sharpToCobraLineNum = _curModule.writeSharpDef
					_moduleFileName_to_sharpToCobraLineNum[_curModule.fileName] = sharpToCobraLineNum
					_moduleFileName_to_sharpToCobraLineNum[Path.getFullPath(_curModule.fileName)] = sharpToCobraLineNum
		finally
			Node.setCompiler(nil)

	def writeSharpTestInvocation
		dt = DateTime.now
		fileName = 'test-[dt.year][dt.month][dt.day][dt.hour][dt.minute].cs'  # TODO: format the numbers to have leading zeros
		using f = SharpWriter(File.createText(fileName))
			print to f
				print 'using System;'
				print 'using Cobra.Lang;'
				print ''
				print 'class RunTests {'
				print ''
				print '	public static void Main() {'
				print '		CobraImp.ShowTestProgress = true;'
				if .hasExceptionReportOption
					print '		bool success = false;'
					print '		try {'
				for module in _modules
					module.writeSharpTestInvocation(f)
				if .hasExceptionReportOption
					print '		success = true;'
					print '		} catch (Exception e) {'
					print '			CobraCore.HandleUnhandledException(e);'
					print '		}'
					print '		if (success)'
				print '		CobraImp.TestProgressWriter.WriteLine("\\nSuccess!  All tests pass.\\n");'
				print '	}'
				print '}'
		_modules.add(SharpModule(fileName, _verbosity))

	var _didWriteSharpInfoClass as bool

	def writeSharpInfoClass
		"""
		The Cobra.Lang.Info class is compiled into the program and contains, at least, the path to the cobra.exe.
		This is used for, at least, the implementation of CobraCore.findCobra.
		"""
		if _didWriteSharpInfoClass
			return
		cobraExePath = CobraCore.exePath
		assert File.exists(cobraExePath)
		infoPath = Path.combine(Path.getDirectoryName(cobraExePath), 'CobraInfo.cs')
		using sw = File.createText(infoPath)
			print to sw
				print 'using System;'
				print 'namespace Cobra.Lang {'
				print '    class CobraInfo {'
				print '        static public String CobraPath {'
				print '            get { return @"[cobraExePath]"; }'
				print '        }'
				print '    }'
				print '}'
		_didWriteSharpInfoClass = true

	var _cscExecPaths = [
		# TODO: should probably loop through available drives, or find the path for .NET and work off that
		[r'C:\WINDOWS\Microsoft.NET\Framework\v2.0.50727\csc', 'ms'],  # common
		[r'C:\WINNT\Microsoft.NET\Framework\v2.0.50727\csc', 'ms'],
		[r'D:\WINDOWS\Microsoft.NET\Framework\v2.0.50727\csc', 'ms'],  # common
		[r'D:\WINNT\Microsoft.NET\Framework\v2.0.50727\csc', 'ms'],
		[r'E:\WINDOWS\Microsoft.NET\Framework\v2.0.50727\csc', 'ms'],  # common
		[r'E:\WINNT\Microsoft.NET\Framework\v2.0.50727\csc', 'ms'],
		[r'\WINDOWS\Microsoft.NET\Framework\v2.0.50727\csc', 'ms'],
		[r'\WINNT\Microsoft.NET\Framework\v2.0.50727\csc', 'ms'],
		[r'/usr/bin/gmcs', 'novell'],  # common
		[r'/bin/gmcs', 'novell'],
		[r'/usr/local/bin/gmcs', 'novell'],
	]

	get baseExeFileName from var
		"""
		Returns the exe file name sans extension.
		"""

	get fullExeFileName from var
		"""
		Returns the exe file name with extension.
		"""

	var _platform as PlatformEnum

	get platform from var

	def compileSharp
		.compileSharp('')

	def compileSharp(extraCscOptions as String)
		require
			.modules.count
			# CC: why does the folowing expression generate C# errors? 2007-11-21 Novell Mono 1.2.4. Could be code gen problem
			# 'SystemInterfaces' in (for mod in .modules get mod.fileName)  # TODO: food for thought: this is inefficent because all fileNames are collected when we could just get out upon hitting the first SystemInterfaces
#			.modules[0].fileName.endsWith('SystemInterfaces.cobra')  # no longer the first module
		body
			if .verbosity >= 2
				print 'Compiling generated code'
			# locate the C# compiler
			isUnix = Utils.isRunningOnUnix
			isMono = CobraCore.isRunningOnMono
			found = false
			for execPathSpec in _cscExecPaths
				cscPath = execPathSpec[0]
				platform = execPathSpec[1]
				if isMono and platform <> 'novell'
					continue
				if isUnix and '\\' in cscPath
					continue  # skip windows paths
				if File.exists(cscPath) or File.exists(cscPath+'.exe')
					found = true
					break
			# special case: you're running Mono on MS Windows
			if not found and isMono and not isUnix
				paths = Environment.getEnvironmentVariable('PATH')
				if paths and paths.length
					for path in paths.split(c';')
						possible = Path.combine(path, 'gmcs.bat')
						if File.exists(possible)
							cscPath = possible
							platform = 'novell'
							found = true
							break
			if not found
				print 'Looked for C# compiler at:'
				for execPathSpec in _cscExecPaths
					cscPath = execPathSpec[0]
					print '  [cscPath]'
				print 'But cannot find a C# compiler from Microsoft .NET or Novell Mono.'
				throw StopCompilation(this)

			assert platform in ['ms', 'novell']
			_platform = if(platform=='ms', PlatformEnum.Microsoft, PlatformEnum.Novell)
			optChar = if(platform=='ms', '/', '-')  # option prefix character

			# exe names
			outName = if(_options.boolValue('test'), _modules[_modules.count-1].sharpFileName, _firstFileName to !)
			if outName.endsWith('.cs')
				outName = outName[:-3]
			if outName.endsWith('.cobra')
				outName = outName[:-6]
			_baseExeFileName = outName

			# options
			options = ''

			target = _options.getDefault('target', '') to String
			if target.length
				if target=='lib'
					target = 'library'
				options += ' [optChar]target:[target]'
				# TODO: what is the output for a module?
				branch target
					on 'exe', 'winexe': outName = Utils.forceExtension(outName, '.exe')
					on 'library': outName = Utils.forceExtension(outName, '.dll')
					on 'module': outName = Utils.forceExtension(outName, '.netmodule')  # http://msdn2.microsoft.com/en-us/library/58scf68s(VS.80).aspx
					else: throw FallThroughException(target)
			else
				outName += '.exe'
			_fullExeFileName = outName

			delaySign = _options.boolValue('delay-sign')
			if delaySign
				options += ' [optChar]delaysign+'
			
			keyContainer = _options.getDefault('key-container', nil)
			if keyContainer
				options += ' "[optChar]keycontainer:[keyContainer]"'

			keyFile = _options.getDefault('key-file', nil)
			if keyFile
				options += ' "[optChar]keyfile:[keyFile]"'
			
			optimize = _options.boolValue('optimize')
			if optimize
				options += ' [optChar]optimize+'

			thing = _options.getDefault('reference', List<of String>()) to List<of String>
			for refer in thing
				options += ' "[optChar]r:[refer]"'

			debug = _options.getDefault('debug', '') to String
			if debug.length
				# TODO: mono does not support full and pdbonly afaik
				assert debug in ['-', '+', 'full', 'pdbonly'], debug
				options += ' [optChar]debug' + if(debug.length==1, debug, ':[debug]')

			options += ' "[optChar]out:[outName]"'

			if _verbosity<3
				options += ' [optChar]nologo'

			options += ' [optChar]nowarn:0162,0169,0183,0184,0219,0414,0429'
				# CS0162: Unreachable code detected
				# CS0169: The private field `Cobra.Lang.CannotReadPropertyException._ih_invariantGuard' is never used
				# CS0183: The given expression is always of the provided (`int') type
				# CS0184: The given expression is never of the provided (`decimal') type
				# CS0219: The variable `x' is assigned but its value is never used / Cobra handles these
				# CS0414: The private field `Point._ih_invariantGuard' is assigned but its value is never used
				# CS0429: Unreachable expression code detected / MS C# 2.0 gives these especially for the 'bool' test case in 'basics'

			options += ' ' + extraCscOptions

			sharpArgs = .options.getDefault('sharp-args', '') to String
			if sharpArgs.length
				if sharpArgs.length > 2 and sharpArgs[0]=="'" and sharpArgs[sharpArgs.length-1]=="'"
					# on Windows, you should really use double quotes instead of single, but
					# we try to compensate here.
					sharpArgs = sharpArgs[1:-1]
				options += ' ' + sharpArgs
			
			for libPath in .options.getDefault('library-directory', '')
				options += ' ' + '-lib:[libPath]'

			# .cs files
			sharpFileNameList = List<of String>()
			for module in _modules[1:]
				if module.sharpFileName.length
					sharpFileNameList.add('"' + module.sharpFileName + '"')
			sharpFileNames = Utils.join(' ', sharpFileNameList)

			# compilation command
			if _verbosity
				print 'Compiling to produce [outName]'
			p = System.Diagnostics.Process()
			p.startInfo.fileName = cscPath
			p.startInfo.arguments = '[options] [sharpFileNames]'
			if _verbosity >= 2
				print '[p.startInfo.fileName] [p.startInfo.arguments]'
			output = CobraCore.runAndCaptureAllOutput(p)
			# TODO: check p.exitCode, especially if output is empty

			for line in output.split(c'\n') 
				line = line.trim
				if not line.length
					continue
				if SharpCompilationMessage.willSkipMessage(line)
					continue
				else
					if _verbosity >= 4
						print 'Got C# message: [line]'
					_addMessage(SharpCompilationMessage(line, this))
			if .errors.count
				_exitFromErrors

			# remove intermediate files such as *.cobra.cs
			if _intermediateFileNames.count == 0
				if _verbosity >= 1
					print 'No intermediate files to keep or delete.'
			else
				if _options.getDefault('keep-intermediate-files', 0)
					if _verbosity >= 1
						print 'Keeping intermediate files.'
				else
					if _verbosity >= 1
						print 'Deleting intermediate files.'
					for fileName in _intermediateFileNames
						if _verbosity >= 3
							print 'Deleting', fileName
						File.delete(fileName)

	def cobraLineNumForSharp(fileName as String, lineNum as int) as int
		"""
		Returns the source cobra line number given a filename (sans ".cs") and line number in the
		generated C#. Used by SharpCompilationMessage.
		"""
		# for some reason the C# filenames come in with a lower case drive letter,
		# and in 2006 strings are *still* case sensitive.
		# *sigh*
		if fileName.length>=2 and fileName[1]==c':'
			fileName = Utils.capped(fileName)

		# TODO: handle relative paths like ..\foo.cobra which C# spells out as absolute paths

		if not _moduleFileName_to_sharpToCobraLineNum.containsKey(fileName)
			return lineNum
		map = _moduleFileName_to_sharpToCobraLineNum[fileName]

		# sometimes the line numbers are one off. that's not ideal, but keep chugging:
		if not map.containsKey(lineNum) and map.containsKey(lineNum-1)
			lineNum -= 1

		if map.containsKey(lineNum)
			return map[lineNum]
		else
			# TODO: take this out someday. was put in 2006-11-12
			print '<> Cannot map C# location back to cobra.'
			print '   fileName = [fileName]'
			print '   lineNum = [lineNum]'
			print '   sharpToCobraLineNum = [CobraCore.toTechString(map)]'
			return map[lineNum]


class InternalError
	inherits SourceException
	"""
	Represents cases where the Cobra compiler itself has experienced an internal exception.
	"""

	var _fileName as String?
	var _lineNum as int?
	var _internalException as Exception

	def init(fileName as String, lineNum as int, message as String, internalException as Exception)
		.init(message, internalException)
		_fileName = fileName
		_lineNum = lineNum

	def init(message as String, internalException as Exception)
		base.init(('COBRA INTERNAL ERROR / ' + internalException.getType.name + ' / ' + message).replace('\r','').replace('\n','; ').trim)
		_internalException = internalException

	get isError as bool is override
		return true
		
	get hasSourceSite as bool is override
		return _fileName is not nil

	get fileName as String is override
		return _fileName to !

	get lineNum as int is override
		return _lineNum to !

	
class SharpCompilationMessage
	inherits SourceException

	def willSkipMessage(msg as String) as bool is shared
		if '.dll' in msg
			# comes up on Novell Mono: '/Library/Frameworks/Mono.framework/Versions/1.2.4/lib/mono/2.0/mscorlib.dll (Location of the symbol related to previous error)'
			# TODO: try removing these
			if msg.endsWith(' (Location of the symbol related to previous error)')
				return true
			if msg.endsWith(' (Location of the symbol related to previous warning)')
				return true
		if msg.startsWith('Compilation succeeded')
			# Novell Mono gmcs ends with this. Cobra handles this itself.
			return true
		if msg.startsWith('Compilation failed')
			# Novell Mono gmcs ends with this. Cobra handles this itself.
			return true
		return false
		
	var _fileName as String?
	var _lineNum as int?
	var _isError as bool

	def init(line as String, compiler as Compiler)
		require not .willSkipMessage(line)
		base.init(line)

		#   example lines:
		# foo.cobra.cs(14,14): error CS0535: `Foo' does not implement interface member `IFoo.Baz()'
		# error CS5001: Program `bugs/bugs-no-main.exe' does not contain a static `Main' method suitable for an entry point
		# foo(30,30):
		
		# trace line
		line = line.trim
		_isError = 'error ' in line
		if line.startsWith('error CS')
			i = line.indexOf(': ')
			line = line[i+2:]
		else
			i = line.indexOf('(')
			if i <> -1
				fileName = line[:i]
				if fileName.endsWith('.cs') and fileName.endsWith('.cobra.cs') # doesn't really happen since #line is generated at the top to set the filename to "Foo.cobra"
					fileName = fileName[:i-3]
					willFixLineNum = true
				else
					willFixLineNum = false
				j1 = line.indexOf(',', i)
				j2 = line.indexOf(')', i)
				j = if(j1 < j2, j1, j2)
				lineStr = line[i+1:j]
				try
					_lineNum = int.parse(lineStr)
				catch
					if compiler.verbosity or Utils.isDevMachine
						line += ' (C#)'
				success
					_fileName = fileName
					if willFixLineNum
						_lineNum = compiler.cobraLineNumForSharp(fileName, _lineNum to !)
					i = line.indexOf(':')
					if i <> -1
						line = line[i+1:].trim
						_isError = line.startsWith('error')
						i = line.indexOf(':')
						if i <> -1 and i < line.length and i+1 < line.length and line[i+1] == ' '
							line = line[i+1:].trim
					# add (sharp)
					if compiler.verbosity or Utils.isDevMachine
						line += ' (C#)'  # ' (C# [sharpLineNum])' ... the sharpLineNum is not useful now that #line is being generated
		line = line.replace("`double'", "`float'")
		line = line.replace("null", "nil")
		# change C#'s `funky' quotes to double quotes
		line = line.replace("`", '"')
		line = line.replace("'", '"')
		_message = line

	get isError as bool is override
		return _isError
		
	get hasSourceSite as bool is override
		return _fileName is not nil

	get fileName as String is override
		return _fileName to !

	get lineNum as int is override
		return _lineNum to !
