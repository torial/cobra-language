use System.Reflection
use System.Diagnostics


class StopCompilation
	inherits Exception
	"""
	Thrown by the compiler when it must stop compilation due to errors. This can happen at the end
	of the phases:
		* parsing
		* bind interface
		* bind implementation
		* code gen
	"""

	var _comp as Compiler

	cue init(comp as Compiler)
		_comp = comp


class UnexpectedInvocationException
	inherits SystemException
	"""
	Throw this when a class is not expecting a particular method to be invoked at runtime
	(even though it inherits it or must implement it for an interface).
	"""

	cue init(obj as Object)
		base.init('Not expecting invocation.')


enum PlatformEnum
	Microsoft
	Novell


class BackEnd is abstract

	cue init(compiler as Compiler)
		__compiler = compiler

	get compiler from __compiler as Compiler

	def generateIntermediateCode is abstract
	
	def generateBinary is abstract

	def generateCode(writeTestInvocation as bool) is abstract


class Compiler
	is partial
	implements ITypeProvider, IWarningRecorder, IErrorRecorder, ICompilerForNodes
	"""
	General notes:

	To cope with nesting, the compiler keeps a stack of the three types of things that can be nested. Items are pushed and popped off these stacks during each of the "bind interface" and "bind implementation" phases. The three stacks are:
		* nameSpaceStack - namespaces
		* boxStack - boxes are classes, structs and interfaces
		* codeMemberStack - methods, properties and inits
	"""

	var _backEnd as BackEnd?

	var _nextSerialNum as int is shared
	var _serialNum as int
	var _verbosity as int
	var _options as OptionValues
	var _commandLineArgParser as ArgParser?
	var _willPrintSuccessMsg = true
	var _htmlWriter as HtmlWriter?

	var _globalNS as NameSpace
	var _modules as List<of Module>
	var _parsedModules as List<of Module>? # accumulated as files parsed
	var _firstFileName as String?

	var _curModule as Module?  # set during bindInt and bindImp
	var _nodeStack as Stack<of INode>
	var _nameSpaceStack as Stack<of NameSpace>
	var _boxStack as Stack<of Box>
	var _boxMemberStack as Stack<of IBoxMember>
	var _codeMemberStack as Stack<of AbstractMethod>

	# TODO: could collapse these down to IsBindingEnum: None, Use, Int, Inh. Or PhaseEnum: None, Parsing, BindingUse, DidBindUse, BindingInh, DidBindInh, BindingInt, DidBindInt, BindingImp, DidBindImp, Generating, DidGenerate
	var _isBindingUse as bool
	var _isBindingInh as bool
	var _isBindingInt as bool
	var _isBindingImp as bool

	var _errors as List<of SourceException>
	var _warnings as List<of SourceException>
	var _messages as List<of SourceException>  # all errors and warnings
	var _messagesPerSourceLine as IDictionary<of String, List<of SourceException>>  # key is 'filename:lineNum'
	var _noWarningLines as ISet<of String>  	# key is 'filename:lineNum'

	var _intermediateFileNames as List<of String>
	var _loadedReferences as List<of String>

	var _clrTypeCache as Dictionary<of String, System.Type>


	# caches
	var _clrPrimitiveToITypeCache as IDictionary<of System.Type, IType>?


	cue init
		.init(0, nil)

	cue init(verbosity as int)
		.init(verbosity, nil)

	cue init(verbosity as int, initialModules as IList<of Module>?)
		Node.reset
		_nextSerialNum += 1
		_serialNum = _nextSerialNum
		_verbosity = verbosity
		_modules = List<of Module>()
		_options = OptionValues()
		_globalNS = NameSpace(Token.empty, '(global)')
		_nodeStack = Stack<of INode>()
		_nameSpaceStack = Stack<of NameSpace>()
		_boxStack = Stack<of Box>()
		_boxMemberStack = Stack<of IBoxMember>()
		_codeMemberStack = Stack<of AbstractMethod>()
		_messages = List<of SourceException>()
		_messagesPerSourceLine = Dictionary<of String, List<of SourceException>>()
		_noWarningLines = Set<of String>()
		_errors = List<of SourceException>()
		_warnings = List<of SourceException>()
		_intermediateFileNames = List<of String>()
		_loadedReferences = List<of String>()
		_clrTypeCache = Dictionary<of String, System.Type>()
		if initialModules
			if false # TODO: not working yet
				for mod in initialModules
					if mod inherits AssemblyModule
						ns = mod.topNameSpace
						assert not ns.superNameSpace
						ns.unifyInto(_globalNS)
					# TODO: handle CobraModule too
					_modules.add(mod)

	def toString as String is override
		return '[.getType.name]([_serialNum])'

	get backEnd from var

	get verbosity from var

	get includeTests as bool
		return .options.boolValue('include-tests')

	get isBindingUse from var

	get isBindingInh from var

	get isBindingInt from var

	get isBindingImp from var

	get clrPrimitiveToITypeCache from var
		"""
		Returns a cache mapping CLR types to their corresponding ITypes.
		Populated and used by ClrTypeProxy.
		"""

	get globalNS from var

	get modules from var

	pro options from var

	pro commandLineArgParser from var

	pro willPrintSuccessMsg from var

	get curModule from var

	get nodeStack from var

	get nameSpaceStack from var

	get curNameSpace as NameSpace
		require .nameSpaceStack.count
		return _nameSpaceStack.peek

	get boxStack from var

	get curBox as Box
		require .boxStack.count
		return _boxStack.peek

	get curBoxMember as IBoxMember
		require .boxMemberStack.count
		return _boxMemberStack.peek

	get boxMemberStack from var

	get curCodeMember as AbstractMethod
		require .codeMemberStack.count
		return _codeMemberStack.peek

	get codeMemberStack from var

	get errors from var

	get warnings from var

	get messages from var

	get noWarningLines from var

	get loadedReferences from var
		"""
		Returns the list of library references that were loaded.
		This could be more than what's specified on the command line due to UseDirective.
		And it could be less due to failures to load.
		"""

	pro htmlWriter from var
		"""
		Set this to support the output-html command line option.
		"""

	get hasDetailedStackTraceOption as bool
		return _options.boolValue('detailed-stack-trace')

	get willTrackLocals as bool
		# the box stack can be empty because of assembly; has SomeAttr
		if .boxStack.count
			# the code member stack can be empty due to class variables (ex: var _x = 1)
			return .hasDetailedStackTraceOption and (.codeMemberStack.count == 0 or .curCodeMember.parentBox.canHaveDetailedStackTrace)
		else
			return false

	get hasExceptionReportOption as bool
		return .options.boolValue('exception-report')

	def recordError(error as SourceException)
		"""
		Node calls this to record errors.
		"""
		if error inherits NodeMultiException
			for exc in error.exceptions
				_addMessage(exc)
		else
			_addMessage(error)

	def addIntermediateFile(path as String)
		_intermediateFileNames.add(path)

	get cobraExeDir as String
		"""
		Returns the directory where cobra.exe is residing.
		Related resources such as CobraLang.cs reside there.
		"""
		return Path.getDirectoryName(Assembly.getEntryAssembly.location) to !  # actually could be nil: if you stuck Cobra in the root dir, the .getDirectoryName docs say it will return nil
		
	def compileFilesNamed(paths as IList<of String>)
		.compileFilesNamed(paths)

	def compileFilesNamed(paths as IList<of String>, writeTestInvocation as bool, stopAfterBindInt as bool)
		if .options.boolValue('reveal-internal-exceptions')
			_compileFilesNamed(paths, writeTestInvocation, stopAfterBindInt)
			.printMessages
			return
		else
			try
				_compileFilesNamed(paths, writeTestInvocation, stopAfterBindInt)
			catch StopCompilation
				throw
			catch exc as Exception
				# unexpected exception -- only StopCompilation should be thrown
				if exc inherits SourceException
					if exc.hasSourceSite
						.recordError(InternalError(exc.fileName, exc.lineNum, exc.message, exc))
					else
						.recordError(InternalError(exc.message, exc))
				else if exc inherits AssertException
					sn as SyntaxNode?
					if exc.this inherits SyntaxNode
						sn = exc.this to SyntaxNode
					else if exc.info inherits SyntaxNode
						sn = exc.info to SyntaxNode
					if sn
						.recordError(InternalError(sn.token.fileName, sn.token.lineNum, exc.message, exc))
					else
						.recordError(InternalError(exc.message, exc))
				else
					.recordError(InternalError(exc.message, exc))
				.printMessages
				throw StopCompilation(this)
			success
				.printMessages

	def _compileFilesNamed(paths as IList<of String>, writeTestInvocation as bool, stopAfterBindInt as bool)
		_initBackEnd
		.parseFilesNamed(paths)
		.bindUse
		.writeSourceCodeCorrections
		.bindInh
		.writeSourceCodeCorrections
		.bindInt
		.writeSourceCodeCorrections
		.computeMatchingBaseMembers
		.writeSourceCodeCorrections
		if stopAfterBindInt, return  # in support of the -doc option
		.bindImp
		.writeSourceCodeCorrections
		.backEnd.generateCode(writeTestInvocation)
	
	def testifyFilesNamed(fileNames as IList<of String>, options as OptionValues, resultsWriter as IndentedWriter, verbose as bool)
		"""
		Compiles the given fileNames in support of "testify".
		Sets .options to the options arg.
		Will raise StopCompilation when an error occurs.
		"""
		.options = options
		bar = '----------------------------------------------------------------------------------------------------'
		_initBackEnd
		.parseFilesNamed(fileNames)

		assert .modules.count
		if verbose
			.dumpModulesForTestify(resultsWriter, 'Modules after parsing')
			print bar

		if verbose, print 'Bind use:'
		.bindUse
		if verbose, print 'Bind inheritance:'
		.bindInh
		if verbose, print 'Bind interface:'
		.bindInt
		if verbose
			.dumpModulesForTestify(resultsWriter, 'Modules after binding interface')
			print 'Bind implementation:'
		.computeMatchingBaseMembers
		.bindImp
		if verbose
			.dumpModulesForTestify(resultsWriter, 'Modules after binding implementation')
			print bar
			print 'Generated C#:'
		_backEnd.generateIntermediateCode
		if verbose
			for module in .modules
				if not module.isCobraLibrary
					Utils.printSource(module.sharpSource)
			print bar
			print 'Compile C#:'
		_backEnd.generateBinary
		.printMessages
		print bar

	def	_addRuntimeRef(opts as OptionValues)
		if not opts.containsKey('reference')
			opts['reference'] = List<of String>()
		refs = opts['reference'] to List<of String>
		libName = 'Cobra.Lang.dll'
		if libName not in refs
			if .verbosity, print 'Adding reference to [libName]'
			refs.add(libName)

	def parseFilesNamed(filenames as IList<of String>) as List<of Module>
		"""
		Returns the modules for the newly parsed files.
		Also, extends _modules with those modules.
		"""
		require
			filenames.count or .options.buildStandardLibrary
		ensure
			true
		body
			_firstFileName = if(.options.buildStandardLibrary, 'Cobra.Lang.dll', filenames[0])

			embedRunTime = .options.boolValue('embed-run-time')

			if not embedRunTime
				_addRuntimeRef(.options)  # then reference runtime dll

			Node.setCompiler(this)
			try
				if _modules.count == 0  # attempt at caching modules during testify. incomplete.
					if embedRunTime
						# The Cobra.Lang.Info class is compiled into the program and contains, at least, the path to the cobra.exe.
						# This is used for, at least, the implementation of CobraCore.findCobra.
						sw = StringWriter()
						print to sw
							print 'namespace Cobra.Lang'
							print '    class CobraInfo'
							print '        get cobraPath as String is shared'
							print '            return r"[CobraCore.exePath]"'
						.options.addExtraSource(sw.toString)
					.readSystemTypes
					.readAssemblyTypes(.options)

				if true # _modules.count == 0
					if embedRunTime
						paths = .commandLineArgParser.readFilesFile(Path.combine(Path.combine(.cobraExeDir, 'Cobra.Lang'), 'files.text'))
						paths.reverse
						for path in paths
							if Path.getFileName(path) == 'Native.cs'
								suffix = .embedRunTimeSuffix
								nativeCode = File.readAllText(path)
								nativeCode = nativeCode.replace('namespace Cobra.Lang', 'namespace Cobra.Lang'+suffix)
								newPath = Path.getFullPath('Native[suffix].cs')
								File.writeAllText(newPath, nativeCode)
								.addIntermediateFile(newPath)
								filenames.insert(0, newPath)
							else
								filenames.insert(0, path)
						
				modules = List<of Module>()
				_parsedModules = modules

				# implement -extra-source option
				extraSource = .options.getDefault('extra-source', '').trim to String
				if extraSource <> ''
					# CC: parser = CobraParser(verbosity=_verbosity, typeProvider=this, warningRecorder=this, errorRecorder=this, globalNS=_globalNS, parseCommandLineArgs=ref .parseCommandLineArgsCallBack)
					parser = CobraParser(verbosity=_verbosity, typeProvider=this, warningRecorder=this, errorRecorder=this, globalNS=_globalNS)
					parser.parseCommandLineArgs = ref .parseCommandLineArgsCallBack
					module = parser.parseSource('_ch_cobra-extra-source.cobra', extraSource)  # ch = compiler helper
					for r in parser.references, .loadReference(_fixLibExtension(r))
					modules.add(module)

				for filename in filenames
					if filename.endsWith('.cs')
						if _verbosity, print 'Noting  [filename]'  # extra space to line up with 'Parsing [filename]'
						modules.add(SharpModule(filename, _verbosity))
					else
						parser = CobraParser()
						parser.verbosity = _verbosity
						parser.typeProvider = this
						parser.warningRecorder = this
						parser.errorRecorder = this
						parser.parseCommandLineArgs = ref .parseCommandLineArgsCallBack
						parser.globalNS = _globalNS
						# @@ TODO: assert _globalNS is parser.nameSpaceStack[0]
						try
							module = parser.parseFileNamed(filename)
						catch SourceException
							pass
						success
							for r in parser.references, .loadReference(_fixLibExtension(r))
							# There could still be parse errors that were recorded, but not thrown.
							# But that's okay because _errors.count is checked further below.
							modules.add(module)
			finally
				Node.setCompiler(nil)
			if _errors.count
				_exitFromErrors
			else
				assert modules.count
				_modules.addRange(modules)
				_parsedModules = nil
			return modules

	def parseCommandLineArgsCallBack(args as IList<of String>, isAvailable as out bool) as String?
		"""
		This is the call back for implementing the `args` directive as encountered in the Parser.
		"""
		if .commandLineArgParser
			isAvailable = true
			try
				.augmentOptions(.commandLineArgParser.parseToOptions(args))
			catch ape as ArgParseException
				return ape.message
		else
			isAvailable = false
		return nil

	def augmentOptions(opts as OptionValues)
		"""
		Update Options and accumulator lists generated from it with additional options settings.
		  Used from inside parseFiles for args compilerDirective handling
 		"""
		if .verbosity
			print 'preAugment Options Dictionary'
			.options.print

		# special cases 
		_fixLibRefs(opts)
		_fixEmbedRunTime(opts) # need this after fix libs

		.options.combineNew(opts)
		v = .options.getDefault('verbosity', 0) to int
		if v > _verbosity, _verbosity = v
		if .verbosity
			print 'postAugment Options Dictionary'
			.options.print

	def _fixEmbedRunTime(opts as OptionValues)
		# print 'before fix embed-run-time', _parsedModules
		if opts.boolValue('embed-run-time') <> .options.boolValue('embed-run-time')
			if not opts.boolValue('embed-run-time') # changed true to false
				# remove parsed rtSrc modules
				for m in List<of Module>(_parsedModules)
					if m.isCobraLibrary and not m.fileName.endsWith('.dll')
						_parsedModules.remove(m)
				_addRuntimeRef(opts)  # add ref to runtime dll
			else
				opts['embed-run-time'] = .options['embed-run-time']
				# errchannel.throwError('Cannot switch -ert:no to -ert:yes in compilerDirective')
				# To support this need to determine where/what recorded for Cobra.dll 
				# ref,clear it out and insert rtl src to be parsed AFTER finish current file
		# print 'after fix embed-run-time', _parsedModules
		
	def _fixLibRefs(opts as OptionValues)
		haveRefs = false
		for key in ['library-directory', 'pkg', 'reference']
			if opts.containsKey(key)
				if key == 'reference'
					references = opts.getStringList('reference')
					_fixLibExtensions(references)
				if not .options.containsKey(key)
					.options[key] = List<of String>()
				existList = .options[key] to List<of String>
				augList = opts[key] to List<of String>
				dupCount = 0
				for item in augList
					if item not in existList
						if .verbosity, print 'Adding [key] "[item]"'
						existList.add(item)
					else
						if .verbosity, print '[key] "[item]" already in options.[key]'
						dupCount += 1 # augList.remove(item) <-- 2008-10-13 CE: what's that comment mean? (part of ticket:35)
				if not haveRefs
					haveRefs = key <> 'library-directory' and augList.count - dupCount > 0
				.options.didSpecify(key) # so not overwrite when combine
							
		if haveRefs
			.readAssemblyTypes(opts)
			if .verbosity > 1
				references = .options.getStringList('reference')
				_printRefs(references)
		
			
	def runProcess as Process
		return .runProcess(nil, nil)
		
	def runProcess(exeName as String?, argList as List<of String>?) as Process
		"""
		Returns a new Process with startInfo.fileName and p.startInfo.arguments set appropriately
		for the produced executable and the current options and any provided argsList.
		"""
		p = Process()
		baseExeFileName = exeName ? .baseExeFileName
		fullExeFileName = exeName ? .fullExeFileName
		branch .platform
			on PlatformEnum.Microsoft
				p.startInfo.fileName = baseExeFileName
			on PlatformEnum.Novell
				p.startInfo.fileName = 'mono'
				args = ''
				# mono also needs --debug when running
				if .options.getDefault('debug', '') not in ['', '-']
					args += '--debug '
				args += '"[fullExeFileName]"'
				p.startInfo.arguments = args + ' '
			else
				throw FallThroughException(.platform)

		if argList and argList.count
			args = p.startInfo.arguments ? ''
			if args <> '', args += ' '
			hasSpaces = any for a in argList where ' ' in a
			if hasSpaces
				argList = for arg in argList get if(' ' in arg, '"[arg]"', arg)
			args += Utils.join(' ', argList) 
			p.startInfo.arguments = args
		return p

	##
	## ITypeProvider
	##

	var _anyFloatType as AnyFloatType?
	var _anyIntType as AnyIntType?
	var _boolType as BoolType?
	var _charType as CharType?
	var _decimalType as DecimalType?
	var _dynamicType as DynamicType?
	var _floatTypes = Dictionary<of int, FloatType>()
	var _intTypes = Dictionary<of int, IntType>()
	var _nilType as NilType?
	var _numberType as AbstractNumberType?
	var _passThroughType as PassThroughType?
	var _unspecifiedType as UnspecifiedType?
	var _voidType as VoidType?
	var _variTypes as Dictionary<of INode, VariType>?
	var _nilableDynamicType as NilableType?

	def typeForName(name as String) as IType
		assert false, 'TODO'
		return .intType

	def typeOrNilForName(name as String) as IType?
		assert false, 'TODO'
		return nil

	get anyFloatType as AnyFloatType
		if _anyFloatType is nil
			_anyFloatType = AnyFloatType()
		return _anyFloatType to !

	get anyIntType as AnyIntType
		if _anyIntType is nil
			_anyIntType = AnyIntType()
		return _anyIntType to !

	get boolType as BoolType
		if _boolType is nil
			_boolType = BoolType()
		return _boolType to !

	get charType as CharType
		if _charType is nil
			_charType = CharType()
		return _charType to !

	get decimalType as DecimalType
		if _decimalType is nil
			_decimalType = DecimalType()
		return _decimalType to !

	get dynamicType as DynamicType
		if _dynamicType is nil
			_dynamicType = DynamicType()
		return _dynamicType to !

	def floatType as FloatType
		return .floatType(64)
	
	def floatType(size as int) as FloatType
		require size in [32, 64]
		type as FloatType?
		if _floatTypes.tryGetValue(size, out type)
			return type to !
		else
			type = _floatTypes[size] = FloatType(size, .anyFloatType)
			return type to !

	def intType as IntType
		return .intType(true, 32)

	def uintType as IntType
		return .intType(false, 32)

	def intType(signed as bool, size as int) as IntType
		require size in [8, 16, 32, 64] # CC: inherit from interface
		key = if(signed, -1, +1) * size
		type as IntType?
		if _intTypes.tryGetValue(key, out type)
			return type to !
		else
			type = _intTypes[key] = IntType(signed, size, .anyIntType)
			return type to !

	get nilType as NilType
		if _nilType is nil
			_nilType = NilType()
		return _nilType to !

	get numberType as AbstractNumberType
		if _numberType is nil
			branch .options['number'] to String
				on 'decimal', _numberType = .decimalType
				on 'float',   _numberType = .floatType
				on 'float32', _numberType = .floatType(32)
				on 'float64', _numberType = .floatType(64)
				else, throw FallThroughException(.options['number'])
		return _numberType to !

	set numberTypeName as String
		"""
		Set `number` type from a string/name.
		"""
		require value in ['decimal', 'float', 'float32', 'float64']
		branch value
			on 'decimal', _numberType = .decimalType
			on 'float',   _numberType = .floatType
			on 'float32', _numberType = .floatType(32)
			on 'float64', _numberType = .floatType(64)
			else, throw FallThroughException(value)

	get passThroughType as PassThroughType
		if _passThroughType is nil
			_passThroughType = PassThroughType()
		return _passThroughType to !

	get typeType as IType
		return _libraryType('System.Type')

	get unspecifiedType as UnspecifiedType
		if _unspecifiedType is nil
			_unspecifiedType = UnspecifiedType()
		return _unspecifiedType to !

	get voidType as VoidType
		if _voidType is nil
			_voidType = VoidType()
		return _voidType to !

	def variType(type as IType) as VariType
		if _variTypes is nil
			_variTypes = Dictionary<of INode, VariType>()
		else if _variTypes.containsKey(type)
			return _variTypes[type]
		_variTypes[type] = vt = VariType(type)
		return vt

	def defaultType as IType
		return .nilableDynamicType

	def nilableDynamicType as NilableType
		if _nilableDynamicType is nil
			_nilableDynamicType = .nilableType(.dynamicType)
		return _nilableDynamicType to !


	## More type stuff

	def nilableType(t as IType) as NilableType
		"""
		Returns a NilableType wrapper for t, unless t is already a NilableType in which case
		it is returned directly.
		"""
		if t inherits NilableType
			return t
		else
			return NilableType(t).bindAll to NilableType  # CC: axe cast after "as this"

	def readSystemTypes
		# TODO: support targeting a specific CLR version, but not below 2.0
		.readAssembly(Assembly.load('mscorlib.dll') to !)

		# TODO: .readAssembly(Assembly.loadFrom('System.dll') to !)
		#       gives: Unhandled Exception: System.IO.FileNotFoundException: Could not load file or assembly 'System.dll' or one of its dependencies. The system cannot find the file specified.

		t = System.Diagnostics.Process.getType
		.readAssembly(t.assembly) # System.dll

	def _fixLibExtension(reference as String) as String
		require reference.length
		ensure reference.endsWith('.dll') or reference.endsWith('.exe')
		if not reference.endsWith('.dll') and not reference.endsWith('.exe')
			reference += '.dll'
		return reference

	def _fixLibExtensions(references as List<of String>)
		i = 0
		for reference in List<of String>(references)
			references[i] = _fixLibExtension(reference)
			i += 1
			
	def _printRefs(references as List<of String>)
		if references.count == 0
			print 'No additional assembly references.'
		else
			print 'Final assembly reference list:'
			i = 0
			for refPath in references
				print '[i]. [refPath]'
				i += 1
			
	def readAssemblyTypes(options as OptionValues)
		references = options.getStringList('reference')

		# Excluding the extension can be problematic
		_fixLibExtensions(references)

		# now that references are fixed, make a copy so that .options['references'] is not modified further
		references = List<of String>(references)

		if options.containsKey('pkg')
			for pkgName in options['pkg'] to List<of String>
				references.addRange(.refsForPackage(pkgName))

		if .verbosity > 1
			_printRefs(references)

		# Here be "reflectionOnlyLoad" code... which does not work on Mono 1.2.4
		# The run-time error message says:
		#   ** (./cobra.exe:24284): WARNING **: Cannot resolve dependency to assembly 'System, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089' because it has not been preloaded. When using the ReflectionOnly APIs, dependent assemblies must be pre-loaded or loaded on demand through the ReflectionOnlyAssemblyResolve event.
		# But hooking ReflectionOnlyAssemblyResolve has no effect as it never gets called.
		# Looks like others are having problems too:
		#   http://csammisrun.net/shaim/viewtopic.php?t=29&sid=e46dc962b1e4d14a5210ae2852ac7d87
		# General references:
		# * "Reflection Only Assembly Loading" blog entry by Junfeng Zhang
		#   http://blogs.msdn.com/junfeng/archive/2004/08/24/219691.aspx
		# * http://forums.microsoft.com/MSDN/ShowPost.aspx?PostID=2485940&SiteID=1
		#   Justin Pinnix from MSFT says "Once our assembly resolver finds your DLL, it calls
		#   Assembly.LoadFrom().  So, even though your code calls Assembly.Load, we still
		#   call Assembly.LoadFrom"
		# TODO: try this out on MS .NET and if it works there, use it there
		# TODO: file a Mono bug report (or ping an existing one)
		# curDomain = AppDomain.currentDomain
		# $sharp('curDomain.ReflectionOnlyAssemblyResolve += _resolveEvent')

		for reference in references
			if not .loadReference(reference)
				_addMessage(SourceException('Cannot locate assembly reference "[reference]".'))

	def refsForPackage(pkgName as String) as List<of String>
		"""
		Returns the library/DLL refs for the give package name.
		Runs pkg-config to get that list.
		See HowTo/GTK.cobra
		"""
		refs = List<of String>()

		# example: pkg-config --libs gtk-sharp-2.0
		p = Process()
		p.startInfo.fileName = 'pkg-config'
		p.startInfo.arguments = '--libs [pkgName]'
		if .verbosity > 1
			print 'Running: [p.startInfo.fileName] [p.startInfo.arguments]'
		output = CobraCore.runAndCaptureAllOutput(p).trim
		if p.exitCode
			_addMessage(SourceException('Cannot locate package "[pkgName]"'))
			print ' $ [p.startInfo.fileName] [p.startInfo.arguments]'
			for line in output.split(c'\n')
				print ' |', line
			return refs

		parts = output.replace('-r:', '\0').split(c'\0')  # while Cobra uses -ref:, pkg-config outputs -r:
		for part in parts
			if part.trim <> '', refs.add(part.trim)
		
		return refs

	def _resolveEvent(sender as Object, args as ResolveEventArgs) as Assembly?
		return nil

	def loadReference(reference as String) as bool
		"""
		Attempts to load the given library reference.
		On success, adds reference to .loadedReferences and returns true.
		On failure, returns false, but does not add any warnings or errors.
		This method is used by Compiler and UseDirective.
		"""
		try
			return _loadReference(reference)
		catch System.IO.FileNotFoundException
			# example: Could not load file or assembly 'NHibernate, Version=2.1.0.1001,
			# Culture=neutral, PublcKeyToken=aa95f207798dfdb4' or one of its dependencies. The
			# system cannot find the file specified.
			return false
		catch System.IO.FileLoadException
			return false

	def _loadReference(reference as String) as bool
		require
			reference.endsWith('.dll') or reference.endsWith('.exe')
			reference not in ['.dll', '.exe']
		ensure
			result implies .loadedReferences[.loadedReferences.count-1] == reference
			not result implies .loadedReferences.count == old .loadedReferences.count
		body
			if .verbosity > 0
				print 'Loading reference:', reference
			assert not (reference.startsWith('-r') and '-r' in reference[2:])
			if false
				# Does not work on Novell Mono. See notes above.
				referredAss = Assembly.reflectionOnlyLoadFrom(reference)
				# TODO: handle all the exceptions from Assembly.loadFrom
			else
				if File.exists(reference)
					# try current directory
					referredAss = Assembly.loadFrom(reference)
				else
					# TODO: the problem with -lib: in both Cobra and C# is that it has no effect on runtime,
					# you must still register the DLLs in the GAC or copy them into the same dir as the .exe
					# because the -lib: paths are not passed into executable.
					# So should Cobra copy the .dll's into the target directory (if their paths are not in MONO_PATH)?
					searchPaths = .options.getDefault('library-directory', List<of String>()) to List<of String>
					# TODO: ?: searchPaths.add(Path.getDirectoryName(Assembly.getExecutingAssembly.location))  # try Cobra's directory - also should be added to .options.'library-directory' not to a local var
					found = false
					for searchPath in searchPaths
						combinedPath = Path.combine(searchPath, reference)
						if File.exists(combinedPath)
							referredAss = Assembly.loadFrom(combinedPath)
							found = true
							break
					if not found
						# try system wide (GAC)
						if reference.endsWith('.dll'), reference = reference[:-4]
						referredAss = Utils.loadWithPartialName(reference)
						reference += '.dll'  # restore to original value
				# TODO: handle all the exceptions from Assembly.loadFrom
			if referredAss
				for dependency in referredAss.getReferencedAssemblies
					.loadAssembly(dependency)
				.readAssembly(referredAss, reference <> 'Cobra.Lang.dll')
				# reassert the preconditions. there have been bugs in the past
				assert reference.endsWith('.dll') or reference.endsWith('.exe')
				assert reference not in ['.dll', '.exe']
				.loadedReferences.add(reference)
				return true
			else
				return false

	var _didLoadAssemblies = Set<of String>()

	def loadAssembly(assName as AssemblyName)
		if assName.toString in _didLoadAssemblies, return
		_didLoadAssemblies.add(assName.toString)
		try
			ass = Assembly.load(assName)  # Will not pick up the assembly from the same directory.
		catch FileNotFoundException       # In fact, will get a FileNotFoundException!
			.loadReference(assName.name + '.dll')
			# TODO: compare the the name loaded to the name given with AssemblyName.referenceMatchesDefinition
			return
		catch exc as Exception
			throw SourceException('Could not open assembly "[assName]" due to: [exc.getType.name]: [exc.message]')
		for dependency in ass.getReferencedAssemblies
			.loadAssembly(dependency)
		.readAssembly(ass)


	##
	## Binding
	##

	def bindUse
		require
			not .isBindingUse
			not .isBindingInh
			not .isBindingInt
			not .isBindingImp
		body
			if .verbosity >= 2
				print 'Binding use directives'
			_isBindingUse = true
			try
				Node.setCompiler(this)
				try
					i = 0
					while i < _modules.count  # new modules can be added, say by the UseDirective
						_curModule = _modules[i]
						try
							_curModule.bindUse
						catch ce as SourceException
							.recordError(ce)
						i += 1
				finally
					Node.setCompiler(nil)
			finally
				_isBindingUse = false
			if _errors.count
				_exitFromErrors

	var _basicTypes as List<of PrimitiveType>?

	get basicTypes as IList<of PrimitiveType>
		if _basicTypes is nil
			_basicTypes = List<of PrimitiveType>()
			_basicTypes.addRange([.anyFloatType, .anyIntType, .boolType, .charType, .decimalType, .floatType])
			for size in [32, 64]
				_basicTypes.add(.floatType(size))
			for signed in [true, false]
				for size in [8, 16, 32, 64]
					_basicTypes.add(.intType(signed, size))
		return _basicTypes to !

	def bindInh
		require
			not .isBindingUse
			not .isBindingInh
			not .isBindingInt
			not .isBindingImp
		body
			if .verbosity >= 2
				print 'Binding inheritance'
			_isBindingInh = true
			try
				Node.setCompiler(this)
				try
					for basicType in .basicTypes
						basicType.bindInh
					.objectType.bindInh
					.stringType.bindInh
					for _curModule in _modules
						try
							_curModule.bindInh
						catch ce as SourceException
							.recordError(ce)
					assert .stringType.isDescendantOf(.objectType)
					assert .stringType.isDescendantOf(.stringType)
				finally
					Node.setCompiler(nil)
			finally
				_isBindingInh = false
			if _errors.count
				_exitFromErrors

	def bindInt
		require
			not .isBindingUse
			not .isBindingInh
			not .isBindingInt
			not .isBindingImp
		body
			if .verbosity >= 2
				print 'Binding interface'
			_isBindingInt = true
			try
				Node.setCompiler(this)
				try
					.fixNilableMemberSigs
					for basicType in .basicTypes
						basicType.bindInt
					.objectType.bindInt
					.stringType.bindInt
					for _curModule in _modules
						try
							_curModule.bindInt
						catch ce as SourceException
							.recordError(ce)
				finally
					Node.setCompiler(nil)
			finally
				_isBindingInt = false
			if _errors.count
				_exitFromErrors

	def computeMatchingBaseMembers
		Node.setCompiler(this)
		try
			for _curModule in _modules
				try
					_curModule.computeMatchingBaseMembers
				catch se as SourceException
					.recordError(se)
		finally
			Node.setCompiler(nil)

	def bindImp
		require
			not .isBindingUse
			not .isBindingInh
			not .isBindingInt
			not .isBindingImp
		body
			if .verbosity >= 2
				print 'Binding implementation'
			# TODO: bindImp to all existing types
			_isBindingImp = true
			try
				Node.setCompiler(this)
				try
					for _curModule in _modules
						try
							_curModule.bindImp
						catch ce as SourceException
							.recordError(ce)
				finally
					Node.setCompiler(nil)
			finally
				_isBindingImp = false
			if _errors.count
				_exitFromErrors

	def symbolForName(name as String, canBeMember as bool, haveThis as bool) as IMember?
		return .symbolForName(name, canBeMember, haveThis, false)

	def symbolForName(name as String, canBeMember as bool, haveThis as bool, isLowerOkay as bool) as IMember?
		"""
		name - obvious.
		canBeMember - the symbol can be a member of the current box
			TODO: can this be retired now that there is findLocal?
		haveThis - if false, symbols like methods, properties, etc. will not be returned while enums, nested classes, etc. could be.
		"""
		require
			name.length
		body
			# TODO: remove canBeMember arg
			assert _curModule

			# check for generic parameters in methods
			if not haveThis and not name[0].isLower
				if _codeMemberStack.count and _codeMemberStack.peek inherits Method
					m = (_codeMemberStack.peek to Method).genericParamForName(name) to IMember?
					if m, return m

			# check the current box which will ask its namespace which will ask its `use` directives
			if _boxStack.count
				#print '>> .compiler.symbolForName([name], [canBeMember], [haveThis])'
				if not isLowerOkay and name[0].isLower
					assert false, 'use findLocal instead. [name]'
					return nil
				m = _boxStack.peek.symbolForName(name, haveThis)
				#print '<< .compiler.symbolForName returning', m
				#print

			if m is nil
				# global namespace of the current module
				m = ((_curModule to dynamic).topNameSpace).symbolForName(name)
				# TODO: cast above is kind of weird, but SharpModule has no .topNameSpace

			return m

	def dumpModulesForTestify(output as IndentedWriter)
		.dumpModulesForTestify(output, 'Modules')

	def dumpModulesForTestify(output as IndentedWriter, title as String)
		print '[title]:'
		output.indent
		try
			print to output
				i = 1
				for module in _modules
					print '[i]. ' stop
					if module.isCobraLibrary
						print to output, module
					else
						module.writeDeepString(output)
					i += 1
		finally
			output.dedent

	def _exitFromErrors
		require .errors.count
		.printMessages
		throw StopCompilation(this)

	def printMessages
		if .htmlWriter
			.printHtmlMessages
		else
			.printConsoleMessages
		Environment.exitCode = if(.errors.count, 1, 0)

	def printHtmlMessages
		require .htmlWriter
		dest = .htmlWriter to !
		dest.writeHtml('<table class=messages cellpadding=2 cellspacing=2>[dest.newLine]\n')
		dest.writeHtml('<tr class=headings> <td class=heading> File </td> <td class=heading> Line </td> <td class=heading> Type </td> <td class=heading> Message </td> </tr>\n')
		for msg in _messages
			msg.writeHtmlTo(dest)
		dest.writeHtml('</table>[dest.newLine]')
		if _errors.count
			dest.writeHtml('<span class=compilationFailed>[_compilationFailedMessage()]</span><br>\n')  # CC: axe ()s
		else
			dest.writeHtml('<span class=compilationSucceeded>Compilation succeeded - [_warnings.count] warning[if(_warnings.count==1,'','s')]</span><br>\n')

	def printConsoleMessages
		willColor = .options.boolValue('color')
		savedColor = Console.foregroundColor
		if CobraCore.isRunningOnMono  # bug on mono: the initial Console.foregroundColor is not necessarily accurate (at least in bash on Terminal.app on Mac OS X 10.4.10 on Mono 1.2.4)
			savedColor = ConsoleColor.Black  # this is really just a guess and possibly a bad one. should be controllable via a cmd line option or argument
		for obj in _messages
			if willColor and obj.isError
				Console.foregroundColor = ConsoleColor.Red
				restoreColor = true
			print obj.consoleString
			if restoreColor
				Console.foregroundColor = savedColor
				restoreColor = false
		if _errors.count
			if willColor
				Console.foregroundColor = ConsoleColor.Red
			print _compilationFailedMessage()  # CC: axe ()s
			if willColor
				Console.foregroundColor = savedColor
		else
			didPrint = false
			if willColor
				Console.foregroundColor = ConsoleColor.Blue
			if _willPrintSuccessMsg or _warnings.count
				print 'Compilation succeeded' stop
				didPrint = true
			if _warnings.count
				print ' - [_warnings.count] warning[if(_warnings.count==1,'','s')]'
			else
				if didPrint
					print
			if willColor
				Console.foregroundColor = savedColor

	def _compilationFailedMessage as String
		return 'Compilation failed - [_errors.count] error[if(_errors.count==1,'','s')], [_warnings.count] warning[if(_warnings.count==1,'','s')]'


	##
	## Source Code Corrections
	##

	var _sourceCorrections = Dictionary<of String, Dictionary<of int, List<of Replacement>>>()
		"""
		The first key of type String is filename.
		The second key of type int is line number.
		"""

	def correctSource(token as IToken, replace as String)
		if not _sourceCorrections.containsKey(token.fileName)
			_sourceCorrections[token.fileName] = Dictionary<of int, List<of Replacement>>()
		file = _sourceCorrections[token.fileName]
		if not file.containsKey(token.lineNum)
			file[token.lineNum] = List<of Replacement>()
		file[token.lineNum].add(Replacement(token.colNum, token.text, replace))

	def writeSourceCodeCorrections
		# TODO: this doesn't properly handle when the replacements are a different length than the
		# original next, but then this isn't needed right now since the only type of correction
		# being done is case correction
		if _sourceCorrections.count == 0, return
		v = .verbosity
		for fileName, lineToReplacements in _sourceCorrections
			if v, print 'Correcting source:', fileName
			lineNums = List<of int>(lineToReplacements.keys)
			lineNums.sort
			lines = File.readAllLines(fileName)
			for lineNum in lineNums
				for rep in lineToReplacements[lineNum]
					assert rep.oldText.length == rep.newText.length  # see TODO above
					if v >= 2, print 'Correct: Line [lineNum], Column [rep.colNum], Old "[rep.oldText]", New "[rep.newText]"'
					i = lineNum - 1
					line = lines[i]
					# print line
					oldLen = line.length
					col = rep.colNum - 1
					lines[i] = line[:col] + rep.newText + line[col+rep.oldText.length:]
					# print lines[i]
					assert lines[i].length == oldLen
			try
				File.writeAllLines(fileName, lines)
			catch exc as Exception
				.warning(CobraWarning(fileName, nil, 'Cannot write source code corrections due to: [exc.message] ([exc.getType.name]).'))
		_sourceCorrections.clear

	##
	## Important system library types
	##

	get objectType as IType
		# for ITypeProvider
		return _libraryClass('System.Object')

	def objectClass as Class
		# for stronger typing
		return _libraryClass('System.Object')

	def stringType as Class
		return _libraryClass('System.String')

	def exceptionType as Class
		return _libraryClass('System.Exception')

	def delegateType as Class
		return _libraryClass('System.Delegate')

	def attributeType as Box
		return _libraryBox('System.Attribute')

	def enumerableType as Box
		return _libraryBox('System.Collections.IEnumerable')

	def enumeratorType as Box
		return _libraryBox('System.Collections.IEnumerator')

	def enumerableOfType as Box
		return _libraryBox('System.Collections.Generic.IEnumerable<of>')

	def enumeratorOfType as Box
		return _libraryBox('System.Collections.Generic.IEnumerator<of>')

	def dictEnumeratorType as Box
		return _libraryBox('System.Collections.IDictionaryEnumerator')
		
	def collectionType as Box
		return _libraryBox('System.Collections.ICollection')

	def collectionOfType as Box
		return _libraryBox('System.Collections.Generic.ICollection<of>')

	def ilistType as Box
		return _libraryBox('System.Collections.IList')
		
	def ilistOfType as Box
		return _libraryBox('System.Collections.Generic.IList<of>')
		
	def listOfType as Class
		return _libraryClass('System.Collections.Generic.List<of>')

	def idictionaryType as Box
		return _libraryBox('System.Collections.IDictionary')
		
	def idictionaryOfType as Box
		return _libraryBox('System.Collections.Generic.IDictionary<of,>')

	def dictionaryOfType as Class
		return _libraryClass('System.Collections.Generic.Dictionary<of,>')

	def setOfType as Class
		return _libraryClass('Cobra.Lang.Set<of>')

	def libraryType(qualifiedName as String) as IType
		"""
		Implemented for ITypeProvider, but use the more specific methods such as .stringType instead.
		"""
		return _libraryType(qualifiedName)

	var _libraryTypeCache = Dictionary<of String, IType>()

	def _libraryType(qualifiedName as String) as IType
		"""
		Used to retrieve types such as System.String.
		Example:
			_libraryType('System.String')
		"""
		type as IType?
		if _libraryTypeCache.tryGetValue(qualifiedName, out type)
			return type to !
		names = qualifiedName.split(c'.')
		type = _libraryType(names to passthrough)
		_libraryTypeCache[qualifiedName] = type to !
		return type to !

	def _libraryType(names as vari String) as IType
		ns as IContainer = _globalNS
		thing as IContainer? = nil
		for name in names
			possible = (thing ? ns).declForName(name)
			assert possible, name
			if possible inherits IContainer
				thing = possible
			else
				assert false, [name, possible.getType.name, possible]
		if thing inherits IType
			if thing.name<>names[names.length-1] # TODO: add this as an ensure as well
				print 'names=' stop
				print CobraCore.toTechString(names)
				print 'thing=[thing]'
				assert false
			return thing
		else
			throw FallThroughException('found [name], but it is not an IType. it is [thing]')

	def _libraryBox(qualifiedName as String) as Box
		"""
		Returns a box from the standard library such as 'System.Object' or 'System.Collections.Generic.IEnumerable<of>'.
		"""
		return _libraryType(qualifiedName) to Box

	def _libraryClass(qualifiedName as String) as Class
		"""
		Returns a class from the standard library such as 'System.Object' or 'System.Collections.Generic.Dictionary<of,>'.
		"""
		return _libraryType(qualifiedName) to Class


	##
	## Services to nodes
	##

	def findLocal(name as String) as AbstractLocalVar?
		"""
		Finds a local parameter or variable in the current code member.
		"""
		require
			.isBindingImp
			.codeMemberStack.count
		body
			return .codeMemberStack.peek.findLocal(name)

	def nativeType(qualifiedName as String) as NativeType
		return ClrNativeType(_clrType(qualifiedName))

	def _clrType(qualifiedName as String) as System.Type
		# eventually this method will be key in targeting different versions of the CLR
		# suppose you are on .NET 3.0 and want to target .NET 2.0
		t as System.Type?
		_clrTypeCache.tryGetValue(qualifiedName, out t)
		if t is nil
			t = sharp'System.Type.GetType(qualifiedName)' # to System.Type
			_clrTypeCache[qualifiedName] = t to passthrough  # "to passthrough" instead of "to !" to avoid non-nil check
		return t to passthrough

	def suggestionFor(name as String) as String? is shared
		require name.length
		# CC: return _unknownSuggestions.getDefault(name, nil)
		if _unknownSuggestions.containsKey(name)
			return _unknownSuggestions[name]
		else if _unknownSuggestions.containsKey(name.toLower)
			return _unknownSuggestions[name.toLower]
		else
			return nil

	def warning(node as ISyntaxNode, msg as String)
		require msg.length
		.warning(CobraWarning(node.token, msg))

	def warning(cw as CobraWarning)
		require not cw.isError
		if _suppressWarning(cw), return
		_addMessage(cw)
	
	def _suppressWarning(cw as CobraWarning) as bool
		# TODO: add suppress all warnings (cmdline sw) - maybe?
		# TODO: add suppress by error tag - maybe?
		entry = if(cw.hasSourceSite, '[cw.fileName]:[cw.lineNum]', '')
		return _noWarningLines.contains(entry)
			
	def augmentWarning(node as ISyntaxNode, lookFor as String, search as String, augment as String) as bool
		require 
			lookFor.length
			augment.length
		body
			message = CobraWarning(node.token, lookFor)
			key = if(message.hasSourceSite, '[message.fileName]:[message.lineNum]', '')
			if not _messagesPerSourceLine.containsKey(key)
				return false
			lowerToMatch = message.message.toLower
			lowerSearch = if(search.length > 0, search.toLower, '')
			for se in _messagesPerSourceLine[key]
				lowerMsg = se.message.toLower
				if lowerMsg.contains(lowerToMatch)  # matched
					if search.length == 0 or lowerMsg.contains(lowerSearch)
						se.appendToMessage(augment)
						return true
			return false

	var _uniqueIdentifier as String?

	def uniqueIdentifier as String
		"""
		Returns a unique id such as '95b141d670c19f2f20a820751897b9c6' which is guaranteed to be
		unique per Compiler instance. Can be used in identifiers. Motivated by -embed-run-time
		option which suffixes the Cobra.Lang suffix to avoid collisions with other assemblies.
		"""
		if _uniqueIdentifier is nil
			components = [DateTime.now, this, Environment.currentDirectory, Process.getCurrentProcess.id]
			_uniqueIdentifier = components.toPrintString.md5HashInHex
		return _uniqueIdentifier to !

	def embedRunTimeSuffix as String
		if .options.boolValue('embed-run-time') and not .options.boolValue('build-standard-library')
			return '_ert_' + .uniqueIdentifier
		else
			return ''

	shared
		var _unknownSuggestions = {
		# literals
		'null':		'nil',
		'none':		'nil',
		'nothing':	'nil',
		'True':		'true',
		'False':	'false',

		# Python
		'self':		'this',
		'super':	'base',
		'elif':		'else if',

		# C#
		'using':	'use',
		'foreach':	'for',

		# VisualBasic
		'imports':	'use',
		'sub':		'def',

		# operators (word ones anyway)
		'isa':		'inherits',
		'new':		'SomeClass() or SomeClass(arg1,arg2) without new',

		# constructs
		#'lambda':	'def(args) ...',  # TODO

		# statements
		'do':		'post while <condition>',
		'elseif':	'else if',

		# types
		'boolean':		'bool',
		'character':	'char',
		'byte':			'uint8',
		'sbyte':		'int8',
		'short':		'int16',
		'ushort':		'uint16',
		'integer':		'int',
		'long':			'int64',
		'ulong':		'uint64',
		'single':		'float32',
		'double':		'float',
		'str':			'String',
		'string':		'String',
		'object':		'Object',
		}

	get unknownSuggestions from var

	def suggestionForUnknown(word as String) as String?
		if _unknownSuggestions.tryGetValue(word, out word), return word
		else, return nil


	##
	## Services to this
	##

	def _addMessage(message as SourceException)
		# Cobra can sometimes generate duplicate messages. Specifically, a constructed type might generate a message that its generic def did.
		# Also, assert statements whose conditions cause C# warnings will get duplicate warnings because of the expression breakdown.
		# Yeah, ideally, this would be fixed, but sometimes that's harder than just removing the duplicates:
		key = if(message.hasSourceSite, '[message.fileName]:[message.lineNum]', '')
		if _messagesPerSourceLine.containsKey(key)
			for se in _messagesPerSourceLine[key]
				if se.message.toLower == message.message.toLower
					if Utils.isDevMachine or .verbosity >= 3
						print 'Skipping duplicate message:', message.consoleString
					return
		else
			_messagesPerSourceLine[key] = List<of SourceException>()
		_messagesPerSourceLine[key].add(message)
		_messages.add(message)
		if message.isError
			_errors.add(message)
		else
			_warnings.add(message)

	def _initBackEnd
		require .backEnd is nil
		ensure .backEnd
		branch .options.get('back-end')
			on 'none', _backEnd = ClrBackEnd(this)  # TODO-SELFHOST
			on 'clr',  _backEnd = ClrBackEnd(this)
			on 'jvm',  _backEnd = JvmBackEnd(this)
			else, throw FallThroughException(.options.get('back-end'))


class InternalError
	inherits SourceException
	"""
	Represents cases where the Cobra compiler itself has experienced an internal exception.
	"""

	var _fileName as String?
	var _lineNum as int?
	var _internalException as Exception

	cue init(fileName as String, lineNum as int, message as String, internalException as Exception)
		.init(message, internalException)
		_fileName = fileName
		_lineNum = lineNum

	cue init(message as String, internalException as Exception)
		base.init(('COBRA INTERNAL ERROR / ' + internalException.getType.name + ' / ' + message.replace('\r','').replace('\n','; ').trim)[:1024])
		_internalException = internalException

	get isError as bool is override
		return true

	get hasSourceSite as bool is override
		return _fileName is not nil

	get fileName as String is override
		return _fileName to !

	get lineNum as int is override
		return _lineNum to !


class SharpCompilationMessage
	inherits SourceException

	test
		line = r"c:\Documents and Settings\Chuck\My Documents\Projects\Cobra\Workspace-New\Tests\tests\720-libraries\200-tao.cobra(11,4): error CS0246: The type or namespace name 'SDL_Event' could not be found (are you missing a using directive or an assembly reference?)"
		msg = SharpCompilationMessage(line, TestCompiler())
		assert 'error ' in line
		assert msg.isError
		assert msg.hasSourceSite
		assert 'tao.cobra' in msg.fileName and 'Documents' in msg.fileName
		assert msg.lineNum == 11

		line = "foo.cobra.cs(14,14): error CS0535: `Foo' does not implement interface member `IFoo.Baz()'"
		msg = SharpCompilationMessage(line, TestCompiler())
		assert msg.isError
		assert msg.hasSourceSite
		assert msg.fileName == 'foo.cobra'
		assert msg.lineNum == 14
		
		line = "error CS5001: Program `bugs/bugs-no-main.exe' does not contain a static `Main' method suitable for an entry point"
		msg = SharpCompilationMessage(line, TestCompiler())
		assert msg.isError
		assert not msg.hasSourceSite
		
		line = "foo.cobra(15,3): warning CS1111: Blah blah"
		msg = SharpCompilationMessage(line, TestCompiler())
		assert not msg.isError
		assert msg.hasSourceSite
		assert msg.fileName == 'foo.cobra'
		assert msg.lineNum == 15
		assert msg.message == 'Blah blah' or msg.message == 'Blah blah (C#)'

	def willSkipMessage(msg as String) as bool is shared
		# TODO: Does mono give localized messages? Like in French.
		if '.dll' in msg
			# comes up on Novell Mono: '/Library/Frameworks/Mono.framework/Versions/1.2.4/lib/mono/2.0/mscorlib.dll (Location of the symbol related to previous error)'
			# TODO: try removing these
			if msg.endsWith(' (Location of the symbol related to previous error)')
				return true
			if msg.endsWith(' (Location of the symbol related to previous warning)')
				return true
		if msg.startsWith('Compilation succeeded')
			# Novell Mono gmcs ends with this. Cobra handles this itself.
			return true
		if msg.startsWith('Compilation failed')
			# Novell Mono gmcs ends with this. Cobra handles this itself.
			return true
		return false

	var _fileName as String?
	var _lineNum as int?
	var _isError as bool

	cue init(message as System.CodeDom.Compiler.CompilerError, compiler as Compiler)
		base.init('')
		_isError = not message.isWarning
		_fileName = message.fileName
		_lineNum = message.line
		text = message.errorText ? ''
		if compiler.verbosity or Utils.isDevMachine
			text += ' (C#)'  # ' (C# [sharpLineNum])' ... the sharpLineNum is not useful now that #line is being generated
		_message = _cleanUp(text)

	cue init(line as String, compiler as Compiler)
		require not .willSkipMessage(line)
# CC:
#		require compiler responds to (get verbosity as int)
#		require compiler responds to (def cobraLineNumForSharp(fileName as String, lineNum as int) as int)
		base.init(line)

		#   example lines:
		# foo.cobra.cs(14,14): error CS0535: `Foo' does not implement interface member `IFoo.Baz()'
		# error CS5001: Program `bugs/bugs-no-main.exe' does not contain a static `Main' method suitable for an entry point
		# foo(30,30):

		# trace line
		line = line.trim
		_isError = 'error ' in line
		if line.startsWith('error CS')
			i = line.indexOf(': ')
			line = line[i+2:]
		else
			i = line.indexOf('(')
			if i <> -1
				fileName = line[:i]
				if fileName.endsWith('.cs') and fileName.endsWith('.cobra.cs') # doesn't really happen since #line is generated at the top to set the filename to "Foo.cobra"
					fileName = fileName[:i-3]
					willFixLineNum = true
				else
					willFixLineNum = false
				j1 = line.indexOf(',', i)
				j2 = line.indexOf(')', i)
				j = if(j1 < j2, j1, j2)
				lineStr = line[i+1:j]
				try
					_lineNum = int.parse(lineStr)
				catch
					if compiler.verbosity or Utils.isDevMachine
						line += ' (C#)'
				success
					_fileName = fileName
					if willFixLineNum
						_lineNum = compiler.cobraLineNumForSharp(fileName, _lineNum to !)
					i = line.indexOf(':', i)
					if i <> -1
						line = line[i+1:].trim
						_isError = line.startsWith('error')
						i = line.indexOf(':')
						if i <> -1 and i < line.length and i+1 < line.length and line[i+1] == ' '
							line = line[i+1:].trim
					# add (sharp)
					if compiler.verbosity or Utils.isDevMachine
						line += ' (C#)'  # ' (C# [sharpLineNum])' ... the sharpLineNum is not useful now that #line is being generated
		_message = _cleanUp(line)

	def _cleanUp(line as String) as String
		line = line.replace("`double'", "`float'")
		line = line.replace("null", "nil")
		# change C#'s `funky' quotes to double quotes
		line = line.replace("`", '"')
		line = line.replace("'", '"')
		return line

	get isError as bool is override
		return _isError

	get hasSourceSite as bool is override
		return _fileName is not nil

	get fileName as String is override
		return _fileName to !

	get lineNum as int is override
		return _lineNum to !


class Replacement

	cue init(colNum as int, oldText as String, newText as String)
		_colNum = colNum
		_oldText = oldText
		_newText = newText
	
	get colNum from var as int
	
	get oldText from var as String
	
	get newText from var as String


class TestCompiler
	inherits Compiler
	"""
	Used by SharpCompilationMessage.test
	CC: should be inside the test or easy to remove via a test attribute
	"""

	cue init
		base.init(0)

	get verbosity as int is override
		return 0
	
	def cobraLineNumForSharp(fileName as String, lineNum as int) as int is override
		return lineNum
