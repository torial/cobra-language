"""
This module contains BoxMember on down, except Property and Indexer which have their own files.
"""

interface IBoxMember
	inherits IMember
	"""
	Anything that can be a member of a box should implement IBoxMember.
	This includes methods, properties, enums and more.
	It even includes Box as nested boxes are an anticipated feature.
	"""
	get docString as String?
	get parentBox as Box
	def mergedIntoPartialBox(newBox as Box)
		require
			newBox is not .parentBox
			newBox.name == .parentBox.name


class BoxMember
	is abstract, partial
	inherits NamedNode
	implements IBoxMember

	shared
		var _accessLevels = ['public', 'protected', 'internal', 'protected internal', 'private']
			"""
			The access level names are the same in both Cobra and C#.
			"""

	var _parentBox as Box
	var _docString as String?
	var _isNames as List<of String>?
	var _attribs as AttributeList
	var _overloadGroup as MemberOverload?
	var _testMethod as TestMethod?
	var _matchingBaseMember as BoxMember?
	var _sharedMethodBacking as String?
	var _sharedMethodBackingIsAlias as bool
	var _binaryName as String?

	def init(token as IToken, parentBox as Box, name as String, isNames as List<of String>, attribs as AttributeList)
		.init(token, parentBox, name, isNames, attribs, nil)

	def init(token as IToken, parentBox as Box, name as String, isNames as List<of String>, attribs as AttributeList, docString as String?)
		base.init(token, name)
		_isNames = isNames
		_attribs = attribs
		_parentBox = parentBox
		_docString = docString

	## Properties

	get attributes from _attribs

	get parentBox from var

	get canHaveMatchingBaseMember as bool
		"""
		Used by .computeMatchingBaseMember to skip over members that cannot have base members.
		Typically, explicit interface implementations like 'ICollection.IsSynchronized'
		"""
		return '.' not in _name

	pro binaryName from var
		"""
		If this BoxMember was scanned from an assembly (usually a DLL), this property holds the assembly-based name.
		For example, you might say "writeLine" in Cobra, but the binary name is probably "WriteLine" and *could be* "writeLine".
		"""

	pro docString from var

	pro isNames from var

	pro overloadGroup from var

	pro sharedMethodBacking from var

	pro sharedMethodBackingIsAlias from var

	pro testMethod from var

	get isAbstract as bool
		return 'abstract' in _isNames

	get isCallable as bool
		return false

	get isInternal as bool
		return 'internal' in _isNames

	get isOverride as bool
		return 'override' in _isNames

	get isProtected as bool
		return 'protected' in _isNames

	get isPrivate as bool
		return 'private' in _isNames

	get isPublic as bool
		return 'public' in _isNames

	get isShared as bool
		return 'shared' in _isNames

	pro isUsed as bool
		get
			return base.isUsed
		set
			base.isUsed = value
			.resultType.isUsed = true

	get englishName as String is abstract

	get defaultAccessLevel as String
		if .isInterfaceMember and not .isExtensionMember
			return ''
		if .name.startsWith('__')
			return 'private'
		if .name.startsWith('_')
			return if(.isStructMember, 'private', 'protected')
		return 'public'

	get hasVariParams as bool
		"""
		Retuns true if the class member takes variable number of arguments.
		"""
		return false

	get hasParams as bool
		"""
		Returns true if the class member has one or more parameters defined.
		"""
		return .params.count > 0

	get params as List<of Param>
		"""
		Returns the list of params of this method, possibly empty.
		Checking hasParams first is recommended since it's more efficient.
		"""
		return List<of Param>()

	get isClassMember as bool
		return _parentBox inherits Class or (_parentBox inherits Extension and (_parentBox to Extension).extendedBox inherits Class)

	get isInterfaceMember as bool
		return _parentBox inherits Interface or (_parentBox inherits Extension and (_parentBox to Extension).extendedBox inherits Interface)

	get isStructMember as bool
		return _parentBox inherits Struct or (_parentBox inherits Extension and (_parentBox to Extension).extendedBox inherits Struct)

	get isExtensionMember as bool
		return _parentBox inherits Extension

	pro matchingBaseMember as BoxMember?
		get
			ensure result is not this
			return _matchingBaseMember
		set
			_matchingBaseMember = value 

	pro parentNameSpace as NameSpace?
		get
			return nil
		set
			throw NotSupportedException()

	get requiresThis as bool
		return not _name.startsWith('_')

	get resultType as IType is abstract
		"""
		The result type of the var, method or property.
		"""

	get shouldBeVirtual as bool
		return false


	## Other

	def unNilReturnType
		"""
		Subclasses should override to change their "return type node" to non-nilable.
		No need to invoke `base`.
		This is invoked to fix up the CLR library which does not indicate, for example, that StringBuilder.toString returns String not String?
		"""
		pass

	def mergedIntoPartialBox(newBox as Box)
		require
			newBox is not .parentBox
			newBox.name == .parentBox.name
		body
			_parentBox = newBox


	## INamedNode

	get typeForIdentifier as IType is override
		return .resultType

	get typeForReceiver as IType is override
		return .resultType


	## Binding

	def _bindInt is override
		base._bindInt
		isNames = Set<of String>()
		for name in _isNames
			if name in isNames
				.compiler.warning(this, 'Duplicate modifier "[name]". You can remove it.')
			isNames.add(name)
		_isNames = List<of String>(isNames)
		if .defaultAccessLevel.length
			# CC: if not find level in _accessLevel where level in _isNames
			found = false
			for level in _accessLevels
				if level in _isNames
					found = true
					break
			if not found
				_isNames.insert(0, .defaultAccessLevel)
		if .shouldBeVirtual
			found = false
			for name in ['nonvirtual', 'virtual', 'shared', 'override', 'abstract']
				if name in _isNames
					found = true
			if not found
				_isNames.add('virtual')
		for attrib in _attribs
			attrib.bindInt
		if _testMethod
			_testMethod.bindInt

	def bindImp as dynamic
		assert not .parentBox.isConstructed
		return base.bindImp
			
	def _bindImp is override
		base._bindImp
		assert .didBindInt  # class members should have always received a bindInt first
		assert not .parentBox.isConstructed  # not expecting to bindImp on a constructed type
		for attrib in _attribs, attrib.bindImp
		if _testMethod, _testMethod.bindImp

	def usesBase
		# Needed by AbstractMethod and ProperDexer
		if 'new' in _isNames or 'override' in _isNames
			return
		# using base implies override, but only if the method sig in the base class is the same
		# (otherwise it's just an overload)
		if (parentBox = .parentBox) inherits Class
			assert parentBox.baseClass
			# Why not use .matchingBaseMember? Because currently that's only method-to-method. Does not work for properties.
			baseMember = parentBox.baseClass.memberForName(_name)
			if baseMember inherits BoxMember
				if baseMember inherits MemberOverload
					for member in baseMember.members
						if .matchesSignature(member)
							baseMember = member
							break
				if .matchesSignature(baseMember)
					if 'nonvirtual' in baseMember.isNames
						_isNames.add('new')
					else
						_isNames.add('override')
					_isNames.remove('virtual')  # virtual is the default for properties and methods

	def matchesSignature(member as BoxMember) as bool
		if .name <> member.name
			return false
		params = .params
		otherParams = member.params
		if params.count <> otherParams.count
			return false
		for i = 0 .. params.count
			if params[i].type <> otherParams[i].type
				return false
		return true


	## Fields

	def addMinFields is override
		base.addMinFields
		.addField('name', _name)
		.addField('isNames', _isNames)

	def addRefFields is override
		base.addRefFields
		.addField('parentBox', .parentBox)

	def addSubFields is override
		base.addSubFields
		if _isNames.count
			.addField('isNames', _isNames)
		.addField('docString', _docString)


	## Generics
	
	def constructedFor(box as Box, gpToType as Dictionary<of GenericParam, IType>) as BoxMember  # CC: as same
		require .didBindInt
		newMember = .memberwiseClone to BoxMember
		newMember._parentBox = box
		newMember._overloadGroup = nil
		return newMember


class BoxEvent
	is partial
	inherits BoxMember
	
	var _handlerType as IType?
	var _handlerTypeProxy as ITypeProxy?

	def init(token as IToken, box as Box, name as String, isNames as List<of String>, attribs as AttributeList, docString as String?, handlerType as ITypeProxy)
		base.init(token, box, name, isNames, attribs, docString)
		_handlerTypeProxy = handlerType

	get englishName as String is override
		return 'event'

	get handlerType from var
		"""
		Returns the underlying handler type for the event.
		"""
	
	get handlerTypeProxy from var

	get isCallable as bool is override
		return true

	get params as List<of Param> is override
		assert .didBindInt
		if _handlerType inherits MethodSig
			return _handlerType.params
		else if _handlerType inherits Class
			method = _handlerType.memberForName('invoke')
			if method inherits AbstractMethod
				return method.params
			else
				.compiler.warning(this, 'Cannot locate a single invoke method of "[_handlerType.name]".')
				return List<of Param>()			
		else
			if not .hasError
				.compiler.warning(this, 'Cannot determine parameters of event "[.name]".')
			return List<of Param>()			

	get resultType as IType is override
		return .handlerType to !

	def addSubFields
		base.addSubFields
		.addField('handlerType', _handlerType)
		.addField('handlerTypeProxy', _handlerTypeProxy)

	def _bindInt
		base._bindInt
		if not _handlerType
			_handlerType = _handlerTypeProxy.realType
		# TODO: error check that _handlerType is a delegate
		# _handlerType.isDescendantOf(.compiler.libraryType('System.Delegate'))


class BoxVar
	is partial
	inherits BoxMember
	implements IVar
	"""
	A BoxVar is a variable declared for a box, whether instance or shared. For example:
		var _x as int is shared

	Classes and structs can have vars, but interfaces cannot.
	
	In CLI terminology, these are called "fields".
	"""

	var _typeNode as ITypeProxy?
	var _type as IType?
	var _initExpr as Expr?
	var _ifInheritsStack as Stack<of IType>
	var _isAssignedTo as bool

	def init(token as IToken, box as Box, name as String, typeNode as ITypeProxy?, isNames as List<of String>, initExpr as Expr?, attribs as AttributeList?, docString as String)
		base.init(token, box, name, isNames, attribs ? AttributeList(), docString)
		_typeNode = typeNode
		_initExpr = initExpr
		_ifInheritsStack = Stack<of IType>()
		_useSharpNameStack = Stack<of String>()  # for if-inherits
		_useSharpNameStack.push(name)

	def addRefFields is override
		base.addRefFields
		if _type
			.addField('type', _type)
		else
			.addField('typeNode', _typeNode)

	def addSubFields is override
		base.addSubFields
		.addField('initExpr', _initExpr)

	get englishName as String is override
		return 'variable member'

	pro isAssignedTo from var

	pro ifInheritsStack from var

	get requiresDotPrefix as bool
		return not _name.startsWith('_')

	def attemptAssignmentOf(type as IType) as bool
		# TODO: dup'ed with AbstractLocalVar
		if _ifInheritsStack.count == 0
			return false
		stack = Stack<of IType>(Stack<of IType>(_ifInheritsStack))
		assert stack.peek == _ifInheritsStack.peek
		count = 0
		post while stack.count and not type.isAssignableTo(stack.peek)
			stack.pop
			count += 1
		if count or type.isAssignableTo(_type to !)
			_ifInheritsStack = stack
			# tell each IfStmt not to pop the if-inherits stack since the assignment did so
			for node in .compiler.nodeStack
				if node inherits IfStmt
					if node.ifInheritsVar is this
						node.doNotPopIfInheritsStack
						count -= 1
						if count == 0
							break						
			return true
		else
			return false

	def _bindInt is override
		base._bindInt
		assert _typeNode or _initExpr
		if _type is nil and _typeNode
			_type = _typeNode.realType
		if _initExpr
			_initExpr.bindImp  # that's bindImp intentionally
			if _type is nil
				_type = _initExpr.type
			else if not _initExpr.isKindOf(_type to !)
				.throwError('The expression type of [_initExpr.type.name] does not match the variable type of [_type.name].')

	get resultType as IType is override
		"""
		The result type of the var, method or property.
		"""
		t = .type
		if t, return t
		else, throw FallThroughException('_type is nil. this=[this]')

	def constructedFor(box as Box, gpToType as Dictionary<of GenericParam, IType>) as BoxMember  # CC: as same
		assert .type
		newMember = base.constructedFor(box, gpToType) to BoxVar  # CC: this = base. ...
		assert newMember._type
		newMember._type = newMember._type.secondaryConstructedTypeFor(box, gpToType)
		return newMember

	## INamedNode

	get typeForReceiver as IType is override
		return if(_ifInheritsStack.count, _ifInheritsStack.peek, .resultType)

	## IVar

	pro type as IType?
		get
			require _type
			return if(_ifInheritsStack.count, _ifInheritsStack.peek, _type)
		set
			assert false, 'Cannot set the type of a ClassVar.'


class AbstractMethod
	is abstract, partial
	inherits BoxMember
	"""
	The abstract ancestor class for
		Initializer
		Method
		PropertyXetter

	But not for Property (which has two code blocks "get" and "set"),
	or other class decls like variables.

	Subclasses must set _params.
	"""

	var _returnTypeNode as ITypeProxy?
	var _returnType as IType?
	var _requirePart as RequirePart?
	var _ensurePart as EnsurePart?
	var _oldExprs as List<of OldExpr>
	var _params as List<of Param>
	var _locals as List<of LocalVar>
	var _stmts as List<of Stmt>
	var _hasReturnStmt as bool
	var _hasThrowStmt as bool
	var _hasYieldStmt as bool
	var _curStmtIndex as int  # to implement .replaceChild
	var _isCompilerGenerated as bool

	def init(token as IToken, box as Box, name as String, paramsList as List<of Param>, isNames as List<of String>, attribs as AttributeList, docString as String)
		base.init(token, box, name, isNames, attribs, docString)
		_params = paramsList
		_oldExprs = List<of OldExpr>()
		_locals = List<of LocalVar>()
		_stmts = List<of Stmt>()

	get params as List<of Param> is override
		return _params

	get locals from var

	get isCallable as bool is override
		return true

	pro hasReturnStmt from var

	pro hasThrowStmt from var

	pro hasYieldStmt from var

	pro isCompilerGenerated from var

	def addStmt(stmt as Stmt)
		_stmts.add(stmt)

	pro requirePart from var

	pro ensurePart from var

	get resultType as IType is override
		or require
			.didBindInt
			_returnType
		body
			return _returnType to !

	get statements from _stmts

	def findLocal(name as String) as AbstractLocalVar?
		# TODO: should this use a dictionary lookup?
		for local in _locals, if local.name==name, return local
		for param in _params, if param.name==name, return param
		return nil

	def findLocalCI(name as String) as AbstractLocalVar?
		name = name.toLower
		# TODO: should this use a dictionary lookup?
		for local in _locals, if local.name.toLower==name, return local
		for param in _params, if param.name.toLower==name, 	return param
		return nil

	def addLocal(local as LocalVar)
		require
			.findLocal(local.name) is nil
		body
			other = .findLocalCI(local.name)
			if other
				.throwError('Parameters and locals must vary by more than just their case. Change "[local.name]" or "[other.name]" to match, or rename one of them to something different.')
			local.isTracked = true
			_locals.add(local)
	
	def replaceLocal(local as LocalVar)
		"""
		A utility method for EnsurePart to slip in the `result`.
		"""
		require
			.findLocal(local.name)
		body
			_locals.remove(.findLocal(local.name) to LocalVar)
			_locals.add(local)

	def removeLocal(name as String)
		require
			name.length
			.findLocal(name)
		body
			for i = 0 .. _locals.count
				if _locals[i].name==name
					_locals.removeAt(i)
					break

	def addOldExpr(oldExpr as OldExpr)
		_oldExprs.add(oldExpr)
		oldExpr.sharpVarName = '_lh_old_' + _oldExprs.count.toString

	get oldExprs from var
		"""
		Use .addOldExpr(e) instead of method.oldExprs.add().
		"""

	def unNilReturnType is override
		assert _returnType is nil
		if _returnTypeNode inherits NilableTypeProxy
			_returnTypeNode = _returnTypeNode.innerTypeProxy
		
	def addRefFields is override
		base.addRefFields
		.addField('returnTypeNode', _returnTypeNode)
		.addField('returnType', _returnType)

	def addSubFields is override
		base.addSubFields
		.addField('params', _params)
		.addField('requirePart', _requirePart)
		.addField('ensurePart', _ensurePart)
		.addField('locals', _locals)
		.addField('stmts', _stmts)

	def cobraSourceSignature as String
		return .cobraSourceSignature(true)

	def cobraSourceSignature(includeShared as bool) as String
		sb = StringBuilder('def [.name]')
		if .params.count > 0
			sb.append('(')
			sep = ''
			for param in .params
				sb.append('[sep][param.name] as ')
				branch param.kind
					on Param.KindEnum.Value, pass
					on Param.KindEnum.InOut, sb.append('inout ')
					on Param.KindEnum.Out, sb.append('out ')
				sb.append('[param.type.name]')
				sep = ', '
			sb.append(')')
		if not .resultType inherits VoidType
			sb.append(' as [.resultType.name]')
			if includeShared and .isShared
				# TODO: other is names
				sb.append(' is shared')
		return sb.toString

	get canHaveDetailedStackTrace as bool
		return .parentBox.canHaveDetailedStackTrace and not .hasYieldStmt

	get willRequire as bool
		# in the future, this will also depend on a command line option to include/exclude preconditions
		# classes that are sensitive with respect to the DST skip on contracts
		return .canHaveDetailedStackTrace

	get willEnsure as bool
		# in the future, this will also depend on a command line option to include/exclude preconditions
		return .canHaveDetailedStackTrace

	def replaceChild(find as INode, replace as INode) as bool
		if _curStmtIndex < _stmts.count and _stmts[_curStmtIndex] is find
			_stmts[_curStmtIndex] = replace to Stmt
			return true
		else
			return base.replaceChild(find, replace)

	def _bindInt is override
		base._bindInt
		.compiler.codeMemberStack.push(this)
		try
			assert .parentBox.didUnNilReturnTypes
			for param in _params
				param.bindInt
			if _returnType is nil
				if _returnTypeNode
					_returnType = _returnTypeNode.realType
				else
					_returnType = .compiler.voidType
				assert _returnType, _returnTypeNode
			if _requirePart is nil and .willRequire
				_requirePart = RequirePart(this)
			if _requirePart
				_requirePart.bindInt
			if _ensurePart is nil and .willEnsure
				_ensurePart = EnsurePart(this)
			if _ensurePart
				_ensurePart.bindInt
		finally
			.compiler.codeMemberStack.pop

	def _bindImp is override
		base._bindImp
		.compiler.codeMemberStack.push(this)
		try
			.computeMatchingBaseMember  # cannot currently go in .bindInt because it uses .memberForName which triggers other things like generic construction completion
			if .matchingBaseMember and 'override' in .isNames and 'private' in .matchingBaseMember.isNames
				.recordError('Cannot override the base member which is declared "private".')
			for param in _params
				param.bindImp
			for local in _locals
				local.bindImp
			if _requirePart
				_requirePart.bindImp
			if _ensurePart and _returnType and _returnType is not .compiler.voidType
				_sharpResultVarName = '_lh_result'
			else
				_sharpResultVarName = ''
			_curStmtIndex = 0
			for stmt in _stmts.toArray
				try
					stmt.bindImp
					stmt.afterStatementBindImp  # to let expressions know when they are used as statements
				catch ne as NodeException
					.compiler.recordError(ne)
				_curStmtIndex += 1
			for param in _params
				assert param.ifInheritsStack.count == 0
			if _ensurePart
				_ensurePart.bindImp
			if _requirePart
				_requirePart.checkConnectToken
			if _ensurePart
				_ensurePart.checkConnectToken
			.checkForUnmarkedOverrideOrNew  # have to do this after statements bindImp since using base can add `override`
			.checkForUnusedVariables
		finally
			.compiler.codeMemberStack.pop

	var _didComputeMatchingBaseMember = true
	
	get didComputeMatchingBaseMember from var

	def computeMatchingBaseMember
		ensure .matchingBaseMember is not this
		_didComputeMatchingBaseMember = true
		if _matchingBaseMember, return
		if not .canHaveMatchingBaseMember, return
		if (parentBox = .parentBox) inherits Class
			if parentBox.baseClass
				baseMember = parentBox.baseClass.memberForName(_name)
				if baseMember is nil
					pass
				else if baseMember inherits AbstractMethod
					if .matchesSignature(baseMember)
						_matchingBaseMember = baseMember
				else if baseMember inherits MemberOverload
					if baseMember.members[0] inherits AbstractMethod
						for member in baseMember.members
							if .matchesSignature(member)
								_matchingBaseMember = member
					else
						cannotRedeclare = true
				else
					cannotRedeclare = true
				if cannotRedeclare
					# TODO: FIXME: the message uses .englishName twice. one of them needs to change
					.recordError('Cannot declare a [.englishName] named "[.name]" because the base member "[.name]" is a [.englishName]. this=[.getType.name], baseMember=[baseMember.getType.name]')
				if _matchingBaseMember and _matchingBaseMember.parentBox inherits Interface
					# not really a base member in the "base class" sense of the word.
					# would not require marking as "is override" for example
					_matchingBaseMember = nil

	def checkForUnmarkedOverrideOrNew
		require .didComputeMatchingBaseMember
		if 'new' not in .isNames and 'override' not in .isNames and _matchingBaseMember and not _matchingBaseMember.isExtensionMember
			.throwError('Member "[_name]" also exists in the base class. You must specify "is override" or "is new", or change the name.')

	def checkForUnusedVariables
		for local in _locals
			if not local.isUsed
				.compiler.warning(local, 'The value of variable "[local.name]" is never used.')


	## Generics

	def constructedFor(box as Box, gpToType as Dictionary<of GenericParam, IType>) as BoxMember  # CC: as same
		newMember = base.constructedFor(box, gpToType) to AbstractMethod  # CC: this = base. ...
		assert newMember._returnType
		newMember._returnType = newMember._returnType.secondaryConstructedTypeFor(box, gpToType)
		newMember._params = for p in _params get p.constructedFor(box, gpToType)
		return newMember


class Initializer
	is partial
	inherits AbstractMethod

	def init(token as IToken, box as Box, paramsList as List<of Param>, isNames as List<of String>, attribs as AttributeList, docString as String)
		base.init(token, box, 'init', paramsList, isNames, attribs, docString)
		_isNames = isNames
		_stmts = List<of Stmt>()

	get englishName as String is override
		return 'initializer'

	get hasVariArgs as bool
		assert false, 'TODO: complete Initializer.hasVariArgs'
		return false

	get isCallable as bool is override
		return true

	get isMethod as bool is override
		return true  # because this is needed for "base.init" without ()s

	def usesBase is override
		# initializers cannot be virtual and don't require "is new"
		pass

	def checkForUnmarkedOverrideOrNew is override
		# initializers don't say override or new
		pass

	get lastToken as IToken
		if _stmts.count
			return _stmts[_stmts.count-1].lastToken  # CC: use .last
		else
			return .token

	def _bindImp
		if .canHaveDetailedStackTrace  # no extra checks for classes that are sensitive with respect to the DST
			# add asserts at the end for non-nilable class vars
			if .compiler.options.boolValue('include-nil-checks')
				token = .lastToken.copy
				token.incLineNum
				stmts = List<of Stmt>()
				for decl in .parentBox.declsInOrder
					if decl inherits BoxVar
						assert decl.type
						if not decl.type inherits NilableType and decl.type.isReference and not decl.isShared
							if decl.name.startsWith('_')
								expr = IdentifierExpr(token, decl) to Expr
							else
								expr = BinaryOpExpr.make(token, 'DOT', ThisLit(token), MemberExpr(token, decl.name)) to Expr
							stmts.add(AssertStmt(token, IsNotNilExpr(token, expr), nil))
				if stmts.count
					cond = BinaryOpExpr.make( _
						.lastToken.copy('DOT', '.'), 'DOT', _
						IdentifierExpr(.lastToken.copy('ID', 'CobraCore')), _
						MemberExpr(.lastToken.copy('ID', '_willCheckNil')))
	
					block = BlockStmt(token, stmts)
	
					ifStmt = IfStmt(token, cond, block, nil)
	
					.addStmt(ifStmt)

		base._bindImp

		first = true
		for stmt in _stmts
			if not first
				if stmt inherits DotExpr
					if stmt.left inherits BaseLit
						# TODO: after switching to byte code gen, it would be nice to relax this a bit, by say allowing statements that use args and locals, but can't set class state by, for example, setting class vars or calling members
						stmt.recordError('The base initializer can only be invoked in the first statement.')
					else if stmt.left inherits ThisLit and ((stmt.right inherits MemberExpr and (stmt.right to MemberExpr).name == 'init') or (stmt.right inherits CallExpr and (stmt.right to CallExpr).name == 'init'))  # CC: axe casts
						stmt.recordError('Another initializer can only be invoked in the first statement.')
			first = false
				

class Method
	is partial
	inherits AbstractMethod

	var _implementsTypeNode as ITypeProxy?
	var _implementsType as IType?

	def init(token as IToken, box as Box, name as String, paramsList as List<of Param>, returnTypeNode as ITypeProxy, implementsTypeNode as ITypeProxy?, isNames as List<of String>, attribs as AttributeList, docString as String)
		.init(token, box, name, List<of IType>(), paramsList, returnTypeNode, implementsTypeNode, isNames, attribs, docString)

	def init(token as IToken, box as Box, name as String, genericParams as List<of IType>, paramsList as List<of Param>, returnTypeNode as ITypeProxy, implementsTypeNode as ITypeProxy?, isNames as List<of String>, attribs as AttributeList, docString as String)
		base.init(token, box, name, paramsList, isNames, attribs, docString)
		_genericParams = genericParams
		_returnTypeNode = returnTypeNode
		_implementsTypeNode = implementsTypeNode
		if 'virtual' in _isNames and _implementsTypeNode
			_isNames.remove('virtual')
		_stmts = List<of Stmt>()

	get englishName as String is override
		return 'method'

	get hasVariArgs as bool
		assert false, 'TODO: complete Method.hasVariArgs'
		return false

	get isCallable as bool is override
		return true

	get isMain as bool
		return .name == 'main' and .isShared

	get isMethod as bool is override
		return true

	get implementsType from var

	get shouldBeVirtual as bool is override
		return .isClassMember and not _implementsTypeNode and not _implementsType

	def addRefFields is override
		base.addRefFields
		.addField('implementsType', _implementsType)

	def addSubFields is override
		base.addSubFields
		.addField('genericParams', _genericParams)
		if _implementsTypeNode
			.addField('implementsTypeNode', _implementsTypeNode)

	get defaultAccessLevel as String is override
		dal = base.defaultAccessLevel
		if dal.length and not _implementsType and not _implementsTypeNode
			return dal
		else
			return ''


	## Generics

	var _genericParams as List<of IType>
	var _genericDef as Method?  # non-nil for a method constructed from a generic method
	var _constructions as Dictionary<of String, Method>?

	get genericDef from var

	get genericParams from var

	get isConstructed as bool
		return _genericDef is not nil

	get isGenericDef as bool
		"""
		Returns true if this type is a definition of a generic type, and
		therefore capable of making subsequent generic types via the
		`constructedTypeFor` method. A generic type will have generic
		parameters which are all GenericParam (as opposed to other types
		such as `int` or a given class).
		"""
		# TODO: make this more efficient, maybe by computing in the initializer
		if .genericDef or .genericParams.count == 0
			return false
		else if .genericParams.count
			for param in .genericParams
				if not param inherits GenericParam
					return false
			return true
		else
			return false

	get containsGenericParameters as bool
		for param in .genericParams
			if param inherits GenericParam
				return true
			if param inherits Box  # CC: and <next if condition>
				if param.containsGenericParameters
					return true
		return false

	def constructedMethodWith(typeArgs as List<of IType>) as Method
		"""
		This is for methods that are generic themselves due to having their own generic parameters.
		For methods that simply belong to a generic class, see .constructedFor.
		
		TODO: Consider the case of a method that implements a specific interface. Can that have generic parameters?
		"""
		require
			.didBindInt
			.isGenericDef
			.containsGenericParameters
			typeArgs.count == .genericParams.count
		ensure
			typeArgs <> .genericParams implies this is not result
			result.genericParams == typeArgs
		body
			if typeArgs == _genericParams
				return this

			# the cache of constructed types has to come from the root generic type def or you end up with duplicate
			# constructed types which is not only wasteful, but causes problems with inheritance tests
			genericDef = this
			while genericDef.genericDef
				genericDef = genericDef.genericDef to !

			if genericDef._constructions is nil
				genericDef._constructions = Dictionary<of String, Method>()

			key = TypeUtil.keyForTypeArgs(typeArgs)

			if genericDef._constructions.containsKey(key)
				return genericDef._constructions[key]

			c = .memberwiseClone to Method
			assert c is not this
			genericDef._constructions[key] = c
			c._genericDef = this
			c._constructions = nil  # only the generic def tracks the constructions			
			c._genericParams = List<of IType>(typeArgs)
			c._params = List<of Param>()
			typeForParam = TypeUtil.dictionaryOf(.genericParams, typeArgs)
			for param in .params
				c._params.add(param.constructedFor(.parentBox, typeForParam))
			c._returnType = c._returnType.secondaryConstructedTypeFor(.parentBox, typeForParam)
			c.bindInt
			return c

	def genericParamForName(name as String) as IType?
		# idea: return find param in _genericParams where param.name == name
		for param in _genericParams, if param.name == name, return param
		return nil


	## Binding

	def _bindInt is override
		for param in _genericParams
			param.bindInt
		base._bindInt
		if .name == '__init__'
			.compiler.warning(this, 'Initializers are named "init" with no surrounding underscores.')

	def _bindImp is override
		numErrors = .compiler.errors.count
		base._bindImp
		for param in _genericParams
			param.bindImp
		if _implementsTypeNode
			_implementsType = _implementsTypeNode.realType
			# TODO: make sure the type is among the interfaces of the box
		if .compiler.errors.count==numErrors and _returnType is not .compiler.voidType and not .hasReturnStmt and not .hasYieldStmt and not .hasThrowStmt and not .isAbstract and not .parentBox.isExtern and not .parentBox inherits Interface
			.throwError('Missing return statement for method "[_name]" which returns [_returnType.name].')
		# check for `return` and `yield` in the same method
		if .resultType is not .compiler.voidType
			returnStmts = List<of Stmt>()
			hasYield = false
			for stmt in _stmts
				if stmt inherits ReturnStmt
					returnStmts.add(stmt)
				else if stmt inherits YieldStmt
					hasYield = true
			if hasYield and returnStmts.count
				for stmt in returnStmts
					stmt.recordError('Cannot return a value from an iterator. Use the yield return statement to return a value, or yield break to end the iteration.')


class ProperDexer
	is abstract, partial
	inherits BoxMember
	"""
	The abstract base class for Property and Indexer.

	This captures some of the common interface between them--whatever happens to be needed.

	Why not do an IProperDexer interface? Because it wouldn't be compatible with a BoxMember
	unless we also defined an IBoxMember.
	"""

	var _getPart as ProperDexerXetter?
	var _setPart as ProperDexerXetter?
	var _coverVar as BoxVar?
	var _coverAccess as String?
	var _returnType as IType?
	var _returnTypeNode as ITypeProxy?

	def init(token as IToken, box as Box, name as String, isNames as List<of String>, attribs as AttributeList, docString as String)
		base.init(token, box, name, isNames, attribs, docString)

	def init(token as IToken, box as Box, name as String, returnTypeOrNode as INode, isNames as List<of String>, attribs as AttributeList, docString as String)
		.init(token, box, name, isNames, attribs, docString)
		if returnTypeOrNode inherits IType
			_returnType = returnTypeOrNode
			_returnTypeNode = nil
		else if returnTypeOrNode inherits ITypeProxy
			_returnType = nil
			_returnTypeNode = returnTypeOrNode
		else
			throw FallThroughException(returnTypeOrNode)

	def makeGetPart(token as IToken) as AbstractMethod is abstract
		require .getPart is nil
		ensure .getPart

	def makeSetPart(token as IToken) as AbstractMethod is abstract
		require .setPart is nil
		ensure .setPart

	def addRefFields is override
		base.addRefFields
		if _coverVar
			.addField('coverVar', _coverVar)
		if _returnType
			.addField('returnType', _returnType)
		else
			.addField('returnTypeNode', _returnTypeNode)

	def addSubFields is override
		base.addSubFields
		if _getPart
			.addField('getPart', _getPart)
		if _setPart
			.addField('setPart', _setPart)

	get returnType from var

	get returnTypeNode from var

	get resultType as IType is override
		assert .didBindInt
		assert _returnType
		return _returnType to !

	get getPart from var

	get setPart from var

	get shouldBeVirtual as bool is override
		return .isClassMember # TODO: and not _implementsTypeNode and not _implementsType

	def mergedIntoPartialBox(newBox as Box)
		base.mergedIntoPartialBox(newBox)
		if .getPart, .getPart.mergedIntoPartialBox(newBox)
		if .setPart, .setPart.mergedIntoPartialBox(newBox)

	def unNilReturnType is override
		assert _returnType is nil
		if _returnTypeNode inherits NilableTypeProxy
			_returnTypeNode = _returnTypeNode.innerTypeProxy

	def _bindInt is override
		base._bindInt
		if _returnType is nil
			if _coverVar
				_coverVar.bindInt
				_returnType = _coverVar.resultType
			else
				assert _returnTypeNode
				_returnType = _returnTypeNode.realType
		assert _returnType  # properties always have a return type

		if _coverVar
			if _coverAccess in ['getset', 'get']
				# return VARNAME
				.makeGetPart(.token).statements.add(ReturnStmt(.token, IdentifierExpr(.token, _coverVar)))
			if _coverAccess in ['getset', 'set']
				# VARNAME = value
				.makeSetPart(.token).statements.add(AssignExpr(.token, 'ASSIGN', IdentifierExpr(.token, _coverVar), IdentifierExpr(.token, 'value')))

		if _getPart
			_getPart.bindInt
		if _setPart
			_setPart.bindInt

	def _bindImp is override
		base._bindImp
		if _getPart
			_getPart.bindImp
		if _setPart
			_setPart.bindImp

	def constructedFor(box as Box, gpToType as Dictionary<of GenericParam, IType>) as BoxMember  # CC: as same
		newMember = base.constructedFor(box, gpToType) to ProperDexer  # CC: this = base. ...
		assert newMember._returnType
		newMember._returnType = newMember._returnType.secondaryConstructedTypeFor(box, gpToType)
		return newMember


class ProperDexerXetter
	is abstract, partial
	inherits AbstractMethod
	"""
	Base class for IndexerGetter, IndexerSetter, PropertyGetter and PropertySetter.
	"""

	var _parent as ProperDexer

	def init(token as IToken, parent as ProperDexer, isNames as List<of String>)
		base.init(token, parent.parentBox, parent.name, List<of Param>(), isNames, AttributeList(), '')  # TODO: should be docString, right?
		_name = parent.name + '.' + .xetPartName  # CC: somewhat awkward. belongs in the base.init() call
		_parent = parent

	get canHaveMatchingBaseMember as bool is override
		return _parent.canHaveMatchingBaseMember

	get parent from var

	get xetPartName as String is abstract

	get isNames as List<of String>? is override
		# may need to get more sophisticated here if, in the future, we support C#'s somewhat recent ability to put access modifiers on just the set or get part of a property
		return _parent.isNames

	get isShared as bool is override
		return _parent.isShared

	get isOverride as bool is override
		return _parent.isOverride

	def usesBase is override
		# it's the property that needs to compute the "is override" or "is new" for itself,
		# not the get or set part
		_parent.usesBase


class MemberOverload
	is partial
	inherits BoxMember
	"""
	Methods and indexers can be overloaded.
	"""
	# TODO: Should take a new IOverloadable instead of BoxMember. Only Method and Indexer would implement that interface.
	
	var _members as List<of BoxMember>

	def init(member as BoxMember)
		require
			member.name.length
		ensure
			.members.count
			.members[0] == member
		body
			base.init(member.token, member.parentBox, member.name, member.isNames, AttributeList())
			member.overloadGroup = this
			_members = [member]
			_isNames = member.isNames  # pick up 'shared' for example

	def addMinFields is override
		base.addMinFields
		.addField('numMembers', .members.count)
		
	def addSubFields is override
		base.addSubFields
		.addField('members', _members)

	get members from var

	get englishName as String is override
		assert _members.count
		return _members[0].englishName

	get isCallable as bool is override
		assert _members.count
		return _members[0].isCallable

	get isMethod as bool is override
		return _members[0].isMethod

	def addMember(member as BoxMember)
		require
			member is not this
			not member inherits MemberOverload
			member.overloadGroup is nil
			member.name==.name
			member not in .members
			member.getType is .members[0].getType
		body
			member.overloadGroup = this
			_members.add(member)
			.parentBox.addDeclFromOverload(member, this)

	def addInheritedMember(member as BoxMember)
		require
			member is not this
			not member inherits MemberOverload
			member.name==.name
			member.parentBox is not .parentBox
			member not in .members
			member.getType is .members[0].getType
		body
			_members.add(member)

	def addInheritedMemberIfNoMatch(member as BoxMember)
		"""
		Utility method for _finishOverloads to avoid the mistake of putting an ancestor method in an overload that was an override or new.
		"""
		for existing in _members
			if member.matchesSignature(existing)
				return
		.addInheritedMember(member)
			
	get resultType as IType? is override
		assert .didBindInt
		assert _members[0] is not this
		return _members[0].resultType

	def unNilReturnType is override
		for member in _members
			member.unNilReturnType

	def _bindInt is override
		base._bindInt
		# sanity check that members all have the right name
		name = .name
		for member in _members
			assert member.name == name
		# sanity check that members don't have the same signature
		#if name <> 'getType'  # TODO: HACK: See Box.prepSystemObjectClass
		# TODO: having problems with explicit interface implementation. I think these probably should have their name changed from "foo" to "Type.foo"
		#	for i = 0 .. _members.count
		#		for j = i+1 .. _members.count
		#			assert not _members[i].matchesSignature(_members[j])
		# rename the test members of the overload by suffixing them with '_o1' '_o2' etc.

		i = 1
		for member in _members # CC: for i, member in _members.numbered
			if member.testMethod
				member.testMethod.overloadId = i
			i += 1
		# TODO: error if the returnType is different among any members
		# TODO: error if the two members have the same arguments

	def _bindImp is override
		base._bindImp


class TestMethod
	is partial
	inherits Method
	"""
	TODO: Does TestMethod need to be altered in light of generic parameters to methods?
	"""

	var _forMember as BoxMember?
	var _forBox as Box?
	var _overloadId = -1

	def init(token as IToken, member as BoxMember)
		require
			member.name.length
		body
			base.init(token, member.parentBox, 'test_'+member.name.capped, List<of Param>(), .getCompiler.voidType, nil, ['shared'], AttributeList(), '')
			_forMember = member

	def init(token as IToken, box as Box)
		require
			box.name.length
		body
			base.init(token, box, 'test_class_'+box.name.capped, List<of Param>(), .getCompiler.voidType, nil, ['shared'], AttributeList(), '')
			_forBox = box

	get shouldBeVirtual as bool is override
		return false

	pro name as String is new
		"""
		NamedNode.name does not allow the name to be set because that could mess up dictionaries
		that index the node by name. However, there are no such dictionaries for TestMethod and
		MemberOverload() needs to mangle test method names so they don't collide.
		"""
		get
			return base.name
		set
			require value.length
			_name = value

	pro overloadId from var


class ContractPart
	is abstract, partial
	inherits SyntaxNode
	"""
	The abstract base class for RequirePart and EnsurePart.
	"""

	var _connectToken as IToken?
	var _codeMember as AbstractMethod
	var _exprs as List<of Expr>
	var _isImplicit as bool # meaning the source code did not define this object

	def init(codeMember as AbstractMethod)
		base.init(codeMember.token)
		_isImplicit = true
		_codeMember = codeMember
		_exprs = List<of Expr>()

	def init(connectToken as IToken?, mainToken as IToken, codeMember as AbstractMethod, exprs as List<of Expr>)
		base.init(mainToken)
		_connectToken = connectToken
		_codeMember = codeMember
		_exprs = exprs

	def addMinFields
		base.addMinFields
		.addField('connectToken', _connectToken)
		.addField('isImplicit', _isImplicit)

	def addSubFields
		base.addSubFields
		.addField('exprs', _exprs)

	get codeMember from var

	get connectWord as String is abstract

	get exprs from var

	get haveConditions as bool is abstract
		"""
		Returns true if this contract part has any conditions, whether directly or through inheritance.
		"""

	get willWriteSharp as bool
		# classes that are sensitive with respect to the DST skip on contracts
		return _codeMember.canHaveDetailedStackTrace and .compiler.options['contracts'] <> 'none' and not (.willInlineSharp and not .haveConditions)
		
	get isImplicit from var

	def _bindImp is override
		base._bindImp
		newExprs = List<of Expr>()
		i = 0
		for expr in _exprs
			expr.bindImp  # TODO: error recovery
			assert expr.type
			if expr.type is not .compiler.boolType
				expr = TruthExpr(expr).bindAll to Expr # CC: axe cast when Cobra supports "as this"
				assert expr.type
			newExprs.add(expr)
			i += 1
		_exprs.clear
		_exprs.addRange(newExprs)

	def checkConnectToken
		"""
		This method checks that you said 'or require' vs. 'require', or 'and ensure' vs. 'ensure'.
		The check cannot be made during _bindImp because it relies on the .codeMember.isNames which can be altered when binding the statements in the method body (per .usesBase).
		"""
		isNames = _codeMember.isNames
		if not _isImplicit
			if _connectToken
				if 'override' not in isNames
					.recordError('The contract was specified with "[_connectToken.text]", but the code member is neither an "override" nor "new".')
			else
				if 'override' in isNames
					what = if('override' in isNames, 'override', 'new')
					.recordError('The contract must be declared "[.connectWord] [.token.text]" rather than "[.token.text]" because the code member is "[what]".')


class RequirePart
	is partial
	inherits ContractPart

	def init(codeMember as AbstractMethod)
		base.init(codeMember)

	def init(connectToken as IToken?, mainToken as IToken, codeMember as AbstractMethod, exprs as List<of Expr>)
		base.init(connectToken, mainToken, codeMember, exprs)
		codeMember.requirePart = this

	get connectWord as String is override
		return 'or'

	get haveConditions as bool is override
		if _codeMember.isOverride
			have = false
			curCodeMember = _codeMember to ?
			post while curCodeMember
				if curCodeMember.requirePart.exprs.count
					have = true
					break
				curCodeMember = curCodeMember.matchingBaseMember to AbstractMethod?
			return have
		else
			return _codeMember.requirePart.exprs.count > 0

	
class EnsurePart
	is partial
	inherits ContractPart

	def init(codeMember as AbstractMethod)
		base.init(codeMember)

	def init(connectToken as IToken?, mainToken as IToken, codeMember as AbstractMethod, exprs as List<of Expr>)
		base.init(connectToken, mainToken, codeMember, exprs)
		codeMember.ensurePart = this

	get connectWord as String is override
		return 'and'

	get haveConditions as bool is override
		if _codeMember.parentBox.hasInvariants
			return true
		have = false
		curCodeMember = _codeMember to ?
		post while curCodeMember
			if curCodeMember.ensurePart.exprs.count
				have = true
			curCodeMember = curCodeMember.matchingBaseMember to AbstractMethod?  # TODO: should a cast really be needed here?
		return have

	def _bindImp is override
		if _codeMember.resultType is .compiler.voidType
			base._bindImp
		else
			resultLocal = _codeMember.findLocal('result')
			resultBuiltIn = ResultVar(.token, _codeMember)
			if resultLocal
				_codeMember.replaceLocal(resultBuiltIn)
			else
				_codeMember.addLocal(resultBuiltIn)
			try
				base._bindImp
			finally
				if resultLocal
					_codeMember.replaceLocal(resultLocal to LocalVar)
				else
					_codeMember.removeLocal('result')
