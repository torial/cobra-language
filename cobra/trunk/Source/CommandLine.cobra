"""
Cobra Command Line Program (compiler and more)

"""
use System.Diagnostics


class CommandLine
	"""
	The main options that control the command line's behavior are:
		run
		test
		compile
		testify
		help

	"testify" is private to the implementor of Cobra.

	"run" is the default if none are specified and at least one path is provided.

	If no arguments are passed at all, "help" becomes the default.

	You need to put at least one dash in front of an option. Also, you can leave
	out the ".cobra" extension if you like. For example:

		cobra -compile foo bar

	"""

	get versionString as String is shared
		s = CobraCore.versionDescription
		if s.endsWith('.0')
			s = s[:-2]
		return s

	var _optionSpecs as List<of Dictionary<of String, Object>>

	var _rawOptionSpecs = [
		{
			'name': 'about',
			'description': 'Print the name, copyright, etc. but no usage.',
			'type': 'main',
		},
		{
			'name': 'build-standard-library',
			'description': 'Builds the standard library.',
			'type': 'main',
			'developer-only': true,
		},
		{
			'name': 'compile',
			'synonyms': ['c'],
			'description': 'Compile the library (to DLL) or the program (to EXE) without running the code.',
			'type': 'main',
		},
		{
			'name': 'color',
			'type': 'bool',
			'description': 'Colorizes the output of error messages and the messages "Compilation failed" and "Compilation succeeded" (as red, red and blue).',
		},
		{
			'name': 'contracts',
			'description': 'Control treatment of code generation for contracts.',
			'type': 'menu',
			'choices': ['none', 'inline', 'methods'],
			'args': 'none|inline|methods',
			'default': 'inline',
		},
		{
			'name': 'debug',
			'synonyms': ['d'],
			'type': 'string',
			'description': 'Turn on system debugging information. The value 1 implies full, which enables attaching a debugger to a running program.',
			'args': '0|1|pdbonly|full'
		},
		{
			'name': 'debugging-tips',
			'description': 'Display debugging tips when an unhandled exception occurs. Overridden by -exception-report.',
			'type': 'bool',
			'default': 'yes',
		},
		{
			'name': 'detailed-stack-trace',
			'synonyms': ['dst'],
			'type': 'bool',
			'description': 'Enable a detailed stack trace which gives great postmortem information for uncaught exceptions, but slows execution. Works in combination with -exception-report.',
		},
		{
			'name': 'embed-run-time',
			'synonyms': ['ert'],
			'type': 'bool',
			'default': 'yes',
			'description': 'Embed the Cobra run-time support code (approx. 80KB) in the assembly so that no reference to an external Cobra.Lang.dll is required.',
		},
		{
			'name': 'exception-report',
			'synonyms': ['exc-rpt', 'er'],
			'type': 'bool',
			'description': 'Turn on an informative HTML report that will be generated if the program throws an uncaught exception.',
		},
		{
			'name': 'files',
			'isAccumulator': true,
			'description': 'Specify the files for Cobra to process in a separate text file. One file per line; # comments and blank lines are ignored.',
			'args': 'filename',
		},
		{
			'name': 'editor',
			'description': 'Specify an editor and command line options to invoke if there is a compile-time error. Use underscore (_) for space in the specification. Can also set via COBRA_EDITOR environment variable (in which case spaces work fine).',
			'example': ['uedit32_FILE/LINE', 'mate_FILE_-l_LINE'],
			'args': 'editor_spec_with_FILE_LINE',
		},
		{
			'name': 'help',
			'synonyms': ['h'],
			'type': 'main',
			'description': 'Display this help message.',
		},
		{
			'name': 'include-tests',
			'type': 'bool',
			'default': 'yes',
			'description': 'Includes unit tests for classes and members in the output assembly.',
		},
		{
			'name': 'keep-intermediate-files',
			'synonyms': ['kif'],
			'type': 'bool',
			'description': 'Keeps any intermediate files that Cobra generates, which are normally deleted. Example intermediate files are *.cobra.cs.',
		},
		{
			'name': 'library-directory',
			'synonyms': ['lib'],
			'type': 'string',
			'isAccumulator': true,
			'description': 'Specify additional directories to search in for references.',
			'args': 'PATH',
		},
		{
			'name': 'output-html',
			'type': 'bool',
			'description': "The command line's output will be in HTML.",
		},
		{
			'name': 'reference',
			'synonyms': ['r'],
			'isAccumulator': true,
			'description': 'Add a DLL reference.',
			'args': 'Some.dll',
		},
# TODO
#		{
#			'name': 'reflect',
#			'isAccumulator': true,
#			'description': 'Display the type interface in Cobra syntax. Use its fully qualified name.',
#			'args': ':Qualified.Type.Name',
#		},
		{
			'name': 'run',
			'description': 'Runs the Cobra program. This is the default behavior if specify any Cobra source files.',
			'type': 'main',
		},
		{
			'name': 'sharp-args',
			'description': 'Passes arguments to the C# compiler.',
			'type': 'string',
			'args': '"arg1 arg2"',
		},
		{
			'name': 'target',
			'description': 'Build a specific target.',
			'type': 'menu',
			'choices': ['exe', 'winexe', 'lib', 'module'],
			'args': 'exe|winexe|lib|module',
			'synonyms': ['t'],
		},
		{
			'name': 'test',
			'description': 'Run the unit tests in the code.',
			'type': 'main',
		},
		{
			'name': 'testify',
			'description': '...',
			'type': 'main',
			'developer-only': true,
		},
		{
			'name': 'timeit',
			'description': 'Gives the total duration of running cobra (including the target program, if it is to be run). This is "wall time", not "cpu time".',
			# although this option is implied by 'testify', the description does not say so, since 'testify' is a hidden option
			'type': 'bool',
		},
		{
			'name': 'verbosity',
			'synonyms': ['verbose', 'v'],
			'type': 'int',
			'min': 0,
			'max': 5,
			'args': 'N',
			'description': 'Enable extra output from Cobra. Mostly useful for debugging Cobra. Values 0 - 5.',
		},
		{
			'name': 'version',
			'description': 'Print just the version number ([.versionString]).',
			'type': 'main',
		},
		{
			'name': 'reveal-internal-exceptions',
			'description': 'When true, uncaught exceptions from the Cobra compiler itself are not caught and wrapped in error messages. This is useful when developing on the Cobra compiler itself. Set to true if the environment variable COBRA_IS_DEV_MACHINE.',
			'type': 'bool',
			'developer-only': true,
		},
	]

	var _startTime as DateTime
	var _verbosity = 0

	var _options = Options()
	var _pathList as List<of String>?
	var _htmlWriter as HtmlWriter?

	var _cachedTestifyModules as IList<of Module>?

	def init
		_startTime = DateTime.now
		# prep the option specs
		_optionSpecs = List<of Dictionary<of String, Object>>()
		for specObj in _rawOptionSpecs
			# since some _optionSpecs are Dictionary<of String, Object> and others are
			# Dictionary<of String, String> then _optionSpecs ends up being
			# Dictionary<of String, Object>

			if specObj inherits Dictionary<of String, Object>
				d = specObj
			else if specObj inherits Dictionary<of String, String>
				d = Dictionary<of String, Object>()
				for key in specObj.keys
					d[key] = specObj[key]
			else
				throw FallThroughException(specObj.getType)
			_optionSpecs.add(d)

	get cobraTestsPath as String
		"""
		Only used when --testify is passed with no path.
		--testify is an "internal" feature of the cobra command line front end.
		"""
		# -testify is often invoked out of the next-door directory "Source"
		# so check next door, first:
		slash = Path.directorySeparatorChar
		path = "..[slash]Tests"
		if Directory.exists(path)
			return Path.getFullPath(path)
		throw Exception(r'Cannot find Tests directory next door or in HOME\Projects\Cobra\Workspace\Tests')

	get options from var

	get verboseLineSeparator as String
		w = Console.bufferWidth
		if w < 20
			w = 80
		w -= 1
		return String(c'-', w)

	get verbosity as int
		return _verbosity

	def run
		"""
		Run the command line using the command line arguments.
		"""
		.run(CobraCore.commandLineArgs[1:])

	def run(args as List<of String>)
		"""
		Run the command line using the given arguments.
		The `args` should include only the arguments and not the executable/program name.
		"""
		if args.count == 0
			.doAbout
			return
		.parseArgs(args)
		if _options.boolValue('output-html')
			_htmlWriter = HtmlWriter(Console.out)
			dest = _htmlWriter to TextWriter
		else
			dest = Console.out
		if _htmlWriter
			stylePath = Path.combine(Path.getDirectoryName(CobraCore.exePath), 'styles-output-html.css')
			_htmlWriter.writeHtml('<html><head><link href="file://[stylePath]" rel=stylesheet type="text/css"></head><body>[_htmlWriter.newLine]')
		print to dest
			paths = _pathList to !
			options = _options
			if .verbosity > 0
				print 'Cobra Command Line [.versionString]'
				if CobraCore.isRunningOnMono
					print 'running on Mono'
				print 'current directory: [Environment.currentDirectory]'
				print 'current exe: [CobraCore.exePath]'
				print 'option dictionary:'
				options.print
				print 'paths:'
				for path in paths
					print '    [path]'
			if options.boolValue('testify')
				.doTestify(paths)
			else if options.boolValue('run')
				.doRun(paths)
			else if options.boolValue('test')
				.doTest(paths)
			else if options.boolValue('compile')
				.doCompile(paths)
			else if options.boolValue('help')
				.doHelp
			else if options.boolValue('version')
				.doVersion
			else if options.boolValue('about')
				.doAbout
			else if options.boolValue('build-standard-library')
				.doBuildStandardLibrary
			else if not paths.count
				.doHelp
			else
				.doRun(paths)
		if _htmlWriter
			_htmlWriter.writeHtml('</body></html>[_htmlWriter.newLine]')

	def testifyOptions as Options
		# TODO: this doesn't even work...
		# CC: use out args when available
		save1 = _options
		save2 = _pathList
		.parseArgs(List<of String>())
		r = _options
		_pathList = save2
		_options = save1
		# trace r
		# remember that you cannot use synonyms below. you must use the canonical name of the option
		# also, default options are not included (which is lame), so you must specify them here
		r = Options()
		r['include-tests'] = true
		r['embed-run-time'] = false
		r['verbosity'] = 2
		r['testify'] = true
		r['debug'] = '+'
		r['contracts'] = 'inline'
		return r

	def parseArgs(args as String)
		.parseArgs(args.split)

	def parseArgs(args as IList<of String>)
		"""
		Parse command line arguments.
		The `args` should include only the arguments and not the executable/program name.
		Sets _options and _pathList.
		"""
		optionPrefix = '-'
		valuePrefix = c':'
		if not args.count
			_options = Options()
			_options.add('help', true)
			_pathList = List<of String>()
			return

		specDict = Dictionary<of String, Dictionary<of String, Object>>()
			# ^ will contain keys for all spec names and their synonyms
		synToName = Dictionary<of String, String>()
			# ^ maps synonyms to their full names
		synList = List<of String>()
		for d in _optionSpecs
			specDict[d['name'] to String] = d
			if d.containsKey('synonyms')
				syns = d['synonyms'] to System.Collections.IList
				for syn as String in syns
					assert not specDict.containsKey(syn)
					specDict[syn] = d
					synToName[syn] = d['name'] to String
					synList.add(syn)
			if not d.containsKey('type')
				d.add('type', 'string')

		# set up initial valueDict
		valueDict = Dictionary<of String, Object>()
		if Utils.isDevMachine
			valueDict['reveal-internal-exceptions'] = true  # this is a specially computed default, but can still be overridden on the command line

		fileList = List<of String>()
		value = 'no-value' to dynamic
		mainOptions = List<of String>()
		for arg in args
			if arg.trim.length == 0
				continue
			if arg.startsWith(optionPrefix)
				isOption = true
				while arg.startsWith(optionPrefix)
					arg = arg.substring(1)
			else
				isOption = false
			if isOption
				parts = arg.split(@[valuePrefix], 2)
				if parts.length == 1
					name = parts[0]
					if name.endsWith('+')
						name = name[:-1]
						valueStr = 'on'
					else if name.endsWith('-')
						name = name[:-1]
						valueStr = 'off'
					else
						valueStr = 'on'
				else
					assert parts.length == 2
					name = parts[0]
					valueStr = parts[1]
				assert name.length, parts
				name = Utils.getSS(synToName to passthrough, name, name) to !
				if not specDict.containsKey(name)
					msg = 'No such option "[name]".'
					if name.contains('=')
						msg += ' If you meant to specify an option value, use colon (:) instead of equals (=).'
					.error(msg)
				spec = specDict[name]
				if Utils.getSB(spec to passthrough, 'isAccumulator', false)
					# accumulators are always treated as strings. TODO: assert that
					if valueDict.containsKey(name)
						(valueDict[name] to System.Collections.IList).add(valueStr to passthrough)
					else
						valueDict[name] = [valueStr]
				else
					cannotProcess = false
					if name=='debug'
						# special case
						if valueStr=='pdbonly' or valueStr=='full'
							value = valueStr
						else
							try
								value = .boolForString(valueStr)
							catch FormatException
								cannotProcess = true
							success
								value = if(value, '+', '-')
					else
						if spec['type'] == 'main'
							mainOptions.add(name)
							value = true
						else
							possible = .interpretValue(valueStr, spec)
							if possible is not nil
								value = possible
							else
								cannotProcess = true							
					if cannotProcess
						.error('Cannot process value "[valueStr]" for option "[name]".')
					valueDict[name] = value
			else # not isOption
				if File.exists(arg)
					fileList.add(arg)
				else if File.exists(arg+'.cobra')
					fileList.add(arg+'.cobra')
				else if Directory.exists(arg)
					fileList.add(arg)
				else
					msg = 'Cannot find "[arg]" as a file.'
					if arg.startsWith('/')
						msg += ' If you meant to specify an option, use dash (-) instead of slash (/).'
					.error(msg)

		# handle synonyms
		for syn in synList
			if valueDict.containsKey(syn)
				valueDict[synToName[syn]] = valueDict[syn]
				valueDict.remove(syn)

		# add in defaults
		for d in _optionSpecs
			defaultName = d['name'] to String
			if not valueDict.containsKey(defaultName) and d.containsKey('default')
				defaultValue = .interpretValue(d['default'] to String, d) to !
				if .verbosity
					print 'Setting option "[defaultName]" to default value [defaultValue].'
				valueDict[defaultName] = defaultValue

		# TODO: make the option names case-insensitive

		# check for more than one main option
		if mainOptions.count > 1
			.error('Cannot have these main options at the same time: [Utils.join(", ", mainOptions)]')

		# unpack certain options into specific class fields
		if valueDict.containsKey('verbosity')
			_verbosity = valueDict['verbosity'] to int
		if not valueDict.containsKey('timeit') and valueDict.containsKey('testify')
			valueDict['timeit'] = true
		if valueDict.containsKey('timeit')
			CobraMain.willTimeIt = valueDict['timeit'] to bool
		if valueDict.containsKey('files')
			for fileName as String in valueDict['files'] to System.Collections.IList
				try
					for line in File.readAllLines(fileName)
						line = line.trim
						if line.length==0 or line.startsWith('#')
							continue
						# TODO: dup'ed above
						arg = line
						if File.exists(arg)
							fileList.add(arg)
						else if File.exists(arg+'.cobra')
							fileList.add(arg+'.cobra')
						else if Directory.exists(arg)
							fileList.add(arg)
						else
							msg = 'Cannot find "[arg]" as a file.'
							#if arg.startsWith('/')
							#	msg += ' If you meant to specify an option, use dash (-) instead of slash (/).'
							.error(msg)
						# end dup
				catch IOException
					.error('Cannot open file "[fileName]".')

		# set the class vars
		_options = Options(valueDict)
		_pathList = fileList
		
		.computeArgImplications
	
	def computeArgImplications
		if .options.getDefault('target', '') == 'lib' and not .options.boolValue('compile')
			.options['compile'] = true

	def interpretValue(valueStr as String, spec as Dictionary<of String, Object>) as dynamic?
		value as dynamic?
		branch spec['type'] to String
			on 'main'
				throw InvalidOperationException('This method does not handle the main type.')
			on 'bool'
				try
					value = .boolForString(valueStr)
				catch FormatException
					cannotProcess = true
			on 'int'
				if valueStr == 'on'  # set internally when there is no value
					valueStr = '1'
				try
					value = int.parse(valueStr)
				catch FormatException
					cannotProcess = true
				catch OverflowException
					cannotProcess = true
				# TODO: check min and max
			on 'string'
				value = valueStr
			on 'menu'
				if valueStr.length==0
					cannotProcess = true
				if not (spec['choices'] to System.Collections.IList).contains(valueStr)
					cannotProcess = true
				else
					value = valueStr
		r = if(cannotProcess, nil, value)
		return r

	def doCompile(paths as List<of String>) as Compiler
		return .doCompile(paths, true, false)

	def doCompile(paths as List<of String>, willPrintSuccessMsg as bool, writeTestInvocation as bool) as Compiler
		oldPaths = List<of String>(paths)
		paths.clear
		for path in oldPaths
			if File.exists(path)
				paths.add(path)
			else if Directory.exists(path)
				.error('Cannot process directories in general ("[path]").')
			else
				.error('Cannot find file "[path]".')
		if paths.count == 0 and not .options.buildStandardLibrary
			.error('No files to process.')
		c = Compiler(.verbosity)
		c.options = _options
		c.willPrintSuccessMsg = willPrintSuccessMsg
		c.htmlWriter = _htmlWriter
		try
			c.compileFilesNamed(paths, writeTestInvocation)
		catch StopCompilation
			# Each phase of the compiler may throw an exception to stop compilation.
			# Before doing so, it prints its errors.
			assert c.errors.count>0
			if _options.containsKey('editor')
				spec = _options['editor'] to String?
			else
				spec = Environment.getEnvironmentVariable('COBRA_EDITOR')
			if spec and spec <> ''
				if spec.indexOf('FILE')==-1
					.error('Missing FILE from editor spec.')
				if spec.indexOf('LINE')==-1
					.error('Missing LINE from editor spec.')
				i = spec.indexOf('_')
				if i == -1
					i = spec.indexOf(' ')
					if i == -1
						.error('Missing underscore or space from editor spec.')
				exeName = spec.substring(0, i)
				args = spec.substring(i+1)
				for error in c.errors
					if error.isError and error.hasSourceSite
						if error.fileName.trim <> ''
							# trace error.fileName, error.lineNum
							args = args.replace('FILE', error.fileName)
							args = args.replace('LINE', error.lineNum.toString)
							p = System.Diagnostics.Process()
							p.startInfo.fileName = exeName
							p.startInfo.arguments = args
							p.startInfo.useShellExecute = false
							if _verbosity >= 3
								print 'Running: [p.startInfo.fileName] [p.startInfo.arguments]'
							try
								p.start
								p.waitForExit  # TODO: is this really needed?
							catch exc as Exception
								print 'Cannot invoke editor:'
								print '    Command: [p.startInfo.fileName] [p.startInfo.arguments]'
								print '    Exception: [exc]'
							break
		return c

	def doTest(paths as List<of String>)
		if paths.count == 0
			.error('You must specify one or more Cobra files to run unit tests for.')
		c = .doCompile(paths, false, true)
		if c.errors.count
			print 'Not running tests due to errors above.'
			return
		testInvoker = c.modules[c.modules.count-1]  # CC: .last
		assert testInvoker inherits SharpModule
		assert testInvoker.fileName.startsWith('test-')
		File.delete(testInvoker.fileName)
		try
			p = Process()
			.setUpRunProcess(c, p)
			if _verbosity >= 1
				print 'Running: [p.startInfo.fileName] [p.startInfo.arguments]'
				print .verboseLineSeparator
			p.startInfo.useShellExecute = false
			p.start
			p.waitForExit  # TODO: is this necessary?
		catch
			File.delete(c.fullExeFileName)
			throw
		success
			File.delete(c.fullExeFileName)

	def doRun(paths as List<of String>)
		c = .doCompile(paths, false, false)
		if c.errors.count
			print 'Not running due to errors above.'
		else
			p = Process()
			.setUpRunProcess(c, p)
			if _verbosity >= 1
				print 'Running: [p.startInfo.fileName] [p.startInfo.arguments]'
				print .verboseLineSeparator
			p.startInfo.useShellExecute = false
			p.start
			p.waitForExit  # TODO: is this necessary?

	def doHelp
		# CC: multiline string
		.doAbout
		print ''
		print 'Usage:'
		print ''
		print '  cobra <options> <filename>'
		print '    * run filename'
		print '    * compile if needed'
		print '    * .cobra extension is optional'
		print ''
		print '  cobra <options> <command> <path(s)>'
		print '    * commands that operate on path(s) are:'
		print '      -compile ... Compile only.'
		print '      -run ....... Run the program (compile if necessary).'
		print '      -test ...... Run the unit tests of a library.'
		print ''
		print '  cobra <options> <command>'
		print '    * standalone commands are:'
		print '      -help ...... Print full help information.'
		print '      -about ..... Print name, copyright, etc. no usage.'
		print '      -version ... Print just the version number ([.versionString]).'
		print ''
		print '  <options> can be:'

		# print options from their specs (but not the main ones which are covered above)
		leftMargin = 8
		leftMarginStr = '        '
		consoleWidth = Console.windowWidth
		if consoleWidth < 1
			consoleWidth = Console.bufferWidth
		totalWidth = consoleWidth - 2
		if totalWidth < 0
			totalWidth = 0
		if totalWidth == 0
			totalWidth = 78
		else if totalWidth < 20
			totalWidth = 20
		assert totalWidth > 0
		width = totalWidth - leftMargin
		assert width > 0
		for spec in _optionSpecs
			if spec.containsKey('type') and spec['type']=='main' # CC: spec.get('main', '')
				continue
			if spec.containsKey('developer-only') and spec['developer-only'] to bool and not Utils.isDevMachine
				continue
			print
			print '    -[spec["name"]]' stop
			if spec.containsKey('args')
				if spec.containsKey('default')
					lbracket = r'['
					print '[lbracket]:[spec["args"]]]' stop
				else
					print ':[spec["args"]]' stop
			else if spec['type']=='bool'
				print r'[:no|yes]' stop
			if spec.containsKey('default')
				print '  default is [spec['default']]' stop
			print
			if spec.containsKey('synonyms')
				print '    ' stop
				sep = ''
				for syn as String in spec['synonyms'] to System.Collections.IList
					print '[sep]-[syn]' stop
					sep = ', '
				print
			s = spec['description'] to String
			while s.length
				if s.length < width
					print '[leftMarginStr][s]'
					s = ''
				else
					# TODO: bug in here for narrow widths. try "width = 20" to reproduce
					j = width+1
					if j >= s.length
						j = s.length - 1
					while j > 0 and s[j] <> ' '
						j -= 1
					if j
						sub = s.substring(0, j)
						s = if(s.length, s.substring(j+1), '')
						print '[leftMarginStr][sub]'
			if spec.containsKey('example')
				if spec['example'] inherits System.Collections.IList
					first = true
					for example in spec['example'] to System.Collections.IList
						if first
							print '        Examples: ' stop
						else
							print '                  ' stop
						print '-[spec["name"]]:[example]'
						first = false
				else
					print '        Example: -[spec["name"]]:[spec["example"]]'

	def doAbout
		# CC: multiline string
		print 'The Cobra Programming Language [CobraCore.versionDescription]'
		print 'Copyright (C) 2003-[DateTime.now.year] by Cobra Language LLC.  All Rights Reserved.'
		print ''
		print 'On the web:  http://Cobra-Language.com/'
		print 'License:     See Cobra/Docs/License.text'
		# TODO: print '             http://Cobra-Language.com/Docs/License.text'
		print 'Usage:       cobra -h'

	def doVersion
		print .versionString

	def boolForString(s as String) as bool
		if s.toLower in ['', '+', 'on', 'true', 't', 'yes', 'y', '1']
			return true
		else if s.toLower in ['-', 'off', 'false', 'f', 'no', 'n', '0']
			return false
		else
			throw FormatException()

	## Self Services

	def error(msg as String)
		if msg.length
			print 'cobra: error: [msg]'
			print 'Run Cobra without options to get full usage information.'
		Environment.exit(1)

	def setUpRunProcess(c as Compiler, p as Process)
		"""
		Sets p.startInfo.fileName and p.startInof.arguments appropriately.
		"""
		# TODO: support args to the program with a - or -- separator
		branch c.platform
			on PlatformEnum.Microsoft
				p.startInfo.fileName = c.baseExeFileName
			on PlatformEnum.Novell
				p.startInfo.fileName = 'mono'
				args = ''
				# mono also needs --debug when running
				if .options.getDefault('debug', '') not in ['', '-']
					args += '--debug '
				args += "'[c.fullExeFileName]'"
				p.startInfo.arguments = args
			else
				throw FallThroughException(c.platform)


	## Build Standard Library
	
	def doBuildStandardLibrary
		v = .verbosity
		if v
			print 'Building standard library'
		dllInfo = FileInfo('Cobra.Lang.dll')
		if dllInfo.exists
			if v
				print 'Renaming Cobra.Lang.dll to Cobra.Lang-previous.dll'
			prevInfo = FileInfo('Cobra.Lang-previous.dll')
			if prevInfo.exists
				prevInfo.delete
			FileInfo('Cobra.Lang.dll').moveTo('Cobra.Lang-previous.dll')
		_options['target'] = 'lib'
		_options['include-tests'] = false  # TODO: including tests in a DLL tends to cause problems. it might be because tests are triggered by type initializers. this needs investigation
		_options['embed-run-time'] = true  # because the runtime is what we're building!
		.doCompile(List<of String>(), true, false)


	## Testify

	var _testifyCount as int

	var _failureCount as int

	var _firstAttempt as bool

	# two writers for testify:
	var _statusWriter as IndentedWriter?
	var _statusCount as int
	var _resultsWriter as IndentedWriter?

	def doTestify(paths as List<of String>)
		"""
		Used internally for testing cobra during development.
		Why not just 'test'? because that is reserved for regular developers to run true unit tests.
		"""
		_statusWriter = IndentedWriter(AutoFlushWriter(Console.out))
		_statusWriter.indentString = '    '
		try
			using resultsWriter = File.createText('r-testify')
				_resultsWriter = IndentedWriter(AutoFlushWriter(resultsWriter))
				print to _resultsWriter
					print 'Cobra: Testify'
					print 'Started at', DateTime.now
					print
					_innerDoTestify(paths)
		finally
			_statusWriter = nil

	def _testifyFlush
		_statusWriter.flush
		_resultsWriter.flush

	def _innerDoTestify(paths as List<of String>)
		# TODO Console.error = Console.out
		if paths.count == 0
			paths = [.cobraTestsPath]
			# since .cobraTestsPath didn't throw an exception we can add the HowTo's
			paths.add(Path.combine('..', 'HowTo'))
		_testifyCount = 0
		for pathName in paths
			if Directory.exists(pathName)
				.testifyDir(pathName)
			else if File.exists(pathName)
				_testifyCount += .testifyFile(pathName)
			else
				.error('No such directory or file named "[pathName]".')
		.testifyFinish(if(_failureCount, 'Failure.', 'Success.'))

	def testifyFinish(message as String)
		_testifyFinish(message, _statusWriter to !)
		_testifyFinish(message, _resultsWriter to !)

	def _testifyFinish(message as String, writer as TextWriter)
		print to writer
			duration = DateTime.now.subtract(_startTime)
			print
			print 'Finished at', DateTime.now
			print '[_testifyCount] Tests in [duration].'
			if _failureCount
				print '[_failureCount] Failures.'
			print
			print message

	def testifyDir(dirName as String)
		"""
		Returns the number tests that passed.
		"""
		baseName = Path.getFileName(dirName) to !  # gets rid of "." and ".." as prefix for relative dirs
		if baseName.startsWith('.') or baseName.startsWith('_')
			# examples: .svn, _svn. Also, _ is a nice way to temporarily exclude a directory if possible
			return
		_statusWriter.writeLine('[dirName]')
		_statusWriter.indent
		try
			print 'Running tests in [dirName]'
			saveDir = Environment.currentDirectory
			if not CobraCore.isRunningOnMono
				targetPath = Path.combine(dirName, 'Cobra.Lang.dll')
				if File.exists(targetPath)
					File.delete(targetPath)
				File.copy(Path.combine(saveDir,'Cobra.Lang.dll'), targetPath)
			Directory.setCurrentDirectory(dirName)
			try
				paths = List<of String>(Directory.getFiles('.'))
				paths.addRange(Directory.getDirectories('.') to passthrough)
				paths.sort
				for baseName in paths
					baseName = Utils.normalizePath(baseName)
					if baseName.endsWith('.cobra')
						_testifyCount += .testifyFile(baseName)
					else if Directory.exists(baseName)
						.testifyDir(baseName)
					_testifyFlush
			finally
				Directory.setCurrentDirectory(saveDir)
		finally
			_statusWriter.dedent
		_testifyFlush

	def testifyFile(baseName as String) as int
		save = _failureCount
		_firstAttempt = true
		try
			result1 = _testifyFile(baseName)
			if _failureCount > save
				print
				print
				print 'DUE TO FAILURE, RERUNNING WITH MORE OUTPUT:'
				_firstAttempt = false
				result2 = _testifyFile(baseName)
				if result1 <> result2
					throw Exception('Result mismatch. result1=[result1], result2=[result2]')
		finally
			_testifyFlush
		return result1

	def _testifyFile(baseName as String) as int
		Node.setCompiler(nil)
		verbose = not _firstAttempt
		compilerVerbosity = if(_verbosity, _verbosity, if(verbose, 1, 0))
		if Path.pathSeparator in baseName
			return .testifyFilePath(baseName)

		_statusWriter.writeLine('([_statusCount]) [baseName]')
		_statusCount += 1
		assert File.exists(baseName)

		source = File.readAllText(baseName)
		bar = '----------------------------------------------------------------------------------------------------'

		print
		print
		print
		print 'RUN [baseName]'
		print '    [Utils.combinePaths(Environment.currentDirectory, baseName)]'
		print '    Test #[_testifyCount+1]'
		print bar
		print bar
		if verbose
			Utils.printSource(source)
			print bar
		lines = List<of String>(source.split(c'\n'))  # CC: axe list wrapper
		firstLine = lines[0]
		firstLineInsensitive = firstLine.trim.replace(' ', '')

		fileNames = [baseName]

		if firstLineInsensitive.startsWith('#.multi.')
			print 'Running multiple files.'
			for fileName in firstLine.substring(firstLine.indexOf('.multi.')+8).split
				if fileName.length
					fileNames.add(Utils.combinePaths(Path.getDirectoryName(baseName) to !, fileName))
			print 'Multiple filenames:', Utils.join(', ', fileNames)
			# enable having another directive on the next line, such as .error.
			lines = lines[1:]
			firstLine = lines[0]
			firstLineInsensitive = firstLine.trim.replace(' ', '')

		if firstLineInsensitive.startsWith('#.compile-only.')  # also meaning don't run the .exe
			willRunExe = false
			lines = lines[1:]
			firstLine = lines[0]
			firstLineInsensitive = firstLine.trim.replace(' ', '')
		else
			willRunExe = true
			
		if firstLineInsensitive.startsWith('#.args.')
			i = firstLine.indexOf('.args.')
			.parseArgs(firstLine[i+'.args.'.length:])
			args = _options
			options = .testifyOptions
			options.combine(args)
			# enable having another directive on the next line, such as .error.
			lines = lines[1:]
			firstLine = lines[0]
			firstLineInsensitive = firstLine.trim.replace(' ', '')
		else
			options = .testifyOptions

		if firstLineInsensitive.startsWith('#.skip.')
			print 'Skipping per directive on first line of test source.'
			return 0

		if firstLineInsensitive.startsWith('#.multipart.')
			# .multi. is the one that gets run along with its associated files
			# the associated files then specify .multipart. and get skipped when encountered
			print 'Skipping per directive on first line of test source.'
			return 0

		# Check for inline warning and error messages that are expected.
		# (Starting in 2007-12 this is now the preferred way to specify these messages--
		#  with the actual line of code that generates them.
		#  The old method of specifying at the top will still be needed for errors
		#  and warnings that have no associated line number.)
		hasInlineMessages = false
		inLineMessages = Dictionary<of int, String>()
		lineNum = 1
		expectingError = false
		for line in lines
			if lineNum > 1 and ('.warning.' in line or '.error.' in line)
				hasInlineMessages = true
				if '.warning.' in line
					message = line[line.indexOf('.warning.') + '.warning.'.length:]
					messageType = 'w'
				else if '.error.' in line
					message = line[line.indexOf('.error.') + '.error.'.length:]
					messageType = 'e'
					expectingError = true
				else
					throw FallThroughException(line)
				inLineMessages[lineNum] = messageType + message
			lineNum += 1
		if hasInlineMessages
			try
				c = Compiler(compilerVerbosity, _cachedTestifyModules)
				c.testifyFilesNamed([baseName], options, _resultsWriter to !, verbose)
			catch StopCompilation
				didStop = true
			success
				didStop = false
			for msg in c.messages
				if msg.lineNum == 0
					print 'Not expecting messages without any line number information:'
					print msg
					bad = true
					continue
				if not inLineMessages.containsKey(msg.lineNum)
					print 'Encountered unexpected message:'
					print msg
					bad = true
					continue
				expected = inLineMessages[msg.lineNum]
				branch expected[0]
					on c'w'
						if msg.isError
							print 'Expecting warning on line [msg.lineNum], but got error instead.'
							bad = true
					on c'e'
						if not msg.isError
							print 'Expecting error on line [msg.lineNum], but got warning instead.'
							bad = true
					else
						throw FallThroughException(expected)
				if bad
					continue
				expected = expected[1:].trim
				if msg.message.trim.toLower.indexOf(expected.toLower) == -1
					print 'Expecting message :', expected
					print 'But got           :', msg.message.trim
					print 'At line           :', msg.lineNum
					bad = true
					continue
				# we made it! same type of message and text
				print 'Message for line [msg.lineNum] was expected.'
				inLineMessages.remove(msg.lineNum)
			# check for expected messages that never occurred
			for key in inLineMessages.keys
				bad = true
				print 'Expecting message on line [key]:', inLineMessages[key][1:].trim
			if bad	
				.failed
				return 0
			else if expectingError
				return 1
			else if willRunExe
				# a test case with nothing but warnings is still executed
				return _testifyRun(c, bar)
			else
				return 1
			
		if firstLineInsensitive.startsWith('#.error.')
			# note that errors that are only detected by the backend C# compiler are not detectable by testify
			# CC: support split with a String extension method
			# error = firstLine.split('.error.',1)[1].trim.toLower
			index = firstLine.indexOf('.error.')
			error = firstLine.substring(index+7).trim.toLower
			try
				c = Compiler(compilerVerbosity, _cachedTestifyModules)
				c.testifyFilesNamed(fileNames, options, _resultsWriter to !, verbose)
			catch StopCompilation
				assert c.errors.count
				expectedErrors = error.split(c'&')
				for i = 0 .. expectedErrors.length
					expectedError = expectedErrors[i].trim
					print 'Expecting error substring [i+1] of [expectedErrors.length]: **[expectedError]**'
					if i >= c.errors.count
						print 'Ran out of real errors.'
						.failed
						return 0
					actualError = c.errors[i]
					if actualError.message.toLower.indexOf(expectedError)==-1
						print 'Actual error is: **[actualError.message]**'
						.failed
						return 0
					else
						print 'Matches: "[actualError.message]"'
				if c.errors.count > expectedErrors.length
					print 'There are more actual errors than expected errors:'
					for i = expectedErrors.length .. c.errors.count
						print 'Another actual error: [c.errors[i].message]'
					.failed
					return 0
			catch exc as Exception
				print 'Internal exception: [exc]'
				.failed
				return 0
			success
				print 'Expecting error(s): [error]'
				print 'No error at all.'
				if c.errors.count > 0
					print 'warning: error count > 0 but StopCompilation was not thrown'
				.failed
				return 0
			return 1

		if firstLineInsensitive.startsWith('#.warning.')
			index = firstLine.indexOf('.warning.')
			warning = firstLine.substring(index+9).trim.toLower
			# TODO: the following code both checks for warnings to be thrown as well as going through a list of warnings. Seems like it should just need to do one or the other.
			try
				c = Compiler(compilerVerbosity, _cachedTestifyModules)
				c.testifyFilesNamed(fileNames, options, _resultsWriter to !, verbose)
			catch StopCompilation
				print 'Expecting warning substring: "[warning]"'
				print 'But got errors.'
				.failed
				return 0
			catch exc as Exception
				print 'Internal exception: [exc]'
				.failed
				return 0
			expectedWarnings = warning.split(c'&')
			for i = 0 .. expectedWarnings.length
				expectedWarning = expectedWarnings[i].trim
				print 'Expecting warning substring [i+1] of [expectedWarnings.length]: **[expectedWarning]**'
				if i >= c.warnings.count
					print 'Ran out of real warnings.'
					.failed
					return 0
				actualWarning = c.warnings[i]
				if actualWarning.message.toLower.indexOf(expectedWarning)==-1
					print 'Actual warning is: **[actualWarning.message]**'
					.failed
					return 0
				else
					print 'Matches: "[actualWarning.message]"'
			if c.warnings.count > expectedWarnings.length
				print 'There are more actual warnings than expected warnings:'
				for i = expectedWarnings.length .. c.warnings.count
					print 'Another actual warning: [c.warnings[i].message]'
				.failed
				return 0
			return 1

		c = Compiler(compilerVerbosity, _cachedTestifyModules)
		
		try
			c.testifyFilesNamed(fileNames, options, _resultsWriter to !, verbose)
		catch StopCompilation
			.failed
			return 0
		catch exc as Exception
			print 'Internal exception: [exc]'
			.failed
			return 0

		if c.messages.count
			# can't be errors or StopCompilation would have been caught above
			print 'Unexpected warnings in test.'
			.failed
			return 0

		if willRunExe
			return _testifyRun(c, bar)
		else
			return 1
		
	def _testifyRun(c as Compiler, bar as String) as int
		if not c.fullExeFileName.endsWith('.exe')
			if File.exists(c.fullExeFileName)
				print 'Produced file "[c.fullExeFileName]" as expected.'
				return 1
			else
				print 'Did not produce file "[c.fullExeFileName]".'
				.failed
				return 0
		else
			print 'Run:'
			p = Process()
			if _verbosity >= 1
				print 'c.fullExeFileName = "[c.fullExeFileName]"'
			.setUpRunProcess(c, p)
			if _verbosity >= 2
				print '[p.startInfo.fileName] [p.startInfo.arguments]'
			output = CobraCore.runAndCaptureAllOutput(p).trim
		
			print 'Output:'
			if output.length
				print output
			if p.exitCode <> 0
				print 'Exit code = [p.exitCode]'
				.failed
				return 0
			if output.toLower.indexOf('unhandled exception') <> -1
				.failed
				return 0

		print bar

		_cachedTestifyModules = for mod in c.modules where mod inherits AssemblyModule get mod
		
		return 1

	def failed
		"""
		Produces output and increments the failure count,
		but does not throw an exception or exit.
		"""
		if _firstAttempt
			_statusWriter.writeLine('FAILURE ----------------------------------------------------------------------')
			_failureCount += 1
			print
			print
			print 'TEST FAILURE. SEE BELOW FOR VERBOSE RERUN.'

	def testifyFilePath(pathName as String) as int
		dirName = Path.getDirectoryName(pathName)
		baseName = Path.getFileName(pathName) to !
		assert dirName and dirName.length
		assert baseName.length
		saveDir = Environment.currentDirectory
		Directory.setCurrentDirectory(dirName)
		try
			return .testifyFile(baseName)
		finally
			Directory.setCurrentDirectory(saveDir)


class HtmlWriter
	inherits TextWriter
	"""
	In support of the output-html option.
	"""
	
	var _otherWriter as TextWriter
	var _isWritingHtml as bool
	
	def init(otherWriter as TextWriter)
		_otherWriter = otherWriter

	get encoding as Encoding? is override
		return Encoding.default

	def write(c as char) is override
		_otherWriter.write(c)
		if not _isWritingHtml and c == c'\n'
			_otherWriter.write('<br>')

	def writeHtml(html as String)
		_isWritingHtml = true
		try
			.write(html)
		finally
			_isWritingHtml = false


class Options
	inherits Dictionary<of String, Object>
	
	def init
		pass

	def init(d as IDictionary<of String, Object>)
		base.init(d)

	def boolValue(key as String) as bool
		if .containsKey(key)
			return this[key] to bool
		else
			return false

	def getDefault(key as String, default as dynamic?) as dynamic?
		if .containsKey(key)
			return this[key]
		else
			return default

	# CC: def getDefault<of T>(key as String, value as T) as T ...

	def combine(options as Options)
		if options is not this
			for key in options.keys
				this[key] = options[key]

	def print
		for key in .keys
			print '    [key]: [CobraCore.toTechString(this[key])]'

	get buildStandardLibrary as bool
		return .boolValue('build-standard-library')
