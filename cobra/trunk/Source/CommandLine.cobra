"""
Cobra Command Line Program (compiler and more)
"""

use System.Diagnostics


class CommandLine
	"""
	The main options that control the command line's behavior are:
		run
		test
		compile
		testify
		help

	"testify" is private to the implementor of Cobra.

	"run" is the default if none are specified and at least one path is provided.

	If no arguments are passed at all, "help" becomes the default.

	You need to put at least one dash in front of an option. Also, you can leave
	out the ".cobra" extension if you like. For example:

		cobra -compile foo bar

	"""

	get versionString as String is shared
		# Can't just take CobraCore.versionDescription as is, because that will be the one from Snapshot,
		# not the current Source directory. And Snapshot can be a final release such as '0.7.4' for a
		# period of time where this Cobra source represents an svn-post-RELEASE.
		return '0.8.0 post-release'

	var _optionSpecs as List<of Dictionary<of String, Object>>

	var _rawOptionSpecs = [
		{
			'name': 'about',
			'description': 'Print the name, copyright, etc. but no usage.',
			'type': 'main',
		},
		{
			'name': 'build-standard-library',
			'synonyms': ['bsl'],
			'description': 'Builds the standard library.',
			'type': 'main',
			'developer-only': true,
		},
		{
			'name': 'compile',
			'synonyms': ['c'],
			'description': 'Compile the library (to DLL) or the program (to EXE) without running the code.',
			'type': 'main',
		},
		{
			'name': 'color',
			'type': 'bool',
			'description': 'Colorizes the output of error messages and the messages "Compilation failed" and "Compilation succeeded" (as red, red and blue).',
		},
		{
			'name': 'contracts',
			'description': 'Control treatment of code generation for contracts.',
			'type': 'menu',
			'choices': ['none', 'inline', 'methods'],
			'args': 'none|inline|methods',
			'default': 'inline',
		},
		{
			'name': 'debug',
			'synonyms': ['d'],
			'type': 'string',
			'description': 'Turn on system debugging information. The value 1 implies full, which enables attaching a debugger to a running program. Turning on implies -debugging-tips:no.',
			'args': '0|1|pdbonly|full'
		},
		{
			'name': 'debugging-tips',
			'description': 'Display debugging tips when an unhandled exception occurs. Overridden by -exception-report.',
			'type': 'bool',
			'default': 'yes',
		},
		{
			'name': 'delay-sign',
			'type': 'bool',
			'description': 'Delay-sign the assembly using only the public portion of the strong name key.',
		},
		{
			'name': 'detailed-stack-trace',
			'synonyms': ['dst'],
			'type': 'bool',
			'description': 'Enable a detailed stack trace which gives great postmortem information for uncaught exceptions, but slows execution. Works in combination with -exception-report.',
		},
		{
			'name': 'embed-run-time',
			'synonyms': ['ert'],
			'type': 'bool',
			'default': 'yes',
			'description': 'Embed the Cobra run-time support code (approx. 80KB) in the assembly so that no reference to an external Cobra.Lang.dll is required. If set to "no" then you should copy Cobra.Lang.dll to your current directory and also notice faster compilation time.',
		},
		{
			'name': 'exception-report',
			'synonyms': ['exc-rpt', 'er'],
			'type': 'bool',
			'description': 'Turn on an informative HTML report that will be generated if the program throws an uncaught exception.',
		},
		{
			'name': 'files',
			'isAccumulator': true,
			'description': 'Specify the files for Cobra to process in a separate text file. One file per line; # comments and blank lines are ignored.',
			'args': 'filename',
		},
		{
			'name': 'editor',
			'description': 'Specify an editor and command line options to invoke if there is a compile-time error. Use underscore (_) for space in the specification. Can also set via COBRA_EDITOR environment variable (in which case spaces work fine).',
			'example': ['uedit32_FILE/LINE', 'mate_FILE_-l_LINE'],
			'args': 'editor_spec_with_FILE_LINE',
		},
		{
			'name': 'help',
			'synonyms': ['h'],
			'type': 'main',
			'description': 'Display this help message.',
		},
		{
			'name': 'include-asserts',
			'type': 'bool',
			'default': 'yes',
			'description': 'Include assert statements in the program.',
		},
		{
			'name': 'include-nil-checks',
			'type': 'bool',
			'default': 'yes',
			'description': 'Include checks on non-nilable class variables, method arguments and "to !" casts.',
		},
		{
			'name': 'include-tests',
			'type': 'bool',
			'default': 'yes',
			'description': 'Includes unit tests for classes and members in the output assembly.',
		},
		{
			'name': 'keep-intermediate-files',
			'synonyms': ['kif'],
			'type': 'bool',
			'description': 'Keeps any intermediate files that Cobra generates, which are normally deleted. Example intermediate files are *.cobra.cs.',
		},
		{
			'name': 'key-container',
			'type': 'string',
			'args': 'FILE',
			'description': 'Specify a strong name key container used to strongname the output assembly.',
		},
		{
			'name': 'key-file',
			'type': 'string',
			'args': 'FILE',
			'description': 'Specify a strong name key file used to sign the output assembly.',
		},
		{
			'name': 'library-directory',
			'synonyms': ['lib'],
			'type': 'string',
			'isAccumulator': true,
			'description': 'Specify additional directories to search in for references.',
			'args': 'PATH',
		},
		{
			'name': 'number',
			'type': 'menu',
			'choices': ['decimal', 'float', 'float32', 'float64'],
			'args': 'decimal|float|float32|float64',
			'default': 'decimal',
			'description': "Set the real numeric type for both the 'number' type and fractional literals such as '1.0'.",
		},
		{
			'name': 'optimize',
			'synonyms': ['o'],
			'type': 'bool',
			'description': 'Enable optimizations.',
		},
		{
			'name': 'output-html',
			'type': 'bool',
			'description': "The command line's output will be in HTML.",
		},
		{
			'name': 'pkg',
			'type': 'string',
			'isAccumulator': true,
			'description': 'References package via "pkg-config --libs". (Mono only.)',
			'args': 'NAME',
			'restriction': 'mono',
		},
		{
			'name': 'reference',
			'synonyms': ['r'],
			'isAccumulator': true,
			'description': 'Add a DLL reference.',
			'args': 'Some.dll',
		},
		{
			'name': 'reveal-internal-exceptions',
			'description': 'When true, uncaught exceptions from the Cobra compiler itself are not caught and wrapped in error messages. This is useful when developing on the Cobra compiler itself. Set to true if the environment variable COBRA_IS_DEV_MACHINE.',
			'type': 'bool',
			'developer-only': true,
		},
# TODO
#		{
#			'name': 'reflect',
#			'isAccumulator': true,
#			'description': 'Display the type interface in Cobra syntax. Use its fully qualified name.',
#			'args': ':Qualified.Type.Name',
#		},
		{
			'name': 'run',
			'description': 'Runs the Cobra program. This is the default behavior if specify any Cobra source files.',
			'type': 'main',
		},
		{
			'name': 'sharp-compiler',
			'description': 'Specify the path to the backend C# compiler.',
			'type': 'string',
			'args': 'file-system-path',
		},
		{
			'name': 'sharp-args',
			'description': 'Pass additional arguments to the backend C# compiler.',
			'type': 'string',
			'args': '"arg1 arg2"',
		},
		{
			'name': 'target',
			'description': 'Build a specific target.',
			'type': 'menu',
			'choices': ['exe', 'winexe', 'lib', 'module'],
			'args': 'exe|winexe|lib|module',
			'synonyms': ['t'],
		},
		{
			'name': 'test',
			'description': 'Run the unit tests in the code.',
			'type': 'main',
		},
		{
			'name': 'testify',
			'description': '...',
			'type': 'main',
			'developer-only': true,
		},
		{
			'name': 'timeit',
			'description': 'Gives the total duration of running cobra (including the target program, if it is to be run). This is "wall time", not "cpu time".',
			# although this option is implied by 'testify', the description does not say so, since 'testify' is a hidden option
			'type': 'bool',
		},
		{
			'name': 'turbo',
			'description': 'Maximum run-time performance. This is a convenience for -contracts:none -include-asserts:no -include-nil-checks:no -include-tests:no -optimize',
			'type': 'bool',
		},
		{
			'name': 'verbosity',
			'synonyms': ['verbose', 'v'],
			'type': 'int',
			'min': 0,
			'max': 5,
			'args': 'N',
			'description': 'Enable extra output from Cobra. Mostly useful for debugging Cobra and reporting problems. Values 0 - 5. Warning: Level 5 causes megabytes of output.',
		},
		{
			'name': 'version',
			'description': 'Print just the version number ([.versionString]).',
			'type': 'main',
		},
	]

	var _startTime as DateTime
	var _verbosity = 0

	var _options = Options()
	var _pathList as List<of String>?
	var _htmlWriter as HtmlWriter?

	var _compiler as Compiler?

	def init
		_startTime = DateTime.now
		# prep the option specs
		_optionSpecs = List<of Dictionary<of String, Object>>()
		for specObj in _rawOptionSpecs
			# since some _optionSpecs are Dictionary<of String, Object> and others are
			# Dictionary<of String, String> then _optionSpecs ends up being
			# Dictionary<of String, Object>

			if specObj inherits Dictionary<of String, Object>
				d = specObj
			else if specObj inherits Dictionary<of String, String>
				d = Dictionary<of String, Object>()
				for key in specObj.keys
					d[key] = specObj[key]
			else
				throw FallThroughException(specObj.getType)
			_optionSpecs.add(d)

	get compiler from var

	get options from var

	get verboseLineSeparator as String
		w = Console.bufferWidth
		if w < 20
			w = 80
		w -= 1
		return String(c'-', w)

	get verbosity as int
		return _verbosity

	def run
		"""
		Run the command line using the command line arguments.
		"""
		.run(CobraCore.commandLineArgs[1:])

	def run(args as List<of String>)
		"""
		Run the command line using the given arguments.
		The `args` should include only the arguments and not the executable/program name.
		"""
		if args.count == 0
			.doAbout
			return
		.parseArgs(args, out _options, out _pathList)
		if _options.boolValue('output-html')
			_htmlWriter = HtmlWriter(Console.out)
			dest = _htmlWriter to TextWriter
		else
			dest = Console.out
		if _htmlWriter
			stylePath = Path.combine(Path.getDirectoryName(CobraCore.exePath), 'styles-output-html.css')
			_htmlWriter.writeHtml('<html><head><link href="file://[stylePath]" rel=stylesheet type="text/css"></head><body>[_htmlWriter.newLine]')
		print to dest
			paths = _pathList to !
			options = _options
			if .verbosity > 0
				print 'Cobra Command Line [.versionString]'
				print 'Copyright (C) 2003-2008 by Cobra Language LLC.'
				print
				print 'OS Version:  ', Environment.osVersion
				print 'CLR Platform:', if(CobraCore.isRunningOnMono, 'Mono', '.NET')
				print 'CLR Version: ', Environment.version
				print 'Current Directory: [Environment.currentDirectory]'
				print 'Current Exe: [CobraCore.exePath]'
				print 'Option Dictionary:'
				options.print
				print 'Paths:'
				for path in paths
					print '    [path]'
			if options.boolValue('testify')
				.doTestify(paths)
			else if options.boolValue('run')
				.doRun(paths)
			else if options.boolValue('test')
				.doTest(paths)
			else if options.boolValue('compile')
				.doCompile(paths)
			else if options.boolValue('help')
				.doHelp
			else if options.boolValue('version')
				.doVersion
			else if options.boolValue('about')
				.doAbout
			else if options.boolValue('build-standard-library')
				.doBuildStandardLibrary
			else if not paths.count
				.doHelp
			else
				.doRun(paths)
		if _htmlWriter
			_htmlWriter.writeHtml('</body></html>[_htmlWriter.newLine]')

	def isOptionSpecRestrictionViolated(optionSpec as Dictionary<of String, Object>) as bool
		"""
		Returns true if the option spec has a 'restriction' key and the check against that restriction is true.
		"""
		if optionSpec.containsKey('restriction')
			branch optionSpec['restriction'] to String
				on 'mono-only'
					return not CobraCore.isRunningOnMono
		return false

	def parseArgs(args as IList<of String>, options as out Options?, paths as out List<of String>?)
		"""
		Parse command line arguments.
		The `args` should include only the arguments and not the executable/program name.
		"""
		ensure
			options
			paths
		body
			optionPrefix = '-'
			valuePrefix = c':'
			if not args.count
				options = Options()
				options.add('help', true)
				paths = List<of String>()
				return

			specDict = Dictionary<of String, Dictionary<of String, Object>>()
				# ^ will contain keys for all spec names and their synonyms
			synToName = Dictionary<of String, String>()
				# ^ maps synonyms to their full names
			synList = List<of String>()
			for d in _optionSpecs
				if .isOptionSpecRestrictionViolated(d)
					continue
				specDict[d['name'] to String] = d
				if d.containsKey('synonyms')
					syns = d['synonyms'] to System.Collections.IList
					for syn as String in syns
						assert not specDict.containsKey(syn)
						specDict[syn] = d
						synToName[syn] = d['name'] to String
						synList.add(syn)
				if not d.containsKey('type')
					d.add('type', 'string')

			# set up initial valueDict
			valueDict = Dictionary<of String, Object>()
			if Utils.isDevMachine
				valueDict['reveal-internal-exceptions'] = true  # this is a specially computed default, but can still be overridden on the command line

			fileList = List<of String>()
			value = 'no-value' to dynamic
			mainOptions = List<of String>()
			didSpecify = Dictionary<of String, bool>()  # CC: could just be a Set
			for arg in args
				if arg.trim.length == 0
					continue
				if arg.startsWith(optionPrefix)
					isOption = true
					while arg.startsWith(optionPrefix)
						arg = arg[1:]
				else
					isOption = false
				if isOption
					parts = arg.split(@[valuePrefix], 2)
					if parts.length == 1
						name = parts[0]
						if name.endsWith('+')
							name = name[:-1]
							valueStr = 'on'
						else if name.endsWith('-')
							name = name[:-1]
							valueStr = 'off'
						else
							valueStr = 'on'
					else
						assert parts.length == 2
						name = parts[0]
						valueStr = parts[1]
					assert name.length, parts
					name = Utils.getSS(synToName to passthrough, name, name) to !
					if not specDict.containsKey(name)
						msg = 'No such option "[name]".'
						if name.contains('=')
							msg += ' If you meant to specify an option value, use colon (:) instead of equals (=).'
						.error(msg)
					spec = specDict[name]
					if Utils.getSB(spec to passthrough, 'isAccumulator', false)
						# accumulators are always treated as strings. TODO: assert that
						if valueDict.containsKey(name)
							(valueDict[name] to System.Collections.IList).add(valueStr to passthrough)
						else
							valueDict[name] = [valueStr]
							didSpecify[name] = true
					else
						cannotProcess = false
						if name=='debug'
							# special case
							if valueStr=='pdbonly' or valueStr=='full'
								value = valueStr
							else
								try
									value = .boolForString(valueStr)
								catch FormatException
									cannotProcess = true
								success
									value = if(value, '+', '-')
						else
							if spec['type'] == 'main'
								mainOptions.add(name)
								value = true
							else
								possible = .interpretValue(valueStr, spec)
								if possible is not nil
									value = possible
								else
									cannotProcess = true
						if cannotProcess
							.error('Cannot process value "[valueStr]" for option "[name]".')
						valueDict[name] = value
						didSpecify[name] = true
				else # not isOption
					if File.exists(arg)
						fileList.add(arg)
					else if File.exists(arg+'.cobra')
						fileList.add(arg+'.cobra')
					else if Directory.exists(arg)
						fileList.add(arg)
					else
						msg = 'Cannot find "[arg]" as a file.'
						if arg.startsWith('/')
							msg += ' If you meant to specify an option, use dash (-) instead of slash (/).'
						.error(msg)

			# handle synonyms
			for syn in synList
				if valueDict.containsKey(syn)
					valueDict[synToName[syn]] = valueDict[syn]
					valueDict.remove(syn)

			# add in defaults
			for d in _optionSpecs
				defaultName = d['name'] to String
				if not valueDict.containsKey(defaultName) and d.containsKey('default')
					defaultValue = .interpretValue(d['default'] to String, d) to !
					if .verbosity
						print 'Setting option "[defaultName]" to default value [defaultValue].'
					valueDict[defaultName] = defaultValue

			# TODO: make the option names case-insensitive

			# check for more than one main option
			if mainOptions.count > 1
				.error('Cannot have these main options at the same time: [Utils.join(", ", mainOptions)]')

			# unpack certain options into specific class fields
			if valueDict.containsKey('verbosity')
				_verbosity = valueDict['verbosity'] to int
			if not valueDict.containsKey('timeit') and valueDict.containsKey('testify')
				valueDict['timeit'] = true
			if valueDict.containsKey('timeit')
				CobraMain.willTimeIt = valueDict['timeit'] to bool
			if valueDict.containsKey('files')
				for fileName as String in valueDict['files'] to System.Collections.IList
					try
						for line in File.readAllLines(fileName)
							line = line.trim
							if line.length==0 or line.startsWith('#')
								continue
							# TODO: dup'ed above
							arg = line
							if File.exists(arg)
								fileList.add(arg)
							else if File.exists(arg+'.cobra')
								fileList.add(arg+'.cobra')
							else if Directory.exists(arg)
								fileList.add(arg)
							else
								msg = 'Cannot find "[arg]" as a file.'
								#if arg.startsWith('/')
								#	msg += ' If you meant to specify an option, use dash (-) instead of slash (/).'
								.error(msg)
							# end dup
					catch IOException
						.error('Cannot open file "[fileName]".')

			# set the out parameters
			options = Options(valueDict)
			for name in didSpecify.keys
				options.didSpecify(name)
			paths = fileList

			.computeArgImplications(options to !)


	def computeArgImplications(options as Options)
		if options.getDefault('target', '') == 'lib' and not options.isSpecified('compile')
			options['compile'] = true
		if options.getDefault('debug', '') not in ['', '0', '-'] and not options.isSpecified('debugging-tips')
			options['debugging-tips'] = false
		if options.boolValue('turbo')
			options['contracts'] = 'none'
			options['include-asserts'] = false
			options['include-nil-checks'] = false
			options['include-tests'] = false
			options['optimize'] = true

	def interpretValue(valueStr as String, spec as Dictionary<of String, Object>) as dynamic?
		value as dynamic?
		branch spec['type'] to String
			on 'main'
				throw InvalidOperationException('This method does not handle the main type.')
			on 'bool'
				try
					value = .boolForString(valueStr)
				catch FormatException
					cannotProcess = true
			on 'int'
				if valueStr == 'on'  # set internally when there is no value
					valueStr = '1'
				try
					value = int.parse(valueStr)
				catch FormatException
					cannotProcess = true
				catch OverflowException
					cannotProcess = true
				# TODO: check min and max
			on 'string'
				value = valueStr
			on 'menu'
				if valueStr.length==0
					cannotProcess = true
				if not (spec['choices'] to System.Collections.IList).contains(valueStr)
					cannotProcess = true
				else
					value = valueStr
		r = if(cannotProcess, nil, value)
		return r

	def doCompile(paths as List<of String>) as Compiler
		return .doCompile(paths, true, false)

	def doCompile(paths as List<of String>, willPrintSuccessMsg as bool, writeTestInvocation as bool) as Compiler
		oldPaths = List<of String>(paths)
		paths.clear
		for path in oldPaths
			if File.exists(path)
				paths.add(path)
			else if Directory.exists(path)
				.error('Cannot process directories in general ("[path]").')
			else
				.error('Cannot find file "[path]".')
		if paths.count == 0 and not .options.buildStandardLibrary
			.error('No files to process.')
		_compiler = c = Compiler(.verbosity)
		c.options = _options
		c.willPrintSuccessMsg = willPrintSuccessMsg
		c.htmlWriter = _htmlWriter
		try
			c.compileFilesNamed(paths, writeTestInvocation)
		catch StopCompilation
			# Each phase of the compiler may throw an exception to stop compilation.
			# Before doing so, it prints its errors.
			assert c.errors.count>0
			if _options.containsKey('editor')
				spec = _options['editor'] to String?
			else
				spec = Environment.getEnvironmentVariable('COBRA_EDITOR')
			if spec and spec <> ''
				if spec.indexOf('FILE')==-1
					.error('Missing FILE from editor spec.')
				if spec.indexOf('LINE')==-1
					.error('Missing LINE from editor spec.')
				i = spec.indexOf('_')
				if i == -1
					i = spec.indexOf(' ')
					if i == -1
						.error('Missing underscore or space from editor spec.')
				exeName = spec.substring(0, i)
				args = spec.substring(i+1)
				for error in c.errors
					if error.isError and error.hasSourceSite
						if error.fileName.trim <> ''
							# trace error.fileName, error.lineNum
							args = args.replace('FILE', error.fileName)
							args = args.replace('LINE', error.lineNum.toString)
							p = System.Diagnostics.Process()
							p.startInfo.fileName = exeName
							p.startInfo.arguments = args
							p.startInfo.useShellExecute = false
							if _verbosity >= 3
								print 'Running: [p.startInfo.fileName] [p.startInfo.arguments]'
							try
								p.start
								p.waitForExit  # TODO: is this really needed?
							catch exc as Exception
								print 'Cannot invoke editor:'
								print '    Command: [p.startInfo.fileName] [p.startInfo.arguments]'
								print '    Exception: [exc]'
							break
		return c

	def doTest(paths as List<of String>)
		if paths.count == 0
			.error('You must specify one or more Cobra files to run unit tests for.')
		c = .doCompile(paths, false, true)
		if c.errors.count
			print 'Not running tests due to errors above.'
			return
		testInvoker = c.modules[c.modules.count-1]  # CC: .last
		assert testInvoker inherits SharpModule
		assert testInvoker.fileName.startsWith('test-')
		File.delete(testInvoker.fileName)
		try
			p = c.runProcess
			if _verbosity >= 1
				print 'Running: [p.startInfo.fileName] [p.startInfo.arguments]'
				print .verboseLineSeparator
			p.startInfo.useShellExecute = false
			p.start
			p.waitForExit  # TODO: is this necessary?
		catch
			File.delete(c.fullExeFileName)
			throw
		success
			File.delete(c.fullExeFileName)

	def doRun(paths as List<of String>)
		c = .doCompile(paths, false, false)
		if c.errors.count
			print 'Not running due to errors above.'
		else
			p = c.runProcess
			if _verbosity >= 1
				print 'Running: [p.startInfo.fileName] [p.startInfo.arguments]'
				print .verboseLineSeparator
			p.startInfo.useShellExecute = false
			p.start
			p.waitForExit  # TODO: is this necessary?

	def doHelp
		# CC: multiline string
		.doAbout
		print ''
		print 'Usage:'
		print ''
		print '  cobra <options> <filename>'
		print '    * run filename'
		print '    * compile if needed'
		print '    * .cobra extension is optional'
		print ''
		print '  cobra <options> <command> <path(s)>'
		print '    * commands that operate on path(s) are:'
		print '      -compile ... Compile only.'
		print '      -run ....... Run the program (compile if necessary).'
		print '      -test ...... Run the unit tests of a library.'
		print ''
		print '  cobra <options> <command>'
		print '    * standalone commands are:'
		print '      -help ...... Print full help information.'
		print '      -about ..... Print name, copyright, etc. no usage.'
		print '      -version ... Print just the version number ([.versionString]).'
		print ''
		print '  <options> can be:'

		# print options from their specs (but not the main ones which are covered above)
		leftMargin = 8
		leftMarginStr = '        '
		try
			consoleWidth = Console.windowWidth
		catch IOException
			# 2008-04-11, When redirecting output, MS .NET 2.0 throws IOException while Novell Mono 1.9 returns 0
			consoleWidth = 0
		if consoleWidth < 1
			try
				consoleWidth = Console.bufferWidth
			catch IOException
				consoleWidth = 0
		totalWidth = consoleWidth - 2
		if totalWidth < 0
			totalWidth = 0
		if totalWidth == 0
			totalWidth = 78
		else if totalWidth < 20
			totalWidth = 20
		assert totalWidth > 0
		width = totalWidth - leftMargin
		assert width > 0
		for spec in _optionSpecs
			if spec.containsKey('type') and spec['type']=='main' # CC: spec.get('main', '')
				continue
			if spec.containsKey('developer-only') and spec['developer-only'] to bool and not Utils.isDevMachine
				continue
			if .isOptionSpecRestrictionViolated(spec)
				continue
			print
			print '    -[spec["name"]]' stop
			if spec.containsKey('args')
				if spec.containsKey('default')
					lbracket = r'['
					print '[lbracket]:[spec["args"]]]' stop
				else
					print ':[spec["args"]]' stop
			else if spec['type']=='bool'
				print r'[:no|yes]' stop
			if spec.containsKey('default')
				print '  default is [spec['default']]' stop
			print
			if spec.containsKey('synonyms')
				print '    ' stop
				sep = ''
				for syn as String in spec['synonyms'] to System.Collections.IList
					print '[sep]-[syn]' stop
					sep = ', '
				print
			s = spec['description'] to String
			while s.length
				if s.length < width
					print '[leftMarginStr][s]'
					s = ''
				else
					# TODO: bug in here for narrow widths. try "width = 20" to reproduce
					j = width+1
					if j >= s.length
						j = s.length - 1
					while j > 0 and s[j] <> ' '
						j -= 1
					if j
						sub = s.substring(0, j)
						s = if(s.length, s.substring(j+1), '')
						print '[leftMarginStr][sub]'
			if spec.containsKey('example')
				if spec['example'] inherits System.Collections.IList
					first = true
					for example in spec['example'] to System.Collections.IList
						if first
							print '        Examples: ' stop
						else
							print '                  ' stop
						print '-[spec["name"]]:[example]'
						first = false
				else
					print '        Example: -[spec["name"]]:[spec["example"]]'

	def doAbout
		# CC: multiline string
		print 'The Cobra Programming Language [.versionString]'
		print 'Copyright (C) 2003-[DateTime.now.year] by Cobra Language LLC.  All Rights Reserved.'
		print ''
		print 'On the web:  http://Cobra-Language.com/'
		print 'License:     See Cobra/Docs/License.text'
		# TODO: print '             http://Cobra-Language.com/Docs/License.text'
		print 'Usage:       cobra -h'

	def doVersion
		print .versionString

	def boolForString(s as String) as bool
		if s.toLower in ['', '+', 'on', 'true', 't', 'yes', 'y', '1']
			return true
		else if s.toLower in ['-', 'off', 'false', 'f', 'no', 'n', '0']
			return false
		else
			throw FormatException()

	## Self Services

	def error(msg as String)
		if msg.length
			print 'cobra: error: [msg]'
			print 'Run Cobra without options to get full usage information.'
		Environment.exit(1)


	## Build Standard Library

	def doBuildStandardLibrary
		v = .verbosity
		if v
			print 'Building standard library'
		dllInfo = FileInfo('Cobra.Lang.dll')
		if dllInfo.exists
			if v
				print 'Renaming Cobra.Lang.dll to Cobra.Lang-previous.dll'
			prevInfo = FileInfo('Cobra.Lang-previous.dll')
			if prevInfo.exists
				prevInfo.delete
			FileInfo('Cobra.Lang.dll').moveTo('Cobra.Lang-previous.dll')
		_options['target'] = 'lib'
		_options['include-tests'] = false  # TODO: including tests in a DLL tends to cause problems. it might be because tests are triggered by type initializers. this needs investigation
		_options['embed-run-time'] = true  # because the runtime is what we're building!
		.doCompile(List<of String>(), true, false)


	## Testify

	def doTestify(paths as List<of String>)
		"""
		Used internally for testing cobra during development.
		Why not just 'test'? because that is reserved for regular developers to run true unit tests.
		"""
		TestifyRunner(_startTime, this, paths).run


class HtmlWriter
	inherits TextWriter
	"""
	In support of the output-html option.
	"""

	var _otherWriter as TextWriter
	var _isWritingHtml as bool

	def init(otherWriter as TextWriter)
		_otherWriter = otherWriter

	get encoding as Encoding? is override
		return Encoding.default

	def write(c as char) is override
		_otherWriter.write(c)
		if not _isWritingHtml and c == c'\n'
			_otherWriter.write('<br>')

	def writeHtml(html as String)
		_isWritingHtml = true
		try
			.write(html)
		finally
			_isWritingHtml = false


class Options
	inherits Dictionary<of String, Object>

	var _isSpecified = Dictionary<of String, bool>()  # CC: could just be a Set

	def init
		pass

	def init(d as IDictionary<of String, Object>)
		base.init(d)

	def isSpecified(name as String) as bool
		"""
		Returns true if the given option name is explicitly specified (as opposed to being present
		in the options dictionary due to having a default value).
		"""
		return _isSpecified.containsKey(name)

	def didSpecify(name as String)
		_isSpecified[name] = true

	def boolValue(key as String) as bool
		if .containsKey(key)
			return this[key] to bool
		else
			return false

	def getDefault(key as String, default as dynamic?) as dynamic?
		if .containsKey(key)
			return this[key]
		else
			return default

	# CC: def getDefault<of T>(key as String, value as T) as T ...

	def combine(options as Options)
		if options is not this
			for key in options.keys
				this[key] = options[key]

	def print
		for key in .keys
			print '    [key]: [CobraCore.toTechString(this[key])]'

	get buildStandardLibrary as bool
		return .boolValue('build-standard-library')
