class BinaryOpExpr
	is abstract
	inherits Expr

	shared
		def make(opToken as IToken, op as String, left as Expr, right as Expr) as BinaryOpExpr
			"""
			Instantiates the correct class for the given operator and returns it.
			"""
			branch op
				on 'TO'
					return ToExpr(opToken, op, left, right)
				on 'TOQ'
					return ToQExpr(opToken, op, left, right)
				on 'QUESTION'
					return CoalesceExpr(opToken, op, left, right)
				on 'QUESTION_EQUALS'
					return CoalesceAssignExpr(opToken, op, left, right)
				on 'BANG'
					return InverseCoalesceExpr(opToken, op, left, right)
				on 'BANG_EQUALS'
					return InverseCoalesceAssignExpr(opToken, op, left, right)
				on 'ASSIGN'
					return AssignExpr(opToken, op, left, right)
				on 'DOT'
					return DotExpr(opToken, op, left, right)
				on 'INHERITS', 'IMPLEMENTS'
					return InheritsExpr(opToken, op, left, right)
				on 'IN', 'NOTIN'
					return InExpr(opToken, op, left, right)
				on 'IS', 'ISNOT', 'EQ', 'NE', 'LT', 'GT', 'LE', 'GE'
					return CompareExpr(opToken, op, left, right)
				on 'AND', 'OR', 'IMPLIES'
					return BinaryBoolExpr(opToken, op, left, right)
				on 'PLUS', 'MINUS', 'STAR', 'STARSTAR', 'SLASH', 'SLASHSLASH', 'PERCENT'
					return BinaryMathExpr(opToken, op, left, right)
				on 'PLUS_EQUALS', 'MINUS_EQUALS', 'STAR_EQUALS', 'STARSTAR_EQUALS', 'SLASH_EQUALS', 'SLASHSLASH_EQUALS', 'PERCENT_EQUALS'
					return AugAssignMathExpr(opToken, op, left, right)
				else
					throw FallThroughException([opToken, op, left, right])

	var _op as String
	var _left as Expr
	var _right as Expr
	var _definition as IMember?

	def init(opToken as IToken, op as String, left as Expr, right as Expr)
		base.init(opToken)
		_op = op
		_left = left
		_left.superNode = this
		_right = right
		_right.superNode = this

	get op from var

	get left from var

	get right from var

	pro definition from var

	get hasError as bool
		if base.hasError
			return true
		if _left.hasError
			return true
		if _right.hasError
			return true
		return false

	def bindImp as INode
		base.bindImp
		assert .didBindImp
		# TODO: maybe checks should only be invoked if left and right were bound without error
		.checkAfterBindImp
		.checkForVoids
		return this

	def _bindImp
		base._bindImp
		assert _left is not this, this
		assert _right is not this, this
		# The try..catch below enables errors to be detected on both sides of the operator
		try
			_left.bindImp
		catch ne1 as NodeException
			gotError = true
			if _left.type is nil
				_left.type = .compiler.passThroughType
		try
			_right.bindImp
		catch ne2 as NodeException
			gotError = true
			if _right.type is nil
				_right.type = .compiler.passThroughType
		if gotError
			_type = .compiler.passThroughType
			throw NodeMultiException(ne1, ne2)
		assert _left.didBindImp
		assert _right.didBindImp

	def checkAfterBindImp
		"""
		Invoked after `bindImp` in order to do more error checking.
		So this is a hook for subclasses to do error checking after
		left and right have been successfully bound.
		"""
		require .didBindImp
		pass

	def checkForVoids
		left = _left
		right = _right
		voidType = .compiler.voidType
		# check for void on either side of the expression
		sugg = 'Use a different method or change that method to return something.'
		if left.type is voidType
			if left inherits BinaryOpExpr and (left to BinaryOpExpr).op=='DOT' and (left to BinaryOpExpr).right inherits CallExpr  # CC: axe casts
				append = ' because "[((left to BinaryOpExpr).right to CallExpr).name]" does not return anything.'  # CC: axe BinaryOp cast
			else
				append = '.'
			.throwError('There is no type for the left hand side of "[.token.text]"[append] [sugg]')
		if right.type is voidType and not right.isCalling
			if right inherits BinaryOpExpr and (right to BinaryOpExpr).op=='DOT' and (right to BinaryOpExpr).right inherits CallExpr  # CC: axe cast
				append = ' because "[((right to BinaryOpExpr).right to CallExpr).name]" does not return anything.'  # CC: axe BinaryOp cast
			else
				append = '.'
			.throwError('There is no type for the right hand side of "[.token.text]"[append] [sugg]')

	def addRefFields
		base.addRefFields
		.addField('definition', _definition)

	def addSubFields
		base.addSubFields
		.addField('op', _op)
		.addField('left', _left)
		.addField('right', _right)

	def toCobraSource as String is override
		return '([_left.toCobraSource] [.token.text] [_right.toCobraSource])'

	def writeSharpDef(sw as SharpWriter, parens as bool) is override
		if parens
			sw.write('(')
		_writeSharpDef(sw)
		if parens
			sw.write(')')

	def _writeSharpDef(sw as SharpWriter)
		pass

	def writeSharpBreakdownItems(sw as SharpWriter)
		base.writeSharpBreakdownItems(sw)
		_writeSharpBreakdownItemsLeft(sw)
		_writeSharpBreakdownItemsRight(sw)

	def _writeSharpBreakdownItemsLeft(sw as SharpWriter)
		_left.writeSharpBreakdownItems(sw)

	def _writeSharpBreakdownItemsRight(sw as SharpWriter)
		_right.writeSharpBreakdownItems(sw)


class AbstractAssignExpr
	inherits BinaryOpExpr
	"""
	The abstract base class for AssignExpr and AugAssignExpr.
	"""

	var _trackLocal as bool  # for the detailed stack trace
	var _trackName as String?

	def init(opToken as IToken, op as String, left as Expr, right as Expr)
		base.init(opToken, op, left, right)

	def checkAfterBindImp
		base.checkAfterBindImp
		# can't do the following in a `_bindImp` override since type inference is implemented in
		# a subclass (_left may not have its _definition until after that executes)
		if .compiler.willTrackLocals
			if _left inherits NameExpr
				_trackLocal = _left.definition inherits AbstractLocalVar
				if _trackLocal
					_trackName  = _left.definition.name

	def writeSharpDef(sw as SharpWriter, parens as bool) is override
		if _trackLocal
			sw.write('CobraImp.SetLocal("[_trackName]", ')
		else if parens
			sw.write('(')
		_writeSharpDef(sw)
		if _trackLocal or parens
			sw.write(')')


class AssignExpr
	inherits AbstractAssignExpr

	var _backUpIfInheritsStack as List<of IType>?

	def init(opToken as IToken, op as String, left as Expr, right as Expr)
		base.init(opToken, op, left, right)

	def _bindImp
		left = _left
		right = _right
		try
			base._bindImp
		catch NodeMultiException   # TODO: try non multi error instead
			# for a type inference situation, create a var of type passthrough for the left hand side
			# to prevent superfluous errors in subsequent statements
			if left inherits IdentifierExpr
				if left.definition is nil
					definition = LocalVar(left.token, .compiler.passThroughType).bindAll to LocalVar  # CC: axe cast when supporting 'as this'
					.compiler.codeMemberStack.peek.addLocal(definition)
					left.setDefinition(definition)
					left.type = definition.type
			if _type is nil
				_type = .compiler.passThroughType
			throw
		assert right.type
		if left inherits IdentifierExpr
			if left.definition is nil
				# type inference
				assert right.type
				if right.type is .compiler.passThroughType  # TODO: ? change to unspecifiedType
					if right.hasError
						# for a type inference situation, create a var of type passthrough for the left hand side
						# to prevent superfluous errors in subsequent statements
						definition = LocalVar(left.token, .compiler.passThroughType).bindAll to LocalVar  # CC: axe cast when supporting 'as this'
						.compiler.codeMemberStack.peek.addLocal(definition)
						left.setDefinition(definition)
						left.type = definition.type
						_type = left.type
						return
					else
						.throwError('Cannot infer type for "[left.name]" because the type of the right hand expression is unknown.')
				if left.name.startsWith('_')
					.throwError('No class variable named "[left.name]" exists and local variable declarations cannot start with an underscore (_).')
				inferredType = if(right.type inherits NilType, NilableType(.compiler.dynamicType), right.type)  # `x = nil` for a new local var `x` is inferred as `dynamic?`
				definition = LocalVar(left.token, inferredType).bindAll to LocalVar  # CC: axe cast when supporting 'as this'
				.compiler.codeMemberStack.peek.addLocal(definition)
				left.setDefinition(definition)
				left.type = definition.type
			if left.definition is nil
				left.errorUnknownId(left.name)
		if not right.canBeAssignedTo(left.type to !)
			okay = false
			if left inherits IdentifierExpr
				if (defi = left.definition) inherits IVar
					if defi.attemptAssignmentOf(right.type to !)
						_backUpIfInheritsStack = List<of IType>(defi.ifInheritsStack)  # will need this later for code gen
						okay = true
			if not okay
				.throwError('Incompatible types. Cannot assign value of type [right.type.name] on the right to [left.type.name] on the left.')
		_type = left.type
		right.contextType = _type

	def checkAfterBindImp
		base.checkAfterBindImp
		if _left inherits IdentifierExpr
			assert _left.definition
			if _left.definition inherits Param
				if _right inherits IdentifierExpr
					if _right.definition inherits BoxVar
						# the exception to this warning is when the statement is guarded by an if which references the _left.definition, as in: if param is nil; param = _param
						# TODO: this has a test case that generates no warnings. so the cobra test cases should probably barf on unexpected warnings
						isException = false
						if .parent inherits BlockStmt and (.parent to BlockStmt).parent inherits IfStmt
							ifStmt = (.parent to BlockStmt).parent to IfStmt
							if (bop = ifStmt.cond) inherits BinaryOpExpr
								if (bop.left inherits NameExpr) and (bop.left to NameExpr).definition is _left.definition
									isException = true
								if (bop.right inherits NameExpr) and (bop.right to NameExpr).definition is _right.definition
									isException = true
						if not isException
							leftName = (_left.definition to Param).name
							rightName = (_right.definition to BoxVar).name
							.compiler.warning(this, 'Setting a parameter ("[leftName]") to a class variable ("[rightName]") is often a mistake. You may want to reverse the assignment.')

	def _writeSharpDef(sw as SharpWriter) is override
		# TODO:
		# if trackLocal:
		#	out.write('CobraImp.SetLocal("%s", ' % .left.name)
		if _left inherits IndexExpr
			if _left.target.type.isDynamic
				# assigning to an indexer of a dynamically typed target requires special code gen
				sw.write('CobraImp.SetIndexerValue(')
				_left.target.writeSharpDef(sw, false)
				sw.write(', ')
				_right.writeSharpDef(sw, false)
				for expr in _left.args
					sw.write(', ')
					expr.writeSharpDef(sw, false)
				sw.write(')')
				return
		handled = false
		if _left inherits IdentifierExpr
			sharpNames = _left.sharpAssignmentNames
			if sharpNames and sharpNames.count
				sharpNames.reverse
				for i = 0 .. sharpNames.count
					sw.write(if(i==0, '', '='))
					assert sharpNames[i].length
					sw.write(sharpNames[i])
			else
				assert _left.sharpName <> ''
				sw.write(_left.sharpName)
			handled = true
		if not handled
			# `obj.foo = bar` where `obj` is dynamic, requires special handling
			if _left inherits DotExpr
				if _left.left.type.isDynamic
					assert _left.right inherits MemberExpr
					sw.write('CobraImp.SetPropertyValue(')
					_left.left.writeSharpDef(sw, false)
					sw.write(', ')
					sw.write(Utils.sharpStringLiteralFor(Utils.capped((_left.right to MemberExpr).name)))
					sw.write(', ')
					_right.writeSharpDef(sw)
					sw.write(')')
					return
		if not handled
			# for something like "p.total = 0", cannot generate "(p.Total)=0" because then C# sees
			# the left hand side as an r-value instead an l-value/target. hence the false below.
			_left.writeSharpDef(sw, false)
		sw.write('=')
		_right.writeSharpDefInContext(sw)
		# handle the case where a type got backed up because of assignment inside of an if-inherits
		if _backUpIfInheritsStack
			assert (_left to dynamic).definition inherits IVar
			(_left to dynamic).definition.ifInheritsStack = Stack<of IType>(_backUpIfInheritsStack)


class NumericPromoExpr
	inherits BinaryOpExpr

	def init(opToken as IToken, op as String, left as Expr, right as Expr)
		base.init(opToken, op, left, right)

	def _bindImp
		base._bindImp
		if _left.type.isDynamic or _right.type.isDynamic
			_type = .compiler.dynamicType
			return
		tint = .compiler.intType
		tdecimal = .compiler.decimalType
		tfloat = .compiler.floatType
		tpassthrough = .compiler.passThroughType
		tstring = .compiler.libraryType('System.String')
		cannotMix = false
		leftType = _left.type
		if leftType inherits NilableType
			leftType = leftType.theWrappedType
		rightType = _right.type
		if rightType inherits NilableType
			rightType = rightType.theWrappedType
		if leftType.isDescendantOf(tint)
			if rightType.isDescendantOf(tint)
				# special case: true division
				# if both sides are ints, the type becomes decimal
				if _op=='SLASH'
					_type = tdecimal
				else
					_type = tint
			else if rightType.isDescendantOf(tdecimal)
				_type = tdecimal
			else if rightType.isDescendantOf(tfloat)
				_type = tfloat
		else if leftType.isDescendantOf(tdecimal)
			if rightType.isDescendantOf(tdecimal)
				_type = tdecimal
			else if rightType.isDescendantOf(tint)
				_type = tdecimal
			else if rightType.isDescendantOf(tfloat)
				cannotMix = true
			else
				cannotMix = true
		else if leftType.isDescendantOf(tfloat)
			if rightType.isDescendantOf(tfloat)
				_type = tfloat
			else if rightType.isDescendantOf(tint)
				_type = tfloat
			else if rightType.isDescendantOf(tdecimal)
				cannotMix = true
			else
				cannotMix = true
		else if leftType.isDescendantOf(tstring)
			if rightType.isDescendantOf(tstring)
				_type = tstring
			else
				cannotMix = true
		if _left.isKindOf(tpassthrough) and not _right.isKindOf(tpassthrough)
			_type = rightType
		else if _right.isKindOf(tpassthrough) and not _left.isKindOf(tpassthrough)
			_type = leftType
		else if _left.isKindOf(tpassthrough) or _right.isKindOf(tpassthrough)
			_type = tpassthrough
		else if cannotMix
			.throwError('Cannot mix types [_left.type.name] and [_right.type.name] for arithmetic.')
		if _type is nil
			sugg = 'Try finding a method that performs this function.'
			if leftType == rightType
				.throwError('Cannot apply [_op] to [leftType.name]. [sugg]')
			else
				.throwError('Cannot apply [_op] to [leftType.name] and [rightType.name]. [sugg]')


class AugAssignMathExpr
	inherits NumericPromoExpr
	"""
	How should:
		someInt /= someInt
	be handled given that
		someInt / someInt
	gives a decimal?
	"""

	# TODO: does not inherit AbstractAssignExpr. Does not participate in super stack trace

	def init(opToken as IToken, op as String, left as Expr, right as Expr)
		base.init(opToken, op, left, right)
		assert op in ['PLUS_EQUALS', 'MINUS_EQUALS', 'STAR_EQUALS', 'STARSTAR_EQUALS', 'SLASH_EQUALS', 'SLASHSLASH_EQUALS', 'PERCENT_EQUALS']

	def _bindImp
		base._bindImp
		# TODO: does NumericPromoExpr cover everything we need?

	def _writeSharpDef(sw as SharpWriter) is override
		if _left.type.isDynamic
			_left.writeSharpDef(sw)
			sw.write(' = ')
			specs = OperatorSpecs.binaryOpSpecsByCobraText
			assert specs.containsKey(.token.text)
			spec = specs[.token.text]
			opText = Utils.sharpStringLiteralFor(spec.opMethodName)
			sw.write('CobraImp.DynamicOp([opText], ')
			_left.writeSharpDef(sw)  # TODO: add , false
			sw.write(', ')
			_right.writeSharpDef(sw)  # TODO: add , false
			sw.write(')')
			return
		op = ''
		sep = ','  # for the method call case
		branch _op
			on 'PLUS_EQUALS'
				op = '+='
			on 'MINUS_EQUALS'
				op = '-='
			on 'STAR_EQUALS'
				op = '*='
			on 'STARSTAR_EQUALS'
				op = 'CobraImp.PowerToEquals('
			on 'SLASH_EQUALS'
				op = '/='  # TODO: finish this
			on 'SLASHSLASH_EQUALS'
				op = '/='  # TODO: finish this
			on 'PERCENT_EQUALS'
				op = '%='
			else
				throw FallThroughException(_op)
		assert op.length
		if op.length==2
			_left.writeSharpDef(sw)
			sw.write(op)
			_right.writeSharpDef(sw)
		else
			sw.write(op)  # ex: 'CobraImp.Foo('
			_left.writeSharpDef(sw)
			sw.write(sep)
			_right.writeSharpDef(sw)
			sw.write(')')


class BinaryBoolExpr
	inherits BinaryOpExpr

	def init(opToken as IToken, op as String, left as Expr, right as Expr)
		base.init(opToken, op, left, right)
		assert op in ['AND', 'OR', 'IMPLIES']

	def _bindImp
		base._bindImp
		_type = .compiler.boolType
		if _left.type is not .compiler.boolType
			_left = TruthExpr(_left).bindImp to TruthExpr # CC: axe cast after "as this"
		if _right.type is not .compiler.boolType
			_right = TruthExpr(_right).bindImp to TruthExpr # CC: axe cast after "as this"

	def _writeSharpDef(sw as SharpWriter) is override
		if _op=='IMPLIES'
			sw.write('!')
		_left.writeSharpDef(sw)
		branch _op
			on 'AND'
				sw.write('&&')
			on 'OR', 'IMPLIES'
				sw.write('||')
		_right.writeSharpDef(sw)

	def _writeSharpBreakdownItemsRight(sw as SharpWriter) is override
		# have to respect the short circuit otherwise something like "s and s.length" will give
		# NullReference exception for "s.length"
		# solution is: given L and R,
		# write:   "R", (!(L) ? "short-circuted" : (R).ToString())
		# that's for 'AND'. for, 'OR', remove the !, for 'IMPLIES' it's like AND

		# so rather than:
		# _right.writeSharpBreakdownItems(sw)
		# do this:
		src = Utils.sharpStringLiteralFor(_right.toCobraSource)
		sharpNot = if(_op=='OR', '', '!')
		sw.write(', [src], new CobraDirectString([sharpNot]')
		_left.writeSharpDefForBreakdown(sw)
		sw.write(' ? "(short-circuited)" : CobraCore.ToTechString(')
		_right.writeSharpDefForBreakdown(sw)
		sw.write('))')


class BinaryMathExpr
	inherits NumericPromoExpr

	def init(opToken as IToken, op as String, left as Expr, right as Expr)
		base.init(opToken, op, left, right)
		assert op in ['PLUS', 'MINUS', 'STAR', 'SLASH', 'SLASHSLASH', 'PERCENT']

	def _bindImp # TODO: this is all messed up. does this get called? TODO: this is missing, so its not being run. resolve with base class: is override
		base._bindImp
		lt = _left.type
		if lt inherits NilableType
			lt = lt.theWrappedType
		rt = _right.type
		if rt inherits NilableType
			rt = rt.theWrappedType
		if lt is rt
			assert _type == lt or (_type is .compiler.decimalType and _op=='SLASH')
		else if lt.isDynamic or rt.isDynamic
			_type = .compiler.dynamicType
		else if lt inherits PassThroughType
			_type = rt
		else if rt inherits PassThroughType
			_type = lt
		else
			# TODO: this will need to be more sophisticated in the future with different sized ints and floats
			if lt.isDescendantOf(.compiler.intType)
				_type = rt
			else if rt.isDescendantOf(.compiler.intType)
				_type = lt
			else if lt.isDescendantOf(.compiler.decimalType)
				if rt.isDescendantOf(.compiler.floatType)
					.throwError('Cannot promote between decimal and float for operator "[_op]". Decimal is more accurate and float has more range.')
				else
					# int case already taken care of, so...
					.throwError('Cannot promote between decimal and "[rt.name]".')
			else if lt.isDescendantOf(.compiler.floatType)
				if rt.isDescendantOf(.compiler.decimalType)
					.throwError('Cannot promote between float and decimal for operator "[_op]". Decimal is more accurate and float has more range.')
				else
					# int case already taken care of, so...
					.throwError('Cannot promote between decimal and "[rt.name]".')
			else
				throw FallThroughException({'this': this, '_left': _left, 'op': _op, 'lt': lt, 'rt': rt})

	def _writeSharpDef(sw as SharpWriter) is override
		if _type.isDynamic
			specs = OperatorSpecs.binaryOpSpecsByCobraText
			assert specs.containsKey(.token.text)
			spec = specs[.token.text]
			opText = Utils.sharpStringLiteralFor(spec.opMethodName)
			sw.write('CobraImp.DynamicOp([opText], ')
			_left.writeSharpDef(sw)
			sw.write(', ')
			_right.writeSharpDef(sw)
			sw.write(')')
			return
		intType = .compiler.intType
		left = _left
		right = _right
		op = ''
		pre = ''
		sep = ','  # for the method call case
		branch _op
			on 'PLUS'
				op = '+'
			on 'MINUS'
				op = '-'
			on 'STAR'
				op = '*'
			on 'STARSTAR'
				op = 'CobraImp.PowerTo('
			on 'SLASH'
				op = '/'
				if _left.isKindOf(intType) and _right.isKindOf(intType)
					pre = '(decimal)'
			on 'SLASHSLASH'
				if left.isKindOf(.compiler.intType) and right.isKindOf(.compiler.intType)
					op = '/'
				else if left.isKindOf(.compiler.decimalType) or right.isKindOf(.compiler.decimalType)
					op = 'Decimal.Floor('
					sep = '/'
				else if left.isKindOf(.compiler.floatType) or right.isKindOf(.compiler.floatType)
					op = 'Math.Floor('
					sep = '/'
				else
					throw FallThroughException([left.type, right.type])
			on 'PERCENT'
				op = '%'
			else
				throw FallThroughException(_op)
		assert op.length
		sw.write(pre)
		if op.length==1
			_left.writeSharpDef(sw)
			sw.write(op)
			_right.writeSharpDef(sw)
		else
			sw.write(op)  # ex: 'CobraImp.Foo('
			_left.writeSharpDef(sw)
			sw.write(sep)
			_right.writeSharpDef(sw)
			sw.write(')')


class CompareExpr
	inherits BinaryOpExpr

	# TODO: handle the real equals and does not equal

	var _cobraToSharp = {
		'EQ': '==',
		'NE': '!=',
		'GT': '>',
		'LT': '<',
		'GE': '>=',
		'LE': '<=',
		'IS': '==',
		'ISNOT': '!=',
	}

	def init(opToken as IToken, op as String, left as Expr, right as Expr)
		base.init(opToken, op, left, right)
		if op == 'ISNOT' and .token.text == 'is'
			.token.text = 'is not'

	def _bindImp
		base._bindImp
		_type = .compiler.boolType
		if _left.type is nil or _right.type is nil
			assert .hasError
			return
		leftType = _left.type to !
		rightType = _right.type to !
		innerMsg as String?
		# cannot invoke .isAssignableTo directly on the types because if one is nilable and the other is not, you can get false, even though that doesn't apply for "is". So use isEquatableTo and isComparableTo
		if .op in ['EQ', 'NE', 'IS', 'ISNOT']
			if not leftType.isEquatableTo(rightType)
				innerMsg = if(.op.startsWith('IS'), 'can never be identical', 'cannot be equated')
			else if .op in ['IS', 'ISNOT']
				# Essentially "is" and "is not" are for reference types. Give a warning when used for value types.
				if not TypeUtil.isDynamicOrPassThrough(leftType) and not TypeUtil.isDynamicOrPassThrough(rightType)
					opName = if(.op=='IS', 'is', 'is not')
					altName = if(.op=='IS', '==', '<>')
					if not leftType.isReference and not rightType.isReference
						.compiler.warning(this, 'Both the left and right sides of "[opName]" are value types ("[leftType.name]" and "[rightType.name]"), but "[opName]" applies to reference types. Use "[altName]" instead.')
					# interestingly, I don't think the following ever happen in practice...
					else if not leftType.isReference and not TypeUtil.isNilableAndDescendantOf(rightType, leftType)
						.compiler.warning(this, 'The left side of "[opName]" is a value type ("[leftType.name]") while the right side is an incompatible reference type ("[rightType.name]").')
					else if not rightType.isReference and not TypeUtil.isNilableAndDescendantOf(leftType, rightType)
						.compiler.warning(this, 'The right side of "[opName]" is a value type ("[rightType.name]") while the left side is an incompatible reference type ("[leftType.name]").')						
		else
			if not leftType.isComparableTo(rightType)
				innerMsg = 'cannot be compared'
		if innerMsg
			typeNames = if(_left.type.name==_right.type.name, 'type ("[_left.type.name]")', 'types ("[_left.type.name]" and "[_right.type.name]")')
			msg = 'The left and right sides of the "[.token.text]" expression [innerMsg] because of their [typeNames].'
			if .op == 'IS' and _right.type.isDescendantOf(.compiler.libraryType('System.Type')) # C#
				msg += ' Maybe you should try "inherits" instead of "is".'
			.throwError(msg)

	def _writeSharpDef(sw as SharpWriter) is override
		left = _left
		right = _right
		op = _op
		# Compute the C# operation which will be an operator or method call
		if op=='EQ' or op=='NE'
			if not left.type.isReference and not right.type.isReference
				op = _cobraToSharp[_op]
			else
				done = false
				stringType = .compiler.libraryType('System.String')
				if left.isKindOf(stringType) and right.isKindOf(stringType)  # TODO: check for static comparison operations instead
					op = _cobraToSharp[_op]
					done = true
				else if left.type inherits Box  # TODO: try skipping on requiring that the type is a Box
					leftBox = left.type to Box
					compareTo = leftBox.memberForName('compareTo')
					if compareTo and compareTo.isMethod and compareTo.resultType is .compiler.intType and right.type.isDescendantOf(leftBox)  # need last condition to prevent someString.CompareTo(someChar)
						op = '.CompareTo('
						done = true
				if not done
					assert op in ['EQ', 'NE']
					assert op == .token.which
					op = if(op=='EQ', 'CobraImp.Equals(', 'CobraImp.NotEquals(')
		else if op=='IS' or op=='ISNOT'
			if left.type inherits PrimitiveType and right.type inherits PrimitiveType
				op = _cobraToSharp[_op]
			else if left.type.isReference and right.type.isReference
				# skip the CobraImp.Is call for faster performance
				op = if(op=='IS', 'Object.ReferenceEquals(', '!Object.ReferenceEquals(')
			else
				# non-trivial situation.. fall back to runtime support
				op = if(op=='IS', 'CobraImp.Is(', 'CobraImp.IsNot(')
		else
			if left.type.isDynamic or right.type.isDynamic
				sw.write('CobraImp.DynamicCompare(')
				left.writeSharpDef(sw, false)
				sw.write(', ')
				right.writeSharpDef(sw, false)
				sw.write(')[_cobraToSharp[_op]]0')
				return
			else
				done = false
				if left.type inherits Box  # TODO: try skipping on requiring that the type is a Box
					leftBox = left.type to Box
					compareTo = leftBox.memberForName('compareTo')
					if compareTo and compareTo.isMethod and compareTo.resultType is .compiler.intType and left.type == right.type  # need last condition to prevent someString.CompareTo(someChar)
						op = '.CompareTo('
						done = true
				if not done
					op = _cobraToSharp[_op]
		# Write the C# code
		if op.length<=2
			left.writeSharpDef(sw)
			sw.write(op)
			right.writeSharpDef(sw)
		else if op == '.CompareTo('
			left.writeSharpDef(sw)
			sw.write(op)
			right.writeSharpDef(sw, false)
			sw.write(') [_cobraToSharp[_op]] 0')
		else if op.endsWith('(')
			sw.write(op)
			left.writeSharpDef(sw)
			sw.write(',')
			right.writeSharpDef(sw)
			sw.write(')')
		else
			throw FallThroughException(op)


interface IDotRightExpr
	"""
	IDotRightExpr is an expression that can appear on the right hand side of a DotExpr.
	Implemented by MemberExpr and CallExpr.
	"""
	get name as String
	get member as IMember?
	get args as List<of Expr>


class DotExpr
	inherits BinaryOpExpr
	implements IPotentialTypeExpr

	var _dotRightExpr as IDotRightExpr
	
	def init(opToken as IToken, op as String, left as Expr, right as Expr)
		require right inherits IDotRightExpr 
		base.init(opToken, op, left, right)
		_dotRightExpr = right to IDotRightExpr

	def _bindImp
		base._bindImp

		if _left inherits BaseLit
			.compiler.curCodeMember.usesBase  # use of base implies override if the containing member is not already marked new
		else if _left inherits ThisLit
			if _left.isExplicit  # CC: combine above
				.compiler.warning(this, 'An explicit "this" literal is unnecessary for accessing members of the current object. You can remove "this".')
			else if _right inherits MemberExpr
				if _right.name.startsWith('_')
					.compiler.warning(this, 'An explicit dot (".") is unnecessary for accessing underscored members of the current object. You can remove ".".')
		if not _type
			assert _right.type
			_type = _right.type
		if _left.type.isDynamic
			_type = .compiler.dynamicType
		else if not _left.hasError and not _right.hasError
			if _left inherits IdentifierExpr
				if _left.definition inherits Box # CC: combine with above if statement
					if not _dotRightExpr.member.isShared
						.throwError('Cannot access instance member "[_dotRightExpr.name]" on type "[_left.name]". Make the member "shared" or create an instance of the type.')
			if _left inherits ThisOrBaseLit
				if .curCodeMember and .curCodeMember.isShared and not _dotRightExpr.member.isShared  # .curCodeMember is nil when bind imp'ing on var init exprs like "var _x = someExpr"
					.throwError('Cannot access instance member "[_dotRightExpr.name]" from the current shared member. Make the member "shared" or create an instance of the type.')
	get potentialType as IType?
		# overridden to return the type this dotted expr represents in those cases when it does represent a type
		assert .didBindImp
		if _definition inherits IType
			return _definition
		else
			return nil

	def toCobraSource as String is override
		if _left inherits ThisLit
			return '.[_right.toCobraSource]'
		else
			return '[_left.toCobraSource].[_right.toCobraSource]'

	def _writeSharpDef(sw as SharpWriter) is override
		if _left.receiverType.isDynamic
			# handle dynamic typing
			if _right inherits MemberExpr
				sw.write('CobraImp.GetPropertyValue(')
				_left.writeSharpDef(sw, not _left inherits DotExpr)
				sw.write(', ')
				sw.write(Utils.sharpStringLiteralFor(Utils.capped(_right.name)))
				sw.write(')')
			else if _right inherits CallExpr
				# TODO: CallExpr
				sw.write('CobraImp.InvokeMethod(')
				_left.writeSharpDef(sw, not _left inherits DotExpr)
				sw.write(', ')
				sw.write(Utils.sharpStringLiteralFor(Utils.capped(_right.name)))
				for arg in _right.args
					sw.write(', ')
					arg.writeSharpDef(sw, false)
				sw.write(')')
			else
				throw FallThroughException(_right)
		else
			# Given Cobra "A.B.C()" where C is a class/type/struct, then the C# needs to be "new A.B.C()"
			# (But stuff like this makes me wonder if the ASTs should be doing some transformations, like collapsing qualified types.)
			if _right inherits CallExpr
				if _right.isNew
					if _left inherits DotExpr
						sw.write('new ')
						_right.willWriteSharpNew = false
			# handle static typing
			# don't write 'this' for shared members
			writeThis = true
			if _left inherits ThisLit
				if _right inherits CallExpr
					defi = _right.definition
					if defi inherits IMember
						writeThis = not defi.isShared
					else
						# TODO: compiler bug stimulated by following line:
						# throw FallThroughException({'right': _right, 'defi': defi})
						throw FallThroughException(defi)
				else if _right inherits MemberExpr
					writeThis = not _right.definition.isShared
			else if .curCodeMember inherits Initializer and _right inherits IDotRightExpr and (_right to IDotRightExpr).name == 'init' and _left inherits ThisOrBaseLit
				# Well, in practice this doesn't really happen because Constructer.innerWriteSharpDef usurps the code gen for base calls
				Stmt.inInitCall = true
				didSetInInitCall = true
			if writeThis
				_left.writeSharpDef(sw, not _left inherits DotExpr)
				sw.write('.')
			_right.writeSharpDef(sw, false)
			if didSetInInitCall
				Stmt.inInitCall = false

	def _writeSharpBreakdownItemsLeft(sw as SharpWriter) is override
		if not _left.type inherits TypeType  # feels like a cheap escape...
			_left.writeSharpBreakdownItems(sw)


class InExpr
	inherits BinaryOpExpr

	def init(opToken as IToken, op as String, left as Expr, right as Expr)
		base.init(opToken, op, left, right)
		assert op in ['IN', 'NOTIN']

	def _bindImp
		base._bindImp
		_type = .compiler.boolType

	def writeSharpDef(sw as SharpWriter, parens as bool) is override
		branch _op
			on 'NOTIN': sw.write('!')
			on 'IN': pass
			else: throw FallThroughException(_op)
		sw.write('CobraImp.In(')
		_left.writeSharpDef(sw, false)
		sw.write(',')
		_right.writeSharpDef(sw, false)
		sw.write(')')


class InheritsExpr
	inherits BinaryOpExpr

	def init(opToken as IToken, op as String, left as Expr, right as Expr)
		base.init(opToken, op, left, right)
		assert op in ['INHERITS', 'IMPLEMENTS']
		
	def _bindImp
		base._bindImp
		_type = .compiler.boolType
		if _right inherits IPotentialTypeExpr
			rightType = _right.potentialType
			if rightType
				leftType = _left.type
				if leftType
					okay = true
					if leftType inherits DynamicType or (leftType inherits NilableType and (leftType to NilableType).theWrappedType inherits DynamicType)
						pass
					else if leftType.isDescendantOf(rightType)
						.compiler.warning(this, 'The expression is always of type "[.right.toCobraSource]".')
					else if rightType.isDescendantOf(leftType)
						# ex: someShape inherits Circle
						pass
					else if leftType inherits NilableType and not rightType inherits NilableType and rightType.isStrictDescendantOf((leftType to NilableType).theWrappedType)
						# ex: someNilableShape inherits Circle
						pass
					else if leftType inherits NilableType and not rightType inherits NilableType and (leftType to NilableType).theWrappedType.isDescendantOf(rightType)
						# ex: someNilableCircle inherits Shape
						.compiler.warning(this, 'The expression will always be of type "[.right.toCobraSource]" when not nil. You can just check for not nil by removing "inherits [.right.toCobraSource]".')
					else if rightType inherits Interface
						if leftType inherits Class
							pass
						else if leftType inherits Struct
							found = false
							for leftInterface in leftType.baseInterfaces
								if leftInterface.isDescendantOf(rightType)
									.compiler.warning(this, 'The expression is always of type "[.right.toCobraSource]".')
									found = true
									break
							if not found
								.compiler.warning(this, 'The expression (of type "[leftType.name]") is never of type "[.right.toCobraSource]".')
						else if leftType inherits Interface
							# already checked earlier if one side descends from the other, so
							okay = false
					else
						okay = false
					if not okay
						.compiler.warning(this, 'The expression (of type "[leftType.name]") is never of type "[.right.toCobraSource]".')
		if (right = .right) inherits IdentifierExpr  # TODO: change to IPotentialTypeExpr and make a test case first
			defi = right.definition
			if defi
				if defi inherits Class
					if .op <> 'INHERITS'
						.throwError('Use the "inherits" operator when testing objects against classes.')
				else if defi inherits Struct
					if .op <> 'INHERITS'
						.throwError('Use the "inherits" operator when testing objects against structs.')
				else if defi inherits Interface
					pass
					#if .op <> 'IMPLEMENTS'
					#	.throwError('Use the "implements" operator when testing objects against interfaces.')
				else
					throw FallThroughException(defi)
				
	def _writeSharpDef(sw as SharpWriter) is override
		_left.writeSharpDef(sw)
		sw.write(' is ')
		_right.writeSharpDef(sw, false)


class AbstractToExpr
	is abstract
	inherits BinaryOpExpr

	var _potentialTypeExpr as IPotentialTypeExpr

	def init(opToken as IToken, op as String, left as Expr, right as Expr)
		base.init(opToken, op, left, right)
		assert right inherits IPotentialTypeExpr
		_potentialTypeExpr = right to IPotentialTypeExpr
		
	def _bindImp
		base._bindImp
		if not _right.isKindOf(.compiler.typeType) and not _right.type inherits Box
			.throwError('The "to" operator does not apply to "[_right.toCobraSource]". Use a type.')
		_type = _potentialTypeExpr.potentialType
		if _type is nil
			.throwError('The expression "[_potentialTypeExpr.toCobraSource]" does not identify a type.')
		# TODO: not quite ready for the following
		#       at the very least, need to enhance CobraType and descendants to have a superType of System.Object
		# test case is 208-to-errors.cobra with substring 'can never be cast to a'
		#else if _left.type and not _type.isDescendantOf(_left.type to !)
		#	.throwError('The given expression, of type "[_left.type.name]", can never be cast to a "[_potentialTypeExpr.toCobraSource]".')


class ToExpr
	inherits AbstractToExpr

	var _rightTypeExpr as IPotentialTypeExpr

	def init(opToken as IToken, op as String, left as Expr, right as Expr)
		base.init(opToken, op, left, right)
		assert right inherits IPotentialTypeExpr
		_rightTypeExpr = right to IPotentialTypeExpr

	def _bindImp
		base._bindImp
		if _left inherits NilLiteral and not (_type inherits NilableType or _type inherits PassThroughType)
			.throwError('Cannot cast nil to a non-nil type.')
		rightType = _rightTypeExpr.potentialType
		if rightType
			if _left.type inherits NilableType and not rightType inherits NilableType
				if (_left.type to NilableType).theWrappedType is rightType
					.compiler.warning(this, 'The given expression is already a "[_rightTypeExpr.toCobraSource]", but nilable. You can just use "to !".')
			else if not _left.type inherits NilableType and rightType inherits NilableType
				if (rightType to NilableType).theWrappedType == _left.type
					.compiler.warning(this, 'The given expression is already a "[_left.type.name]", but not nilable. You can just use "to ?".')
			else if _left.type == rightType
				.compiler.warning(this, 'The given expression is already a "[_rightTypeExpr.toCobraSource]" so the typecast is redundant. You can remove it.')
		else
			.throwError('Cannot locate a type for the type cast "to [_rightTypeExpr.toCobraSource]".')

	def _writeSharpDef(sw as SharpWriter) is override
		rightType = _rightTypeExpr.potentialType to !   # its not nil or _bindImp would have thrown an error
		if rightType is .compiler.passThroughType
			_left.writeSharpDef(sw)
			return
		sw.write('(')
		_right.writeSharpDef(sw, false)  # double parens would be pointless and also causes a C# error
		sw.write(')')
		if not rightType inherits NilableType and rightType.isReference
			sw.write('CobraImp.CheckNonNil<[_left.type.sharpRef]>([.sharpThis], [Utils.sharpStringLiteralFor(_left.toCobraSource)], ')
			_left.writeSharpDef(sw, false)
			sw.write(', [.sharpSourceSite])')
		else
			_left.writeSharpDef(sw)


class ToQExpr
	inherits AbstractToExpr

	def init(opToken as IToken, op as String, left as Expr, right as Expr)
		base.init(opToken, op, left, right)
		# TODO: use IPotentialTypeExpr like ToExpr does

	def _bindImp
		base._bindImp
		if not _type inherits NilableType
			_type = NilableType(_type).bindAll to NilableType  # CC: axe cast when 'as this' is supported
		# TODO: warn about redundancy

	def _writeSharpDef(sw as SharpWriter) is override
		# x to? int     --> ((x is int || x is int?) ? (int?)x : (int?)null)
		# x to? int?    --> ((x is int || x is int?) ? (int?)x : (int?)null)
		# ^ but this would cause multiple evaluation of x, so...
		# x to? int?	--> (int?)CobraImp.ToOrNil(x)

		# x to? string  --> (x as String)
		# x to? string? --> (x as String)
		right = .right
		if right inherits TypeExpr
			t = right.containedType to !
		else if right inherits IdentifierExpr
			t = right.definition to IType
		else
			throw FallThroughException(t)
		# TODO?: t = t.realType
#		assert t inherits IType
		if t inherits NilableType
			t = t.theWrappedType
		typeSharpRef = t.sharpRef
		if t.isReference
			sw.write('(')
			.left.writeSharpDef(sw)
			sw.write(') as [typeSharpRef]')
		else
			sw.write('[typeSharpRef]?)CobraImp.ToOrNil<[typeSharpRef]>(')
			.left.writeSharpDef(sw)


class CoalesceExpr
	inherits BinaryOpExpr
	"""
	x ? y ==> if(x is nil, y, x)
	but without the potential double evaluation of x, which could be a complex expression.
	"""

	def init(opToken as IToken, op as String, left as Expr, right as Expr)
		base.init(opToken, op, left, right)

	def _bindImp
		base._bindImp
		ptt = .compiler.passThroughType
		if _left.type is ptt or _right.type is ptt
			# x ? y   ...where either is typed as passthrough
			_type = ptt
		else if _left.type inherits NilableType and not _right.type inherits NilableType
			# x ? y   ...where x can be nil, but y cannot
			_type = (_left.type to NilableType).theWrappedType  # TODO: should be greatest common denominator between the two
		else
			# the catch all case
			_type = _left.type  # TODO: should be greatest common denominator between the two

	def _writeSharpDef(sw as SharpWriter) is override
		_left.writeSharpDef(sw)
		sw.write(' ?? ')
		_right.writeSharpDef(sw)


class InverseCoalesceExpr
	inherits BinaryOpExpr
	"""
	x ! y ==> if(x is not nil, y, x)
	but without the potential double evaluation of x, which could be a complex expression.
	"""

	def init(opToken as IToken, op as String, left as Expr, right as Expr)
		base.init(opToken, op, left, right)

	def _bindImp
		base._bindImp
		ptt = .compiler.passThroughType
		if _left.type is ptt or _right.type is ptt
			# x ! y   ...where either is typed as passthrough
			_type = ptt
# TODO?
#		else if _right.type inherits NilableType and not _right.type inherits NilableType
#			# x ? y   ...where x can be nil, but y cannot
#			_type = _left.type.theWrappedType  # TODO: should be greatest common denominator between the two
		else
			# the catch all case
			_type = _left.type  # TODO: should be greatest common denominator between the two

	def _writeSharpDef(sw as SharpWriter) is override
		if _right inherits NilLiteral
			# `left ! nil` always returns nil -- it's like a no-op
			if _left inherits IdentifierExpr
				# no side effect possibl
				sw.write('null')
			else
				# in case `left` has side effects, evaluate it
				sw.write('CobraImp.Return<[_type.sharpRef]>(null, ')
				_left.writeSharpDef(sw, false)
				sw.write(')')
		else
			_left.writeSharpDef(sw)
			sw.write('==null ? null : ')
			if not _right.type inherits NilableType and not _right.type inherits NilType
				sw.write('([_right.type.sharpRef]?)')
			_right.writeSharpDef(sw)


class CoalesceAssignExpr
	inherits BinaryOpExpr
	"""
	x ?= y
	"""

	def init(opToken as IToken, op as String, left as Expr, right as Expr)
		base.init(opToken, op, left, right)

	def _bindImp
		base._bindImp
		# TODO: error check that the left hand type is nilable?
		# TODO: error check that the right hand type is not nilable?
		_type = _right.type

	def _writeSharpDef(sw as SharpWriter) is override
		# L = L * R
		_left.writeSharpDef(sw)
		sw.write(' = ')
		_left.writeSharpDef(sw)
		sw.write(' ?? ')
		_right.writeSharpDef(sw)


class InverseCoalesceAssignExpr
	inherits BinaryOpExpr
	"""
	x != y
	"""

	def init(opToken as IToken, op as String, left as Expr, right as Expr)
		base.init(opToken, op, left, right)

	def _bindImp
		base._bindImp
		# TODO: any error checks here?
		_type = _left.type

	def _writeSharpDef(sw as SharpWriter) is override
		_left.writeSharpDef(sw)
		sw.write(' = ')
		if _right inherits NilLiteral
			# `left != nil` is the same as `left = nil`
			sw.write('null')
		else
			_left.writeSharpDef(sw)
			sw.write('==null ? null : ')
			if not _right.type inherits NilableType and not _right.type inherits NilType
				sw.write('([_right.type.sharpRef]?)')
			_right.writeSharpDef(sw)
