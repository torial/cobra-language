"""
Eventually this file will contain all C# code generation.
In the future, you can expect (or contribute!) alternate code generators such as IL, JVM and Objective-C.
"""


##
## Types
##

class BasicLibraryType
	is partial

	get sharpInit as String
		throw NoSharpGenException(this)

	get sharpName as String
		throw NoSharpGenException(this)

	get sharpNameComponent as String
		throw NoSharpGenException(this)

	get sharpParamRef as String
		throw NoSharpGenException(this)

	get sharpRef as String
		throw NoSharpGenException(this)

	def writeSharpDef(sw as SharpWriter)
		throw NoSharpGenException(this)

	def writeSharpTestInvocation(sw as SharpWriter)
		throw NoSharpGenException(this)


class NoSharpGenException
	inherits Exception
	
	def init(blt as BasicLibraryType)
		base.init('Not expecting to generate C# with BasicLibraryType ([blt])')


interface IType
	is partial

	get sharpInit as String

	get sharpNameComponent as String
		"""
		Returns a string that refers to this type and is suitable for embedding in a larger
		identifier (meaning there will be no punction, spaces or C# comments).
		"""

	get sharpRef as String
		"""
		Returns a string that refers to this type.
		Examples: 'int'  'List<String>'  'object'
		"""

	get sharpParamRef as String
		"""
		Returns a string that refers to this type including any necessary parameter declaration
		specification such as C# 'params' or 'out'. Invoked by Param.writeSharpDef.
		"""


class CobraType
	is abstract, partial

	get sharpInit as String is abstract

	get sharpName as String
		return .name

	get sharpNameComponent as String
		name = .name
		i = name.indexOf('/*')  # example: /*dynamic*/object
		if i <> -1
			j = name.indexOf('*/', i)
			name = name[:i] + name[j+2:]
		name = name.replace('.', '_').replace('<', '_').replace('>', '_').replace(', ', '_')
		return name

	get sharpRef as String
		return .sharpName

	get sharpParamRef as String
		return .sharpRef

	def writeSharpTestInvocation(sw as SharpWriter)
		pass


class BoolType
	is partial

	get sharpInit as String is override
		return 'false'


class CharType
	is partial

	get sharpInit as String is override
		return '(char)0'


class DynamicType
	is partial

	get sharpInit as String is override
		return 'null'

	get sharpName as String is override
		return '/*dynamic*/object'


class FloatType
	is partial

	get sharpName as String is override
		return _clrType.name


class IntType
	is partial

	get sharpName as String is override
		return _clrType.name


class NilableType
	is partial

	get sharpInit as String is override
		return 'null'

	get sharpRef as String is override
		return _wrappedType.sharpRef + if(not _wrappedType.isReference, '?', '')


class NilType
	is partial

	get sharpInit as String is override
		return 'null'

	get sharpRef as String is override
		return '/*nil*/object'


class NumberType
	is partial

	get sharpInit as String is override
		return '0'

class PassThroughType
	is partial

	get sharpInit as String is override
		return 'null'

	get sharpRef as String is override
		return '/*passthrough*/object'


class VoidType
	is partial

	get sharpInit as String is override
		throw Exception('Cannot init a void type.')


class WrappedType
	is partial

	get sharpInit as String is override
		return _wrappedType.sharpInit


class ArrayType
	is partial

	get sharpRef as String is override
		return '[_wrappedType.sharpRef]' + r'[]'

	get sharpInit as String is override
		return 'null'


class VariType
	is partial

	get sharpRef as String is override
		return '[_wrappedType.sharpRef]' + r'[]'

	get sharpParamRef as String is override
		return 'params ' + .sharpRef


class UnspecifiedType
	is partial
	
	get sharpInit as String is override
		# TODO: throw Exception('Not expecting code gen for unspecified types.')
		return '!UnspecifiedType!'


##
## Expressions
##


class Expr
	is abstract, partial

	def writeSharpDefInContext(sw as SharpWriter)
		.writeSharpDefInContext(sw, true)

	def needsContextCast as bool
		"""
		Returns true if this expression needs to be cast within its context.
		One example, is that a dynamically typed expression requires such casting.
		"""
		type = .type
		if type.isDynamic, return true
		if type inherits IntType
			if type.size < 32, return true
		return false

	def writeSharpDefInContext(sw as SharpWriter, parens as bool)
		"""
		When an expression is used where a particular type is expected, such as:
			# assignment
			x = y
			# argument passing
			obj.foo(x, y)
			obj[x, y]
		it may need C# typecasting--particularly if it is dynamic typed expression.
		This method relies on having had its .contextType set beforehand.
		This method should be invoked instead of `writeSharpDef` in any situation where .contextType was set.
		"""
		cast = _contextType and .needsContextCast
		if cast
			if parens, sw.write('(')
			sw.write('([_contextType.sharpRef])(')
		.writeSharpDef(sw)
		if cast
			sw.write(')')
			if parens, sw.write(')')

	def writeSharpDef(sw as SharpWriter) is override
		base.writeSharpDef(sw)
		branch .argumentLabel
			on ArgumentLabel.None,  pass
			on ArgumentLabel.Out,   sw.write('out ')
			on ArgumentLabel.InOut, sw.write('ref ')
		.writeSharpDef(sw, true)

	def writeSharpDef(sw as SharpWriter, parens as bool)
		pass

	def writeSharpStmt(sw as SharpWriter) is override
		assert .didBindImp
		sw.node(this)
		.writeSharpSetLine(sw)
		.writeSharpDef(sw, false)
		sw.write(';\n')

	def writeSharpBreakdown(sw as SharpWriter)
		sw.write(r'new object[] { 0')
		.writeSharpBreakdownItems(sw)
		sw.write('}, ')

	get willWriteSharpBreakdownItems as bool
		return _argumentLabel <> ArgumentLabel.Out

	def writeSharpBreakdownItems(sw as SharpWriter)
		if .willWriteSharpBreakdownItems
			src = Utils.sharpStringLiteralFor(.toCobraSource)
			sw.write(', [src], ')
			.writeSharpDefForBreakdown(sw)

	def writeSharpDefForBreakdown(sw as SharpWriter)
		.writeSharpDef(sw)


class NameExpr
	is abstract, partial

	get asSharp as String
		return _definition.sharpName

	def writeSharpDef(sw as SharpWriter, parens as bool) is override
		sw.write(.asSharp)


class AsExpr
	is partial

	def writeSharpStmt(sw as SharpWriter) is override
		# this happens for declarations like "i as int"
		sw.write('// [_name] as [_type.name]\n')


class CallExpr
	is partial

	def writeSharpDef(sw as SharpWriter, parens as bool) is override
		assert .superNode inherits DotExpr
		name = .name
		if _definition inherits BoxMember and (_definition to BoxMember).binaryName
			name = (_definition to BoxMember).binaryName to !
		else
			name = name.capped
		sw.write('[name]')
		if _genericArgTypes and _genericArgTypes.count
			sw.write('<')
			sep = ''
			for genericArgType in _genericArgTypes
				sw.write(sep + genericArgType.sharpRef)
				sep = ', '
			sw.write('>')
		sw.write('(')
		sep = ''
		for arg in _args
			sw.write(sep)
			arg.writeSharpDefInContext(sw)
			sep = ', '
		sw.write(')')

	def writeSharpBreakdownItems(sw as SharpWriter) is override
		# leaving out the base call is intentional:
		# base.writeSharpBreakdownItems(sw)
		sw.write(', +1')
		for expr in _args
			expr.writeSharpBreakdownItems(sw)
		sw.write(', -1')


class EnumCallExpr
	is partial

	def writeSharpDef(sw as SharpWriter, parens as bool) is override
		if parens
			sw.write('(')
		if _args.count == 0
			sw.write('default([_definition.sharpRef])')
		else
			sep = ''
			for member in _members
				sw.write(sep)
				sw.write(member.sharpRef)
				sep = '|'
		if parens
			sw.write(')')

	def writeSharpBreakdownItems(sw as SharpWriter)
		base.writeSharpBreakdownItems(sw)
		sw.write(', +1')
		for member in _members
			sw.write(', ')
			sw.write(member.sharpRef)
		sw.write(', -1')


class ForExpr
	is partial

	def writeSharpDef(sw as SharpWriter, parens as bool) is override
		# C#:  CobraImp.For(stuff, delegate(x as int) { return x*x })
		# C#:  CobraImp.For(stuff, delegate(x as int) { if (x<0) return x*x; })
		inType = _what.type.innerType
		outType = _getExpr.type
		sw.write('CobraImp.For<[inType.sharpRef],[outType.sharpRef]>(')
		_what.writeSharpDef(sw, false)
		sw.write(', ')
		helperName = '_lh_for_[_var.name]_[_varNumber]'
		if _whereExpr is nil
			sw.write('delegate([inType.sharpRef] [helperName]) {\n')
			sw.indent
			sw.write('[_var.sharpName] = [helperName];\n')
			sw.write('return ')
			_getExpr.writeSharpDef(sw, false)
			sw.write(';\n')
			sw.dedent
			sw.write('})')
		else
			outHelperName = helperName + '_out'
			sw.write('delegate([inType.sharpRef] [helperName], out [outType.sharpRef] [outHelperName]) {\n')
			sw.indent
			sw.write('[_var.sharpName] = [helperName];\n')
			sw.write('if (')
			_whereExpr.writeSharpDef(sw, false)
			sw.write(') {\n')
			sw.indent
			sw.write('[outHelperName] = ')
			_getExpr.writeSharpDef(sw, false)
			sw.write(';\n')
			sw.write('return true;\n')
			sw.dedent
			sw.write('} else {\n')
			sw.indent
			sw.write('[outHelperName] = [outType.sharpInit];\n')
			sw.write('return false;\n')
			sw.dedent
			sw.write('}\n')
			sw.dedent
			sw.write('})')


class IdentifierExpr
	is partial

	def writeSharpDef(sw as SharpWriter, parens as bool) is override
		# weird stuff motivated by ../Tests/110-basics-two/500-namespaces/400-type-property-name-collision-1.cobra and 402-type-property-name-collision-2.cobra

		# recall that this cannot be the right side of "foo.bar" since that is a MemberExpr
		sharpName = .sharpName
		if not .definition inherits IVar
			# the only definition that has no parentNameSpace in practice is IVar
			if not sharpName.startsWith('typeof')
				# maybe parentNameSpace could be moved up in the interface definitions
				pn = (.definition to dynamic).parentNameSpace
				if pn, sharpName = pn.sharpQualifier + sharpName

				# handle the case of "X.X" where namespace and class are both called "X".
				# C# chokes on it because the first "X" is considered to be the type
				if .curBox.name + '.' in sharpName
					sharpName = 'global::' + sharpName

		sw.write(sharpName)

	get sharpName as String
		assert .didBindImp
		assert .definition
		assert not .type inherits UnspecifiedType
		if .superNode inherits DotExpr
			assert this is not (.superNode to DotExpr).right  # should be a CallExpr or MemberExpr instead
		defi = .definition
		if .isTypeReference
			# C# often requires typeof(Foo) instead of just plain Foo
			superNode = .superNode
			if not superNode inherits DotExpr and not superNode inherits InheritsExpr and (not superNode inherits PostCallExpr or (superNode to PostCallExpr).expr is not this)
				return 'typeof(' + defi.sharpName + ')'
		return defi.sharpName

	def writeSharpStmt(sw as SharpWriter) is override
		assert .isCalling
		sw.write('[_name]();')

	get sharpAssignmentNames as List<of String>?
		require
			.didBindImp
			.definition
		body
			if _definition inherits IVar
				return _definition.sharpAssignmentNames
			else
				return nil

	def writeSharpDefForBreakdown(sw as SharpWriter)
		sharpName = .sharpName
		if .isKindOf(.compiler.typeType) and .definition inherits IType and 'typeof(' not in sharpName
			sw.write('typeof([.sharpName])')
		else
			base.writeSharpDefForBreakdown(sw)


class IfExpr
	is partial

	def writeSharpDef(sw as SharpWriter, parens as bool) is override
		cast = _tpart.type <> _fpart.type
		# C# doesn't do the "greatest common denominator" thing like Cobra does, so some casting is in order
		sw.write('(')
		_cond.writeSharpDef(sw)
		sw.write('?')
		if cast, sw.write('([.type.sharpRef])(')
		_tpart.writeSharpDef(sw)
		if cast, sw.write(')')
		sw.write(':')
		if cast, sw.write('([.type.sharpRef])(')
		_fpart.writeSharpDef(sw)
		if cast, sw.write(')')
		sw.write(')')

	def writeSharpBreakdownItems(sw as SharpWriter)
		base.writeSharpBreakdownItems(sw)

		sw.write(', +1') # indent

		_cond.writeSharpBreakdownItems(sw)
		# only one of the target expressions is actually evaluated

		# tpart:
		src = Utils.sharpStringLiteralFor(_tpart.toCobraSource)
		sw.write(', [src], new CobraDirectString(')
		_cond.writeSharpDefForBreakdown(sw)
		sw.write(' ? CobraCore.ToTechString(')
		_tpart.writeSharpDefForBreakdown(sw)
		sw.write(') : "(not-evaluated)")')

		# fpart:
		src = Utils.sharpStringLiteralFor(_fpart.toCobraSource)
		sw.write(', [src], new CobraDirectString(')
		_cond.writeSharpDefForBreakdown(sw)
		sw.write(' ? "(not-evaluated)" : CobraCore.ToTechString(')
		_fpart.writeSharpDefForBreakdown(sw)
		sw.write('))')

		sw.write(', -1') # dedent


class IndexExpr
	is partial

	def writeSharpDef(sw as SharpWriter, parens as bool) is override
		if _target.type.isDynamic
			sw.write('CobraImp.GetIndexerValue(')
			_target.writeSharpDef(sw, false)
			for expr in _args
				sw.write(', ')
				expr.writeSharpDef(sw, false)
			sw.write(')')
			return
		if parens
			sw.write('(')
		if _target inherits IdentifierExpr
			if _target.isKindOf(.compiler.typeType)
				# here we're favoring "Foo[]" being an array type rather than a shared indexer
				sw.write(_target.name)
				handled = true
		if not handled
			_target.writeSharpDef(sw)
		sw.write(r'[')
		sep = ''
		for expr in _args
			sw.write(sep)
			expr.writeSharpDefInContext(sw)
			sep = ', '
		sw.write(']')
		if parens
			sw.write(')')

	def writeSharpBreakdownItems(sw as SharpWriter)
		base.writeSharpBreakdownItems(sw)
		sw.write(', +1')
		_target.writeSharpBreakdownItems(sw)
		for expr in _args
			expr.writeSharpBreakdownItems(sw)
		sw.write(', -1')


class IsNilExpr
	is partial

	def writeSharpDef(sw as SharpWriter, parens as bool) is override
		if parens
			sw.write('(')
		sw.write('(')
		_expr.writeSharpDef(sw)
		sw.write(')')
		sw.write('==null')
		if parens
			sw.write(')')

	def writeSharpBreakdownItems(sw as SharpWriter)
		base.writeSharpBreakdownItems(sw)
		_expr.writeSharpBreakdownItems(sw)


class IsNotNilExpr
	is partial

	def writeSharpDef(sw as SharpWriter, parens as bool) is override
		if parens
			sw.write('(')
		sw.write('(')
		_expr.writeSharpDef(sw)
		sw.write(')')
		sw.write('!=null')
		if parens
			sw.write(')')

	def writeSharpBreakdownItems(sw as SharpWriter)
		base.writeSharpBreakdownItems(sw)
		_expr.writeSharpBreakdownItems(sw)


class MemberExpr
	is partial

	def writeSharpDef(sw as SharpWriter, parens as bool) is override
		assert .superNode inherits DotExpr
		if _definition inherits BoxMember
			name = _definition.binaryName
		if name is nil
			name = _name.capped
		sw.write(name)
		if _definition and (_definition.isMethod or _name=='toString') and not _isReference  # TODO: axe the 'toString' check
			sw.write('()')

	def writeSharpBreakdownItems(sw as SharpWriter) is override
		pass


class OldExpr
	is partial

	var _sharpVarName as String?

	pro sharpVarName from var

	def writeSharpAssignment(sw as SharpWriter)
		require
			.didBindImp
			.sharpVarName
			.type
		body
			sw.write('[.type.sharpRef] [_sharpVarName] = ')
			_expr.writeSharpDef(sw)
			sw.write(';\n')

	def writeSharpDef(sw as SharpWriter, parens as bool) is override
		assert _sharpVarName
		# this gets called when generating the `ensure` code
		sw.write(_sharpVarName)


class PostCallExpr
	is partial

	def writeSharpDef(sw as SharpWriter, parens as bool) is override
		if _helperMethod
			sw.write(_helperMethod.name + '(')
			sep = ''
			for arg in _args
				sw.write(sep)
				if arg inherits AssignExpr
					arg = arg.right
				arg.writeSharpDefInContext(sw, false)
				sep = ','
			sw.write(')')
		else
			if parens, sw.write('(')
			expr = _expr
			isMethodSig = false
			isDynamic = false
			if expr inherits TypeExpr
				if expr.containedType inherits ArrayType
					# arrays
					sw.write('new ')
					sw.write((expr.containedType to ArrayType).theWrappedType.sharpRef)
					sw.write(r'[')
					.writeSharpArgs(sw)
					sw.write(r']')
				else
					sw.write('new ')
					expr.writeSharpDef(sw)
					sw.write('(')
					.writeSharpArgs(sw)
					sw.write(')')
			else if expr inherits IdentifierExpr
				if expr.isTypeReference
					sw.write('new ')
					expr.writeSharpDef(sw)
					sw.write('(')
					.writeSharpArgs(sw)
					sw.write(')')
				else if expr.receiverType inherits GenericParam # TODO: shouldn't expr.isTypeReference above have caught this?
					sw.write('new [expr.receiverType.sharpRef](')
					.writeSharpArgs(sw)
					sw.write(')')
				else if expr.type inherits MethodSig
					isMethodSig = true
				else if expr.type.isSystemTypeClass or _type.isDynamic
					isDynamic = true
				else
					assert false, expr  # TODO: .throwError
			else if expr inherits IndexExpr
				if expr.type inherits MethodSig
					isMethodSig = true
				else if expr.type.isSystemTypeClass or _type.isDynamic
					isDynamic = true
				else
					assert false, expr  # TODO: .throwError
			else
				assert false, expr  # TODO: .throwError
			if isMethodSig
				expr.writeSharpDef(sw)
				sw.write('(')
				.writeSharpArgs(sw)
				sw.write(')')
			else if isDynamic
				defi = (expr to dynamic).definition
				assert not defi inherits Box, expr  # TODO: just curious
				what = if(defi inherits IType, 'typeof([defi.sharpName])', defi.sharpName to String)
				if defi inherits IVar
					if defi.type.isDynamic
						what = '(System.Type)' + what
				sw.write('Activator.CreateInstance([what]')
				.writeSharpArgs(sw, ', ')
				sw.write(')')
			if parens, sw.write(')')

	def writeSharpArgs(sw as SharpWriter)
		.writeSharpArgs(sw, '')

	def writeSharpArgs(sw as SharpWriter, sep as String)
		for arg in _args
			sw.write(sep)
			arg.writeSharpDefInContext(sw, false)
			sep = ','
		
	def writeSharpBreakdownItems(sw as SharpWriter)
		base.writeSharpBreakdownItems(sw)
		sw.write(', +1')
		_expr.writeSharpBreakdownItems(sw)
		for expr in _args
			expr.writeSharpBreakdownItems(sw)
		sw.write(', -1')


class RefExpr
	is partial

	def writeSharpDef(sw as SharpWriter, parens as bool) is override
		if parens
			sw.write('(')
		_expr.writeSharpDef(sw, false)
		if parens
			sw.write(')')

	def writeSharpBreakdownItems(sw as SharpWriter)
		base.writeSharpBreakdownItems(sw)
		# TODO


class SharpExpr
	is partial

	def writeSharpDef(sw as SharpWriter, parens as bool) is override
		if parens
			sw.write('(')
		if _sharpSource
			sw.write(_sharpSource)
		else
			sw.write(_expr.token.value)
		if parens
			sw.write(')')


class SliceExpr
	is partial


	def writeSharpDef(sw as SharpWriter, parens as bool) is override
		sw.write('CobraImp.GetSlice(')
		isArray = _target.type inherits ArrayType
		if isArray
			sw.write('(System.Array)(')  # or C# can't disambiguate the GetSlice() overloads
		_target.writeSharpDef(sw, false)
		if isArray
			sw.write(')')
		sw.write(',')
		if _start is nil
			sw.write('null')
		else
			_start.writeSharpDefInContext(sw, false)
		sw.write(',')
		if _stop is nil
			sw.write('null')
		else
			_stop.writeSharpDefInContext(sw, false)
		sw.write(',')
		if _step is nil
			sw.write('null')
		else
			_step.writeSharpDefInContext(sw, false)
		sw.write(')')

	def writeSharpBreakdownItems(sw as SharpWriter)
		base.writeSharpBreakdownItems(sw)
		sw.write(', +1')
		_target.writeSharpBreakdownItems(sw)
		if _start
			_start.writeSharpBreakdownItems(sw)
		if _stop
			_stop.writeSharpBreakdownItems(sw)
		if _step
			_step.writeSharpBreakdownItems(sw)
		sw.write(', -1')


class TruthExpr
	is partial

	def writeSharpDef(sw as SharpWriter, parens as bool) is override
		lparen = if(parens, '(', '')
		rparen = if(parens, ')', '')
		branch _treatment
			on Treatment.AsIs
				_expr.writeSharpDef(sw, parens)
			on Treatment.InvokeRuntime
				sw.write('CobraImp.IsTrue(')
				_expr.writeSharpDef(sw, false)
				sw.write(')')				
			on Treatment.CompareToZero
				sw.write('[lparen]0!=')
				_expr.writeSharpDef(sw, true)
				sw.write(rparen)
			on Treatment.CompareToZeroChar
				sw.write("[lparen]'\\0'!=")
				_expr.writeSharpDef(sw, true)
				sw.write(rparen)
			on Treatment.CompareToNull
				sw.write('[lparen]null!=')
				_expr.writeSharpDef(sw, true)
				sw.write(rparen)

	def writeSharpBreakdownItems(sw as SharpWriter) is override
		# leaving out the base class is intentional:
		# base.writeSharpBreakdownItems(sw, isFirstExpr)
		_expr.writeSharpBreakdownItems(sw)


class TypeExpr
	is partial

	def writeSharpDef(sw as SharpWriter, parens as bool) is override
		sharpRef = _containedType.sharpRef
		# handle the case of "X.X" where namespace and class are both called "X".
		# C# chokes on it because the first "X" is considered to be the type
		if .curBox.name + '.' in sharpRef
			sharpRef = 'global::' + sharpRef
		if _requiresTypeOf()
			sw.write('typeof(')
			sw.write(_containedType.sharpRef)
			sw.write(')')
		else
			sw.write(_containedType.sharpRef)

	def _requiresTypeOf as bool
		# Cobra never requires that you wrap a type reference in typeof(Foo).
		# C# requires typeof() in a variety of circumstances and won't accept it in a variety of others.
		superNode = .superNode
		if superNode is nil
			return false
		else
			if superNode inherits DotExpr, return false
			if superNode inherits PostCallExpr, return false
			if superNode inherits BinaryOpExpr
				if this is superNode.right
					if superNode inherits InheritsExpr or superNode inherits AbstractToExpr
						return false
			return true

	def writeSharpDefForBreakdown(sw as SharpWriter) is override
		sw.write('typeof(')
		.writeSharpDef(sw)
		sw.write(')')


class AllOrAnyExpr
	is abstract, partial

	def writeSharpDef(sw as SharpWriter, parens as bool) is override
		sw.write('CobraImp.[.opName.capped](')
		.expr.writeSharpDefInContext(sw)
		sw.write(')')

	def writeSharpBreakdownItems(sw as SharpWriter)
		base.writeSharpBreakdownItems(sw)
		sw.write(', +1')
		.expr.writeSharpBreakdownItems(sw)
		sw.write(', -1')


class UnaryOpExpr
	is partial

	def writeSharpDef(sw as SharpWriter, parens as bool) is override
		if _op == 'PLUS'
			if parens
				sw.write('(')
			_expr.writeSharpDef(sw, false)
			if parens
				sw.write(')')
			return
		if _expr.type.isDynamic
			specs = OperatorSpecs.unaryOpSpecsByCobraText
			assert specs.containsKey(.token.text)
			spec = specs[.token.text]
			opText = Utils.sharpStringLiteralFor(spec.opMethodName)
			sw.write('CobraImp.DynamicOp([opText], ')
			_expr.writeSharpDef(sw, false)
			sw.write(')')
			return
		if parens
			sw.write('(')
		branch _op
			on 'MINUS'
				sw.write('-')
			on 'TILDE'
				sw.write('~')
			on 'NOT'
				sw.write('!')
			else
				throw FallThroughException(_op)
		_expr.writeSharpDef(sw)
		if parens
			sw.write(')')

	def writeSharpBreakdownItems(sw as SharpWriter)
		base.writeSharpBreakdownItems(sw)
		sw.write(', +1')
		_expr.writeSharpBreakdownItems(sw)
		sw.write(', -1')


class Literal
	is partial

	get asSharp as String
		return ''

	def writeSharpDef(sw as SharpWriter, parens as bool) is override
		sw.write(.asSharp)


class AtomicLiteral
	is partial

	get willWriteSharpBreakdownItems as bool is override
		return false


class BoolLit
	is partial

	get asSharp as String is override
		return if(_value, 'true', 'false')


class CharLit
	is partial

	get asSharp as String is override
		return "'" + _value.toString + "'"


class DecimalLit
	is partial

	get asSharp as String is override
		return _value.toString(Utils.cultureInfoForNumbers) + 'm'


class FractionalLit
	is partial

	get asSharp as String is override
		if _type == .compiler.floatType(32), suffix = 'f'
		else if _type == .compiler.floatType(64), suffix = ''
		else if _type == .compiler.decimalType, suffix = 'm'
		else, throw FallThroughException(_type)
		return _value.toString(Utils.cultureInfoForNumbers) + suffix


class FloatLit
	is partial

	get asSharp as String is override
		s = _value.toString(Utils.cultureInfoForNumbers)
		if s.indexOf('.')==-1
			s += '.0'
		if .token.info == 32
			s += 'f'
		return s


class IntegerLit
	is partial

	get asSharp as String is override
		s = ''
		if (info = .token.info) inherits int
			branch info
				on - 8, s = 'System.SByte'
				on + 8, s = 'System.Byte'
				on -16, s = 'System.Int16'
				on +16, s = 'System.UInt16'
				on -32, s = ''
				on +32, s = 'U'
				on -64, s = 'L'
				on +64, s = 'UL'
				else, throw FallThroughException(info)
		if s.length <= 2
			return _value.toString + s
		else
			return '([s])[_value.toString]'


class NilLiteral
	is partial

	get asSharp as String is override
		return 'null'


class StringLit
	is partial

	get asSharp as String is override
		return Utils.sharpStringLiteralFor(_string)


class StringSubstLit
	is partial

	def writeSharpDef(sw as SharpWriter, parens as bool) is override
		if _items.count>1
			sw.write('CobraImp.MakeString(')
		sep = ''
		for item in _items
			sw.write(sep)
			if item inherits StringLit
				item.writeSharpDef(sw, true)  # CC: axe the "true" when the bug about overload groups crossing inheritance is fixed
			else if item inherits FormattedExpr
				sw.write('CobraImp._printStringMaker.MakeString(')
				item.expr.writeSharpDef(sw)
				sw.write(',')
				sw.write(Utils.sharpStringLiteralFor(item.format))
				sw.write(')')
			else
				sw.write('CobraImp._printStringMaker.MakeString(')
				item.writeSharpDef(sw, false)
				sw.write(')')
			sep = ','
		if _items.count>1
			sw.write(')')


class BaseLit
	is partial

	get asSharp as String is override
		return 'base'


class ThisLit
	is partial

	get asSharp as String is override
		return .compiler.curBox.sharpThis


class VarLit
	is partial

	get asSharp as String is override
		return _name


class SequenceLit
	is abstract, partial

	def writeSharpBreakdownItems(sw as SharpWriter) is override  # CC: axe is override
		base.writeSharpBreakdownItems(sw)
		sw.write(', +1')
		for expr in _exprs
			expr.writeSharpBreakdownItems(sw)
		sw.write(', -1')


class ListLit
	is partial

	def writeSharpDef(sw as SharpWriter, parens as bool) is override
		innerType = (_type to Box).genericParams[0]
		sw.write('CobraImp.MakeList<[innerType.sharpRef]>(typeof([_type.sharpRef])')
		if _exprs.count
			sw.write(', ')
			sep = ''
			for expr in _exprs
				sw.write(sep)
				expr.writeSharpDef(sw, false)
				sep = ', '
		sw.write(')')


class ArrayLit
	is partial

	def writeSharpDef(sw as SharpWriter, parens as bool) is override
		sw.write('new [_type.sharpRef] { ')
		if _exprs.count
			sep = ''
			for expr in _exprs
				sw.write(sep)
				expr.writeSharpDef(sw, false)
				sep = ', '
		sw.write(' }')


class SetLit
	is partial

	def writeSharpDef(sw as SharpWriter, parens as bool) is override
		innerType = (_type to Box).genericParams[0]
		sw.write('CobraImp.MakeSet<[innerType.sharpRef]>(typeof([_type.sharpRef])')
		if _exprs.count
			sw.write(', ')
			sep = ''
			for expr in _exprs
				sw.write(sep)
				expr.writeSharpDef(sw, false)
				sep = ', '
		sw.write(')')


class DictLit
	is partial

	def writeSharpDef(sw as SharpWriter, parens as bool) is override
		assert (_type to Box).genericParams.count==2
		keyType   = (_type to Box).genericParams[0]
		valueType = (_type to Box).genericParams[1]
		sw.write('CobraImp.MakeDict<[keyType.sharpRef],[valueType.sharpRef]>(typeof([_type.sharpRef])')
		if _entries.count
			sw.write(', ')
			sep = ''
			for entry in _entries
				sw.write(sep)
				entry[0].writeSharpDef(sw)
				sw.write(',')
				entry[1].writeSharpDef(sw)
				sep = ', '
		sw.write(')')

	def writeSharpBreakdownItems(sw as SharpWriter) is override  # CC: axe is override
		base.writeSharpBreakdownItems(sw)
		sw.write(', +1')
		for entry in _entries
			# CC: keyExpr, valueExpr = entry
			keyExpr = entry[0]
			valueExpr = entry[1]
			keyExpr.writeSharpBreakdownItems(sw)
			valueExpr.writeSharpBreakdownItems(sw)
		sw.write(', -1')


class ToNilableOrNotExpr
	is abstract, partial

	def writeSharpBreakdownItems(sw as SharpWriter)
		base.writeSharpBreakdownItems(sw)
		_expr.writeSharpBreakdownItems(sw)


class ToNilableExpr
	is partial

	def writeSharpDef(sw as SharpWriter, parens as bool) is override
		if _expr.type.isReference
			# In C#/.NET, reference types are always "nilable"
			_expr.writeSharpDef(sw)
		else
			# ex: ((int?)x)
			# ex: ((Color?)Color.Black)
			sw.write('(([_expr.type.sharpRef]?)')
			_expr.writeSharpDef(sw, false)
			sw.write(')')


class ToNonNilableExpr
	is partial


	def writeSharpDef(sw as SharpWriter, parens as bool) is override
		type = _expr.type
		if type inherits NilableType and not (type to NilableType).theWrappedType.isReference
			# ex: (x).Value
			# ex: (obj.foo).Value
			sw.write('(')
			_expr.writeSharpDef(sw, false)
			sw.write(').Value')
		else if .compiler.options.boolValue('include-nil-checks')
			sw.write('(CobraCore._willCheckNil?CobraImp.CheckNonNil<[type.sharpRef]>([.sharpThis], [Utils.sharpStringLiteralFor(_expr.toCobraSource)], ')
			_expr.writeSharpDef(sw, false)
			sw.write(', [.sharpSourceSite]):')
			_expr.writeSharpDef(sw, false)
			sw.write(')')
		else
			_expr.writeSharpDef(sw, parens)


##
## Binary Expressions
##

class BinaryOpExpr
	is partial

	def writeSharpDef(sw as SharpWriter, parens as bool) is override
		if parens, sw.write('(')
		_writeSharpDef(sw)
		if parens, sw.write(')')

	def _writeSharpDef(sw as SharpWriter)
		pass

	def writeSharpBreakdownItems(sw as SharpWriter)
		base.writeSharpBreakdownItems(sw)
		sw.write(', +1')
		_writeSharpBreakdownItemsLeft(sw)
		_writeSharpBreakdownItemsRight(sw)
		sw.write(', -1')

	def _writeSharpBreakdownItemsLeft(sw as SharpWriter)
		_left.writeSharpBreakdownItems(sw)

	def _writeSharpBreakdownItemsRight(sw as SharpWriter)
		_right.writeSharpBreakdownItems(sw)


class AbstractAssignExpr
	is partial

	def writeSharpDef(sw as SharpWriter, parens as bool) is override
		if _trackLocal
			sw.write('CobraImp.SetLocal("[_trackName]", ')
		else if parens
			sw.write('(')
		_writeSharpDef(sw)
		if _trackLocal or parens
			sw.write(')')


class AssignExpr
	is partial

	def _writeSharpDef(sw as SharpWriter) is override
		# TODO:
		# if trackLocal:
		#	out.write('CobraImp.SetLocal("%s", ' % .left.name)
		if _left inherits IndexExpr
			if _left.target.type.isDynamic
				# assigning to an indexer of a dynamically typed target requires special code gen
				sw.write('CobraImp.SetIndexerValue(')
				_left.target.writeSharpDef(sw, false)
				sw.write(', ')
				_right.writeSharpDef(sw, false)
				for expr in _left.args
					sw.write(', ')
					expr.writeSharpDef(sw, false)
				sw.write(')')
				return
		handled = false
		if _left inherits IdentifierExpr
			sharpNames = _left.sharpAssignmentNames
			if sharpNames and sharpNames.count
				sharpNames.reverse
				for i in sharpNames.count
					sw.write(if(i==0, '', '='))
					assert sharpNames[i].length
					sw.write(sharpNames[i])
			else
				assert _left.sharpName <> ''
				sw.write(_left.sharpName)
			handled = true
		if not handled
			# `obj.foo = bar` where `obj` is dynamic, requires special handling
			if _left inherits DotExpr
				if _left.left.type.isDynamic
					assert _left.right inherits MemberExpr
					sw.write('CobraImp.SetPropertyValue(')
					_left.left.writeSharpDef(sw, false)
					sw.write(', ')
					sw.write(Utils.sharpStringLiteralFor((_left.right to MemberExpr).name.capped))
					sw.write(', ')
					_right.writeSharpDef(sw)
					sw.write(')')
					return
		if not handled
			# for something like "p.total = 0", cannot generate "(p.Total)=0" because then C# sees
			# the left hand side as an r-value instead an l-value/target. hence the false below.
			_left.writeSharpDef(sw, false)
		sw.write('=')
		_right.writeSharpDefInContext(sw)
		# handle the case where a type got backed up because of assignment inside of an if-inherits
		if _backUpIfInheritsStack
			assert (_left to dynamic).definition inherits IVar
			(_left to dynamic).definition.ifInheritsStack = Stack<of IType>(_backUpIfInheritsStack)


class NumericPromoExpr
	is partial

	def _writeSharpDefDynamic(sw as SharpWriter)
		specs = OperatorSpecs.binaryOpSpecsByCobraText
		assert specs.containsKey(.token.text)
		spec = specs[.token.text]
		opText = Utils.sharpStringLiteralFor(spec.opMethodName)
		sw.write('CobraImp.DynamicOp([opText], ')
		_left.writeSharpDef(sw)
		sw.write(', ')
		_right.writeSharpDef(sw)
		sw.write(')')


class AugAssignMathExpr
	is partial

	def _writeSharpDef(sw as SharpWriter) is override
		if _left.type.isDynamic
			_left.writeSharpDef(sw)
			sw.write(' = ')
			specs = OperatorSpecs.binaryOpSpecsByCobraText
			assert specs.containsKey(.token.text)
			spec = specs[.token.text]
			opText = Utils.sharpStringLiteralFor(spec.opMethodName)
			sw.write('CobraImp.DynamicOp([opText], ')
			_left.writeSharpDef(sw)  # TODO: add , false
			sw.write(', ')
			_right.writeSharpDef(sw)  # TODO: add , false
			sw.write(')')
			return
		op = ''
		sep = ','  # for the method call case
		branch _op
			on 'PLUS_EQUALS'
				op = '+='
			on 'MINUS_EQUALS'
				op = '-='
			on 'STAR_EQUALS'
				op = '*='
			on 'STARSTAR_EQUALS'
				op = 'CobraImp.PowerToEquals('
			on 'SLASH_EQUALS'
				op = '/='  # TODO: finish this
			on 'SLASHSLASH_EQUALS'
				op = '/='  # TODO: finish this
			on 'PERCENT_EQUALS'
				op = '%='
			else
				throw FallThroughException(_op)
		assert op.length
		if op.length==2
			_left.writeSharpDef(sw)
			sw.write(op)
			_right.writeSharpDef(sw)
		else
			sw.write(op)  # ex: 'CobraImp.Foo('
			_left.writeSharpDef(sw)
			sw.write(sep)
			_right.writeSharpDef(sw)
			sw.write(')')


class AugAssignBitwiseExpr
	is partial

	def _writeSharpDef(sw as SharpWriter) is override
		if _left.type.isDynamic
			_left.writeSharpDef(sw)
			sw.write(' = ')
			specs = OperatorSpecs.binaryOpSpecsByCobraText
			assert specs.containsKey(.token.text)
			spec = specs[.token.text]
			opText = Utils.sharpStringLiteralFor(spec.opMethodName)
			sw.write('CobraImp.DynamicOp([opText], ')
			_left.writeSharpDef(sw)  # TODO: add , false
			sw.write(', ')
			_right.writeSharpDef(sw)  # TODO: add , false
			sw.write(')')
			return
		op = ''
		branch _op
			on 'AMPERSAND_EQUALS'
				op = '&='
			on 'VERTICAL_BAR_EQUALS'
				op = '|='
			on 'CARET_EQUALS'
				op = '^='
			on 'DOUBLE_LT_EQUALS'
				op = '<<='
			on 'DOUBLE_GT_EQUALS'
				op = '>>='
			else
				throw FallThroughException(_op)
		assert op.length
		_left.writeSharpDef(sw)
		sw.write(op)
		_right.writeSharpDef(sw)


class BinaryBoolExpr
	is partial

	def _writeSharpDef(sw as SharpWriter) is override
		if _op=='IMPLIES'
			sw.write('!')
		_left.writeSharpDef(sw)
		branch _op
			on 'AND'
				sw.write('&&')
			on 'OR' or 'IMPLIES'
				sw.write('||')
		_right.writeSharpDef(sw)

	def _writeSharpBreakdownItemsRight(sw as SharpWriter) is override
		# have to respect the short circuit otherwise something like "s and s.length" will give
		# NullReference exception for "s.length"
		# solution is: given L and R,
		# write:   "R", (!(L) ? "short-circuted" : (R).ToString())
		# that's for 'AND'. for, 'OR', remove the !, for 'IMPLIES' it's like AND

		# so rather than:
		# _right.writeSharpBreakdownItems(sw)
		# do this:
		src = Utils.sharpStringLiteralFor(_right.toCobraSource)
		sharpNot = if(_op=='OR', '', '!')
		sw.write(', [src], new CobraDirectString([sharpNot]')
		_left.writeSharpDefForBreakdown(sw)
		sw.write(' ? "(short-circuited)" : CobraCore.ToTechString(')
		_right.writeSharpDefForBreakdown(sw)
		sw.write('))')


class BinaryBitwiseExpr
	is partial

	def _writeSharpDef(sw as SharpWriter) is override
		if _type.isDynamic
			_writeSharpDefDynamic(sw)
			return
		op = ''
		branch _op
			on 'AMPERSAND'
				op = '&'
			on 'VERTICAL_BAR'
				op = '|'
			on 'CARET'
				op = '^'
			on 'DOUBLE_LT'
				op = '<<'
			on 'DOUBLE_GT'
				op = '>>'
			else
				throw FallThroughException(_op)
		assert op.length
		_left.writeSharpDef(sw)
		sw.write(op)
		_right.writeSharpDef(sw)


class BinaryMathExpr
	is partial

	def _writeSharpDef(sw as SharpWriter) is override
		if _type.isDynamic
			_writeSharpDefDynamic(sw)
			return
		intType = .compiler.anyIntType
		left = _left
		right = _right
		op = ''
		pre = ''
		sep = ','  # for the method call case
		branch _op
			on 'PLUS'
				op = '+'
			on 'MINUS'
				op = '-'
			on 'STAR'
				op = '*'
			on 'STARSTAR'
				op = 'CobraImp.PowerTo('
			on 'SLASH'
				op = '/'
				if _left.isKindOf(intType) and _right.isKindOf(intType)
					pre = '(decimal)'
			on 'SLASHSLASH'
				if left.isKindOf(intType) and right.isKindOf(intType)
					op = '/'
				else if left.isKindOf(.compiler.decimalType) or right.isKindOf(.compiler.decimalType)
					op = 'Decimal.Floor('
					sep = '/'
				else if left.isKindOf(.compiler.anyFloatType) or right.isKindOf(.compiler.anyFloatType)
					op = 'Math.Floor('
					sep = '/'
				else
					throw FallThroughException([left.type, right.type])
			on 'PERCENT'
				op = '%'
			else
				throw FallThroughException(_op)
		assert op.length
		sw.write(pre)
		if op.length==1
			_left.writeSharpDef(sw)
			sw.write(op)
			_right.writeSharpDef(sw)
		else
			sw.write(op)  # ex: 'CobraImp.Foo('
			_left.writeSharpDef(sw)
			sw.write(sep)
			_right.writeSharpDef(sw)
			sw.write(')')


class CompareExpr
	is partial

	def _writeSharpDef(sw as SharpWriter) is override
		left = _left
		right = _right
		op = _op
		# Compute the C# operation which will be an operator or method call
		if op=='EQ' or op=='NE'
			if not left.type.isReference and not right.type.isReference
				op = _cobraToSharp[_op]
			else
				done = false
				stringType = .compiler.libraryType('System.String')
				if left.isKindOf(stringType) and right.isKindOf(stringType)  # TODO: check for static comparison operations instead
					op = _cobraToSharp[_op]
					done = true
				else if left.type inherits Box  # TODO: try skipping on requiring that the type is a Box
					leftBox = left.type to Box
					compareTo = leftBox.memberForName('compareTo')
					if compareTo and compareTo.isMethod and compareTo.resultType.isDescendantOf(.compiler.anyIntType) and right.type.isDescendantOf(leftBox)  # need last condition to prevent someString.CompareTo(someChar)
						op = '.CompareTo('
						done = true
				if not done
					assert op in ['EQ', 'NE']
					assert op == .token.which
					op = if(op=='EQ', 'CobraImp.Equals(', 'CobraImp.NotEquals(')
		else if op=='IS' or op=='ISNOT'
			if left.type inherits PrimitiveType and right.type inherits PrimitiveType
				op = _cobraToSharp[_op]
			else if left.type.isReference and right.type.isReference
				# skip the CobraImp.Is call for faster performance
				op = if(op=='IS', 'System.Object.ReferenceEquals(', '!System.Object.ReferenceEquals(')
			else
				# non-trivial situation.. fall back to runtime support
				op = if(op=='IS', 'CobraImp.Is(', 'CobraImp.IsNot(')
		else
			if left.type.isDynamic or right.type.isDynamic
				sw.write('CobraImp.DynamicCompare(')
				left.writeSharpDef(sw, false)
				sw.write(', ')
				right.writeSharpDef(sw, false)
				sw.write(')[_cobraToSharp[_op]]0')
				return
			else
				done = false
				if left.type inherits Box  # TODO: try skipping on requiring that the type is a Box
					leftBox = left.type to Box
					compareTo = leftBox.memberForName('compareTo')
					if compareTo and compareTo.isMethod and compareTo.resultType.isDescendantOf(.compiler.anyIntType) and left.type == right.type  # need last condition to prevent someString.CompareTo(someChar)
						op = '.CompareTo('
						done = true
				if not done
					op = _cobraToSharp[_op]
		# Write the C# code
		if op.length<=2
			left.writeSharpDef(sw)
			sw.write(op)
			right.writeSharpDef(sw)
		else if op == '.CompareTo('
			left.writeSharpDef(sw)
			sw.write(op)
			right.writeSharpDef(sw, false)
			sw.write(') [_cobraToSharp[_op]] 0')
		else if op.endsWith('(')
			sw.write(op)
			left.writeSharpDef(sw)
			sw.write(',')
			right.writeSharpDef(sw)
			sw.write(')')
		else
			throw FallThroughException(op)


class DotExpr
	is partial

	def _writeSharpDef(sw as SharpWriter) is override
		if _left.receiverType.isDynamic
			# handle dynamic typing
			if _right inherits MemberExpr
				sw.write('CobraImp.GetPropertyValue(')
				_left.writeSharpDef(sw, not _left inherits DotExpr)
				sw.write(', ')
				sw.write(Utils.sharpStringLiteralFor(_right.name.capped))
				sw.write(')')
			else if _right inherits CallExpr
				sw.write('CobraImp.InvokeMethod(')
				_left.writeSharpDef(sw, not _left inherits DotExpr)
				sw.write(', ')
				sw.write(Utils.sharpStringLiteralFor(_right.name.capped))
				for arg in _right.args
					sw.write(', ')
					arg.writeSharpDef(sw, false)
				sw.write(')')
			else
				throw FallThroughException(_right)
		else
			# Given Cobra "A.B.C()" where C is a class/type/struct, then the C# needs to be "new A.B.C()"
			# (But stuff like this makes me wonder if the ASTs should be doing some transformations, like collapsing qualified types.)
			if _dotRightExpr.member inherits BoxMember
				backing = (_dotRightExpr.member to BoxMember).sharedMethodBacking
				if backing
					# example:  Cobra: c.isUpper   C#: char.IsUpper(c)
					# also used for extension methods under .NET 2.0
					sw.write(backing+'(')
					_left.writeSharpDef(sw, false)
					if _right inherits CallExpr
						for arg in _right.args
							sw.write(', ')
							arg.writeSharpDefInContext(sw)
					sw.write(')')
					return
			# handle static typing
			# don't write 'this' for shared members
			writeThis = true
			if _left inherits ThisLit
				if _right inherits CallExpr
					defi = _right.definition
					if defi inherits IMember
						writeThis = not defi.isShared
					else
						# TODO: compiler bug stimulated by following line:
						# throw FallThroughException({'right': _right, 'defi': defi})
						throw FallThroughException(defi)
				else if _right inherits MemberExpr
					writeThis = not _right.definition.isShared
			else if .curCodeMember inherits Initializer and _right inherits IDotRightExpr and (_right to IDotRightExpr).name == 'init' and _left inherits ThisOrBaseLit
				# Well, in practice this doesn't really happen because Constructer.innerWriteSharpDef usurps the code gen for base calls
				Stmt.inInitCall = true
				didSetInInitCall = true
			if writeThis
				if _left.needsContextCast
					_left.writeSharpDefInContext(sw)
				else
					_left.writeSharpDef(sw, not _left inherits DotExpr)
				sw.write('.')
			_right.writeSharpDef(sw, false)
			if didSetInInitCall
				Stmt.inInitCall = false

	def _writeSharpBreakdownItemsLeft(sw as SharpWriter) is override
		if not _left.type.isDescendantOf(.compiler.typeType) # feels like a cheap escape...  # TODO: still needed? what is this?
			_left.writeSharpBreakdownItems(sw)


class InExpr
	is partial

	def writeSharpDef(sw as SharpWriter, parens as bool) is override
		branch _op
			on 'NOTIN', sw.write('!')
			on 'IN', pass
			else, throw FallThroughException(_op)
		if _containsExpr
			_containsExpr.writeSharpDef(sw, parens)
		else
			sw.write('CobraImp.In(')
			_left.writeSharpDef(sw, false)
			sw.write(',')
			_right.writeSharpDef(sw, false)
			sw.write(')')
