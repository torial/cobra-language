use System.Reflection

class Module
	is abstract
	inherits Node

	# TODO: Seems that much of Module's guts should be moved down to CobraModule

	var _fileName as String
	var _sharpFileName = ''
	var _docString as String?

	def init(fileName as String, verbosity as int, docString as String)
		require fileName.length
		base.init
		_fileName = fileName
		_docString = docString
		# TODO: what's going on with verbosity?

	get docString from var

	get fileName from var

	get sharpFileName from var

	get isCobraLibrary as bool
		return _fileName.endsWith('CobraLang.cobra') or _fileName.endsWith('CobraLang.cs') or _fileName.endsWith('SystemInterfaces.cobra') or _fileName.endsWith('Cobra.Lang.dll')

	get sharpSource as String
		if _sharpFileName.length
			return File.readAllText(_sharpFileName)
		else
			throw FallThroughException('csFileName is blank')

	def addMinFields
		base.addMinFields
		.addField('fileName', _fileName)

	def bindUse
		pass

	def writeSharpDef as Dictionary<of int, int>? is abstract

	def writeSharpTestInvocation(sw as SharpWriter)
		pass


class SharpModule
	inherits Module
	"""
	The purpose of a C# module is to allow the programmer to include .cs command for Cobra to
	incorporate in the final compilation.
	"""

	def init(fileName as String, verbosity as int)
		base.init(fileName, verbosity, '')
		_sharpFileName = fileName

	def writeSharpDef as Dictionary<of int, int>? is override
		if false
			# kind of silly, but it works:
			d = Dictionary<of int, int>()
			for i = 1 .. Utils.countChars(File.readAllText(_sharpFileName), c'\n')+1
				d[i] = i
			return d	
		return nil


class AssemblyModule
	inherits Module
	"""
	An assembly module represents a .dll
	"""
	
	var _topNameSpace as NameSpace
	var _mustBindInhList = List<of INameSpaceMember>()

	def init(ass as Assembly, globalNS as NameSpace)
		.init(ass, 0, globalNS)

	def init(ass as Assembly, verbosity as int, globalNS as NameSpace)
		base.init(ass.location, verbosity, '')
		_topNameSpace = NameSpace(globalNS, '(top namespace for assembly [ass])')
		_sharpFileName = ''

	get sharpSource as String is override
		return '(no C# source for [this])'

	def addMustBindInh(what as INameSpaceMember)
		require .compiler.curModule is this
		_mustBindInhList.add(what)

	get topNameSpace from var
		"""
		Returns the top namespace for this module.
		This is an implicit namespace that is not unified (its unified namespace is the global namespace).
		"""

	def bindUse
		base.bindUse
		.topNameSpace.bindUse

	def _bindInh
		base._bindInh
		# .topNameSpace.bindInh - It's too expensive to scan all types in a DLL. Do them as needed.
		for item in _mustBindInhList, item.bindInh

	def _bindInt
		base._bindInt
		# .topNameSpace.bindInt - It's too expensive to scan all types in a DLL. Do them as needed.

	def writeSharpDef as Dictionary<of int, int>? is override
		return nil


class CobraModule
	inherits Module

	var _topNameSpace as NameSpace
	
	def init(fileName as String, verbosity as int, docString as String, globalNS as NameSpace)
		base.init(fileName, verbosity, docString)
		_topNameSpace = NameSpace(globalNS, '(top namespace for module [fileName])')
		if not _fileName.endsWith('SystemInterfaces.cobra')
			_sharpFileName = _fileName + '.cs'

	get topNameSpace from var
		"""
		Returns the top namespace for this module.
		This is an implicit namespace that is not unified (its unified namespace is the global namespace).
		"""

	def addSubFields
		base.addSubFields
		.addField('topNameSpace', _topNameSpace)

	def bindUse
		base.bindUse
		.topNameSpace.bindUse

	def _bindInh
		base._bindInh
		.topNameSpace.bindInh

	def _bindInt
		base._bindInt
		.topNameSpace.bindInt

	def _bindImp
		base._bindImp
		assert .didBindInt
		.topNameSpace.bindImp

	def writeSharpDef as Dictionary<of int, int>? is override
		file = File.createText(_sharpFileName)
		using sw = SharpWriter(file)
			.compiler.addIntermediateFile(_sharpFileName)
			sw.start(.fileName)
			sw.write('// [_sharpFileName]\n')
			sw.write('// Generated by Cobra\n')  # TODO: put version number here
			sw.write('// on [DateTime.now]\n')
			# TODO: list op sys
			sw.write('\n')
			.topNameSpace.writeSharpDef(sw)
			d = sw.sharpToCobraLineNum
		return d

	def writeSharpTestInvocation(sw as SharpWriter) is override
		.topNameSpace.writeSharpTestInvocation(sw)
