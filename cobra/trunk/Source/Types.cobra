use System.Reflection


interface ITypeProvider
	"""
	A type provider can provide essential types and serve as a place
	they are "uniqued" in order to avoid type duplication.

	The Cobra types themselves rely on having a type provider available to implement some of their methods.

	The main type provider is Compiler.
	There is also a BasicTypeProvider that is useful in setting up tests.
	"""

	def typeForName(name as String) as IType

	def typeOrNilForName(name as String) as IType?

	get boolType as BoolType

	get charType as CharType

	get decimalType as DecimalType

	def floatType as FloatType

	def floatType(size as int) as FloatType

	def intType as IntType

	def uintType as IntType

	def intType(signed as bool, size as int) as IntType
		require size in @[8, 16, 32, 64]

	get dynamicType as DynamicType

	get nilType as NilType

	get numberType as NumberType

	get passThroughType as PassThroughType

	get typeType as IType

	get unspecifiedType as UnspecifiedType

	get voidType as VoidType

	# TODO: def nilableType ... just like .variType. cache and get "is" testing

	def variType(type as IType) as VariType

	def libraryType(qualifiedName as String) as IType

	def clrType(qualifiedName as String) as System.Type


class BasicTypeProvider
	implements ITypeProvider
	"""
	TODO: rename to TypeProvider, change to a "mix-in" and have the Compiler class inherit it
	"""

	var _anyFloatType		as AnyFloatType?
	var _anyIntType			as AnyIntType?
	var _boolType			as BoolType?
	var _charType			as CharType?
	var _decimalType		as DecimalType?
	var _dynamicType		as DynamicType?
	var _floatTypes			=  Dictionary<of int, FloatType>()
	var _intTypes			=  Dictionary<of int, IntType>()
	var _nilType			as NilType?
	var _numberType			as NumberType?
	var _passThroughType	as PassThroughType?
	var _unspecifiedType	as UnspecifiedType?
	var _voidType			as VoidType?
	var _variTypes			as Dictionary<of IType, VariType>?

	def typeForName(name as String) as IType
		assert false, 'TODO'
		return .intType

	def typeOrNilForName(name as String) as IType?
		assert false, 'TODO'
		return nil

	get anyFloatType as AnyFloatType
		if _anyFloatType is nil
			_anyFloatType = AnyFloatType()
		return _anyFloatType to !

	get anyIntType as AnyIntType
		if _anyIntType is nil
			_anyIntType = AnyIntType()
		return _anyIntType to !

	get boolType as BoolType
		if _boolType is nil
			_boolType = BoolType()
		return _boolType to !

	get charType as CharType
		if _charType is nil
			_charType = CharType()
		return _charType to !

	get decimalType as DecimalType
		if _decimalType is nil
			_decimalType = DecimalType()
		return _decimalType to !

	get dynamicType as DynamicType
		if _dynamicType is nil
			_dynamicType = DynamicType()
		return _dynamicType to !

	def floatType as FloatType
		return .floatType(64)
	
	def floatType(size as int) as FloatType
		require size in [32, 64]
		type as FloatType?
		if _floatTypes.tryGetValue(size, out type)
			return type to !
		else
			type = _floatTypes[size] = FloatType(size, .anyFloatType)
			return type to !

	def intType as IntType
		return .intType(true, 32)

	def uintType as IntType
		return .intType(false, 32)

	def intType(signed as bool, size as int) as IntType
		require size in [8, 16, 32, 64] # CC: inherit from interface
		key = if(signed, -1, +1) * size
		type as IntType?
		if _intTypes.tryGetValue(key, out type)
			return type to !
		else
			type = _intTypes[key] = IntType(signed, size, .anyIntType)
			return type to !
		
	get nilType as NilType
		if _nilType is nil
			_nilType = NilType()
		return _nilType to !

	get numberType as NumberType
		return .decimalType

	get passThroughType as PassThroughType
		if _passThroughType is nil
			_passThroughType = PassThroughType()
		return _passThroughType to !

	get typeType as IType
		return .libraryType('System.Type')

	get unspecifiedType as UnspecifiedType
		if _unspecifiedType is nil
			_unspecifiedType = UnspecifiedType()
		return _unspecifiedType to !

	get voidType as VoidType
		if _voidType is nil
			_voidType = VoidType()
		return _voidType to !

	def variType(type as IType) as VariType
		if _variTypes is nil
			_variTypes = Dictionary<of IType, VariType>()
		else if _variTypes.containsKey(type)
			return _variTypes[type]
		_variTypes[type] = vt = VariType(type)
		return vt

	def libraryType(qualifiedName as String) as IType
		clrType = $sharp('Type.GetType(qualifiedName)') to Type?
		return BasicLibraryType(clrType)

	def clrType(qualifiedName as String) as System.Type
		return sharp'Type.GetType(qualifiedName)' to System.Type


class BasicLibraryType
	implements IType
	"""
	These objects are created by BasicTypeProvider and only for testing purposes.
	The real library types used by the compiler are instances of Class, Interface, Struct, etc.
	See BasicTypeProvider.libraryType and Compiler.libraryType.
	"""

	shared
		
		def systemObjectType as BasicLibraryType
			return BasicLibraryType($sharp('typeof(System.Object)'))

	var _clrType as Type

	def init(clrType as Type)
		_clrType = clrType

	def toString as String is override
		return '[.getType.name]([.clrType])'

	def equals(other as Object?) as bool is override
		if other
			if other inherits BasicLibraryType
				return .clrType == other.clrType
			else
				return false
		else
			return false

	def getHashCode as int is override
		return _clrType.getHashCode

	get clrType from var

	## IType Properties

	get innerType as IType?
		return nil

	get realType as IType
		return this

	get superType as IType?
		return if(.isSystemObjectClass, nil, .systemObjectType)

	## IType isFoo

	get isDynamic as bool
		return false

	get isSystemObjectClass as bool
		return _clrType.name == 'Object'

	get isSystemTypeClass as bool
		return _clrType.name == 'Type'

	def isAssignableTo(t as IType) as bool
		return this is t or t.isSystemObjectClass

	def isComparableTo(t as IType) as bool
		return this is t

	def isEquatableTo(t as IType) as bool
		return this is t

	def isDescendantOf(t as IType) as bool
		return this is t or t.isSystemObjectClass

	get isReference as bool
		return not _clrType.isValueType

	def isStrictDescendantOf(t as IType) as bool
		return this is not t and t.isSystemObjectClass

	## Methods

	def greatestCommonDenominatorWith(type as IType) as IType
		if type is this
			return this
		else
			return .systemObjectType

	def memberForName(name as String) as IMember?
		return nil

	def suggestionsForBadMemberName(name as String) as List<of String>
		return List<of String>()

	def secondaryConstructedTypeFor(box as Box, gpToType as Dictionary<of GenericParam, IType>) as IType
		return this

	## INode

	def bindAll as INode
		.bindInh
		.bindInt
		return .bindImp

	def bindInh
		_didBindInh = true

	var _didBindInh as bool
	get didBindInh from var

	def bindInt as INode
		_didBindInt = true
		return this

	var _didBindInt as bool
	get didBindInt from var

	def bindImp as dynamic
		_didBindImp = true
		return this

	var _didBindImp as bool
	get didBindImp from var

	get hasError as bool
		return false

	get serialNum as int
		return 1

	pro superNode as INode?
		get
			return nil
		set
			pass

	def toTechString as String
		return .toString

	def throwError(msg as String)
		throw NodeException(this, msg)

	def writeDeepString
		.writeDeepString(IndentedWriter(CobraCore.printDestination))

	def writeDeepString(iw as IndentedWriter)
		pass

	get deepString as String
		return .toString

	get minimalString as String
		return .toString
	
	get shallowString as String
		return .toString

	def replaceChild(find as INode, replace as INode) as bool
		throw NotImplementedException('[.getType.name].replaceChild')

	pro transformedFrom as INode?
		get
			return nil
		set
			throw NotImplementedException('[.getType.name].replaceChild')

	## INamedNode
	
	get name as String
		return .clrType.name

	get typeForIdentifier as IType
		return this # well should really be System.Type

	get typeForReceiver as IType
		return this

	get isMethod as bool
		return false

	pro isUsed as bool
		get
			return false
		set
			pass

	## IMember

	get attributes as AttributeList
		return AttributeList()

	get englishName as String
		return 'library type'

	get isCallable as bool
		return true

	get isShared as bool
		return true

	pro parentNameSpace as NameSpace?
		get
			return nil
		set
			pass

	get requiresThis as bool
		return false

	get resultType as IType
		return this

	def unNilReturnType
		pass

	def writeSharpTestInvocation(sw as SharpWriter)
		throw NoSharpGenException(this)

	## Code gen
	
	get sharpInit as String
		throw NoSharpGenException(this)

	get sharpName as String
		throw NoSharpGenException(this)

	get sharpNameComponent as String
		throw NoSharpGenException(this)

	get sharpParamRef as String
		throw NoSharpGenException(this)

	get sharpRef as String
		throw NoSharpGenException(this)

	def writeSharpDef(sw as SharpWriter)
		throw NoSharpGenException(this)


class NoSharpGenException
	inherits Exception
	
	def init(blt as BasicLibraryType)
		base.init('Not expecting to generate C# with BasicLibraryType ([blt])')


interface ITypeProxy
	inherits INode
	"""
	An ITypeProxy is a node that represents/stands-in for a type.
	Its .realType property returns that type, often by locating it among symbols.
	Implemented by CobraType, AbstractTypeIdentifier, NilableTypeProxy and ClrTypeProxy.
	"""

	# TODO: See above NOTE and consider adding name below. Also see _bindBase in Boxes.cobra which would benefit from .name
#	get name as String
#		"""
#		Return the name of the type.
#		"""

	get realType as IType
		"""
		Returns the type that this node represents or .throwError if the type cannot be located.
		"""


class AbstractTypeProxy
	is abstract
	inherits Node
	implements ITypeProxy

	get realType as IType is abstract


class TypeProxy
	inherits AbstractTypeProxy
	"""
	Once in awhile you might need to pass or use an ITypeProxy even though you already know the type (probably because it is a builtin type such as `int` or `dynamic`.
	In that case, you can use TypeProxy(someType)
	"""

	var _type as IType

	def init(type as IType)
		_type = type

	get realType as IType is override
		return _type


class LibraryTypeProxy
	inherits AbstractTypeProxy
	"""
	Relies on .compiler.libraryType(qualifiedName) to locate the Cobra type.
	Useful for the primitive types that need a reference to, for example, System.Char.
	"""

	var _qualifiedName as String
	
	def init(qualifiedName as String)
		_qualifiedName = qualifiedName

	get qualifiedName from var
	
	get realType as IType is override
		return .compiler.libraryType(_qualifiedName)


class NilableTypeProxy
	inherits AbstractTypeProxy
	"""
	Returns the type proxy it is given wrapped in a NilableType.
	Used when scanning, for example, method arguments in DLLs. See _scan* in Box.
	"""

	var _innerType as ITypeProxy

	def init(innerType as ITypeProxy)
		_innerType = innerType

	get innerTypeProxy as ITypeProxy
		return _innerType

	def addMinFields
		base.addMinFields
		.addField('innerTypeProxy', .innerTypeProxy)

	get realType as IType is override
		return NilableType(_innerType.realType)


class VariTypeProxy
	inherits AbstractTypeProxy
	"""
	Returns the type proxy it is given wrapped in a VariType.
	Used when scanning, for example, method arguments in DLLs. See _scan* in Box.
	"""

	var _innerType as ITypeProxy

	def init(innerType as ITypeProxy)
		_innerType = innerType

	get innerTypeProxy as ITypeProxy
		return _innerType

	def addMinFields
		base.addMinFields
		.addField('innerTypeProxy', .innerTypeProxy)

	get realType as IType is override
		return VariType(_innerType.realType)


class ClrTypeProxy
	inherits AbstractTypeProxy
	"""
	Acts as an ITypeProxy where the CLR type is known.
	Typically used when scanning DLLs.
	"""

	shared

		var _cobraNameForSharpGenericNameCache = Dictionary<of String, String>()

		def cobraNameForSharpBoxName(name as String) as String
			"""
			Returns 'Foo' for 'Foo' and 'Foo<of,>' for 'Foo`2'
			In other words, works for generic and non-generic classes, structs and interfaces.
			Does *not* work for arrays, pointers, etc.
			"""
			if '`' not in name
				return name
			if _cobraNameForSharpGenericNameCache.containsKey(name)
				return _cobraNameForSharpGenericNameCache[name]
			else
				parts = name.split(c'`')
				count = int.parse(parts[1]) to int
				cobraName = parts[0] + '<of'
				for i = 1 .. count
					cobraName += ','
				cobraName += '>'
				_cobraNameForSharpGenericNameCache[name] = cobraName
				return cobraName

	var _clrType as Type

	def init(clrType as Type)
		base.init
		_clrType = clrType

	def addMinFields
		base.addMinFields
		.addField('clrType', _clrType)

	get realType as IType is override
		return _realType(_clrType)

	def _realType(clrType as Type) as IType
		assert .compiler.basicTypes.count > 9   # should have bool, char, all the ints, etc.
		
		# Must return the Cobra primitive types in place of System.Boolean, System.Char, System.Int16, etc.
		# because it's the primitives that are used all over the compiler.

		clrPrimitiveToIType = .compiler.clrPrimitiveToITypeCache
		if clrPrimitiveToIType is nil or clrPrimitiveToIType.count == 0
			clrPrimitiveToIType = Dictionary<of System.Type, IType>()
			for bt in .compiler.basicTypes
				if bt.systemAliasProxy
					key = .compiler.clrType((bt.systemAliasProxy to LibraryTypeProxy).qualifiedName)
					clrPrimitiveToIType[key] = bt
			assert clrPrimitiveToIType.count == 0 or clrPrimitiveToIType.count > 9
		basicType as IType?
		if clrPrimitiveToIType.tryGetValue(clrType, out basicType)
			return basicType to !
		
		# handle wrapped types, like arrays and pointers, with recursive calls
		if clrType.isArray
			# assert clrType.name.endsWith(r'[]') # could be [,] so TODO: handle multidim arrays
			return ArrayType(_realType(clrType.getElementType to !))
		else if clrType.isNested and not clrType.isGenericParameter
			declaringType = _realType(clrType.declaringType to !)
			declaringType.bindInh  # trigger scanning the clr type if needed
			potential = declaringType.memberForName(clrType.name)
			if potential is nil
				# comes up on MS Windows .NET 2.0 for multiple types when using System.Windows.Forms
				# error: Cannot locate nested CLR type "System.Windows.Forms.UnsafeNativeMethods+IOleControl" (simple name is "IOleControl").
				if 'NativeMethods' in clrType.toString
					return _hack(clrType)
				.throwError('Cannot locate nested CLR type "[clrType]" (simple name is "[clrType.name]").')
			else if potential inherits IType
				return potential
			else
				.throwError('Located CLR type spec "[clrType]" but got a [potential.englishName] instead of a type.')
		else if clrType.isPointer
			assert clrType.name.endsWith('*')
			# TODO: handle pointer types
			return _realType(clrType.getElementType to !)
		else if clrType.isByRef
			assert clrType.name.endsWith('&')
			# TODO: handle ref types
			return _realType(clrType.getElementType to !)

		# generic parameters
		if clrType.isGenericParameter
			return GenericParam(clrType)

		# compute type name
		typeName = clrType.name
		if '`' in typeName
			# generic like IComparable`1
			assert r'[' not in typeName
			typeName = .cobraNameForSharpBoxName(typeName)
		else if typeName == 'IBuiltInEvidence' or typeName == 'IConstantMembershipCondition'
			# TODO: wow really weird.  2007-11-20.  problem on Mono. How about on .NET?
			typeName = 'IMembershipCondition'
		else if typeName[typeName.length-1].isLetterOrDigit
			pass
		else
			msg = 'Cannot locate CLR type "[clrType]".'
			if clrType.namespace and clrType.namespace.startsWith('System.')
				# Since most (and usually all) System.Foo types can be read, don't choke up on a bad one
				# TODO: .compiler.warning(msg)
				typeName = 'Object'
			else
				.throwError(msg)

		# compute namespace
		nameParts = clrType.namespace.split(c'.')
		member = .compiler.globalNS.symbolForName(nameParts[0])
		if member inherits NameSpace
			curNS = member
		else
			msg = 'Cannot find top level namespace "[nameParts[0]]" of CLR type "[clrType.fullName]".'
			if nameParts[0] == 'Accessibility'
				# not sure what's going on here. happens with: cobra -c -t:winexe -r:System.Windows.Forms winforms1.cobra  on Novell Mono 1.2.6. Does it happen with .NET?
				if Utils.isDevMachine
					print msg  # could do a .compiler.warning, but then testify gets messed up
			return _hack(clrType)
#			.throwError(msg)
		i = 1
		while i < nameParts.length
			possible = curNS.declForName(nameParts[i])
			if possible is nil
				# .throwError('Cannot find "[nameParts[i]]" at component [i+1] of CLR type "[clrType.fullName]".')
				# TODO:
				# error: Cannot find "Xml" at component 2 of CLR type "System.Xml.XmlNode".
				# error: Cannot find "ObjectModel" at component 3 of CLR type "System.Collections.ObjectModel.Collection`1[[System.Net.Mail.AlternateView, System, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]]".
				return _hack(clrType)
			else if possible inherits NameSpace
				curNS = possible
			else
				.throwError('Found "[nameParts[i]]" at component [i+1] of CLR type "[clrType.fullName]", but it is a [possible.englishName].')
			i += 1

		# return namespace member
		member = curNS.declForName(typeName)
		if member inherits IType
			if clrType.isGenericType and not clrType.isGenericTypeDefinition
				# So we have something like ICollection<of KeyValuePair<of TKey,TValue>> which is all CLR types.
				# We need the Cobra types of those args so we can construct the Cobra type from the generic cobra type
				# otherwise, we would just end up returning the generic definition.
				args = List<of IType>()
				for genArg in clrType.getGenericArguments
					args.add(_realType(genArg))
				member = (member to Box).constructedTypeFor(args)
			return member
		else
			msg = 'Cannot locate CLR type "[clrType]".'
			if clrType.namespace and clrType.namespace.startsWith('System.')
				# TODO: On .NET 2.0 only \Tests\110-basics-two\550-collection-equality.cobra
				# fails with: Cannot locate CLR type "System.Collections.KeyValuePairs[]".
				# Figure out why.
				if .compiler and .compiler.verbosity > 1
					print msg
				# TODO: .compiler.warning(msg)
				return .compiler.libraryType('System.Object')
			else
				.throwError(msg)
		return .compiler.intType  # CC: to make C# code gen happy.

	def _hack(clrType as Type) as IType
		if clrType.isInterface
			return ClrTypeProxy($sharp('typeof(ICloneable)')).realType
		else
			return ClrTypeProxy(Object).realType


interface IType
	inherits ITypeProxy, IMember

	def isAssignableTo(type as IType) as bool

	def isDescendantOf(type as IType) as bool

	def isStrictDescendantOf(type as IType) as bool

	get isDynamic as bool
		"""
		Returns true if the type is a dynamic type.
		You cannot use `t inherits DynamicType` because a NilableType gives false for that even though it may be dynamic.
		"""

	get isReference as bool
		"""
		Returns true if the type is a reference type, such as a class, interface or nilable type.
		And as opposed to value type such as a struct, int, etc.).
		"""

	get isSystemObjectClass as bool
		"""
		Return true if this type represents/is System.Object.
		"""

	get isSystemTypeClass as bool
		"""
		Return true if this type represents/is System.Type.
		"""

	def isComparableTo(t as IType) as bool
		"""
		Returns true if this type can be compared to the given type via comparison operators such as `>`, `<=`, etc.
		"""

	def isEquatableTo(t as IType) as bool
		"""
		Returns true if this type can be compared to the given type via `is`, `is not`, `==` and `<>`.
		"""

	def secondaryConstructedTypeFor(box as Box, gpToType as Dictionary<of GenericParam, IType>) as IType
		"""
		Makes a new generic type, if needed, using the given map from generic params to types.
		Returns this type if no generic construction is necessary.
		This method is invoked during the type construction for return types, parameter types, etc.
		"""

	def greatestCommonDenominatorWith(type as IType) as IType
		"""
		Return the most specific type that is compatible with both this type and the arg.
		The worst case scenarious are Object and Object? since all types are compatible
		with Object. Used for at least if() expressions, list literals and dictionary
		literals.
		"""

	get innerType as IType?
		"""
		Used by the enumerable for statement to infer the type of the control variable.
		Examples:
		 	List<of int> --> int
			List<of dynamic> --> dynamic
			ArrayList --> Object
			String --> char
			Object --> nil
		"""

	get superType as IType?
		"""
		Returns the super type of this type.
		If an implementor has multiple super types (interfaces do), then this method should
		return nil and other methods such as isDescendantOf() and memberForName() must be
		sure to take the multiple super types into consideration.
		"""

	def memberForName(name as String) as IMember?
		"""
		Used for `foo.bar` where this type is the type of `foo`.
		Should return members that are inherited (if any).
		"""

	def suggestionsForBadMemberName(name as String) as List<of String>
		"""
		When .memberForName returns nil for the given name, provide suggestions of names that actually exist.
		"""

	## Code gen

	get sharpInit as String

	get sharpNameComponent as String
		"""
		Returns a string that refers to this type and is suitable for embedding in a larger
		identifier (meaning there will be no punction, spaces or C# comments).
		"""

	get sharpRef as String
		"""
		Returns a string that refers to this type.
		Examples: 'int'  'List<String>'  'object'
		"""

	get sharpParamRef as String
		"""
		Returns a string that refers to this type including any necessary parameter declaration
		specification such as C# 'params' or 'out'. Invoked by Param.writeSharpDef.
		"""


class CobraType
	is abstract
	inherits Node
	implements IType, ITypeProxy
	"""
	This is the parent type of all other types.
	It exists for organizational purposes.
	No actual expression is ever directly assigned this type.
	If you are looking for "dynamic", see DynamicType.
	If you are looking for "object", see ObjectType.
	If you are looking for the type of types, that would be typeProvider.typeType which is a cover for typeProvider.libraryType('System.Type').
	TODO: Could CobraType by a subclass of NamedNode instead?
	"""

	var _parentNameSpace as NameSpace?
	var _superType as IType?
	var _isUsed as bool

	def init
		.init(nil)

	def init(superType as IType?)
		base.init
		_superType = superType

	get attributes as AttributeList
		return AttributeList()
		
	get englishName as String is abstract

	get name as String
		return .getType.toString

	pro parentNameSpace from var

	get isCallable as bool
		return true

	get isDynamic as bool
		return false

	get isMethod as bool
		return false

	get isReference as bool is abstract

	get isShared as bool
		return true

	get isSystemObjectClass as bool
		return false

	get isSystemTypeClass as bool
		return false

	def isComparableTo(t as IType) as bool
		if t inherits NilableType
			t = t.theWrappedType
		compareTo = .memberForName('compareTo')
		if compareTo and compareTo.isMethod and compareTo.resultType is .compiler.intType and t.isDescendantOf(this)
			# TODO: check that the compareTo can take a `t` as an argument
			return true
		if t inherits DynamicType
			return true
		return false

	def isEquatableTo(t as IType) as bool
		if t inherits NilableType
			t = t.theWrappedType
		if .isAssignableTo(t) or t.isAssignableTo(this)
			return true
		return false

	get requiresThis as bool
		return false

	get resultType as IType?
		return this

	get typeForIdentifier as IType
		return .compiler.typeType

	get typeForReceiver as IType
		return this

	get innerType as IType?
		return nil

	get realType as IType
		return this

	get superType from var

	def secondaryConstructedTypeFor(box as Box, gpToType as Dictionary<of GenericParam, IType>) as IType
		return this

	def greatestCommonDenominatorWith(type as IType) as IType
		if this is type
			return this
		if type inherits NilableType
			return type.greatestCommonDenominatorWith(this)
		if type inherits NilType
			return NilableType(this)
		if .isDescendantOf(type)
			return type
		if type.isDescendantOf(this)
			return this
		if type inherits DynamicType
			return type
		# TODO: following is a guess -- haven't really thought about following both superTypes at the same time or if there is even any point
		if .superType and type.superType
			return .superType.greatestCommonDenominatorWith(type.superType to !)
		else
			return .typeProvider.libraryType('System.Object')

	def isAssignableTo(type as IType) as bool
		require
			.typeProvider
		body
			if type is .typeProvider.passThroughType
				return true
			if type is .typeProvider.dynamicType
				return true
			if type is .typeProvider.libraryType('System.Object')
				return true
			# TODO: remove this:
			if type inherits GenericParam
				return true
			# TODO: would this be needed if not for qualified types?
			if type inherits WrappedType
				return .isAssignableTo(type.theWrappedType to passthrough) # CC: bug with if-inherits changes the parameter type
			return .isDescendantOf(type)

	def isDescendantOf(type as IType) as bool
		"""
		Returns true if this type is a subtype (direct or indirect) of type.
		"""
		if not .didBindInh
			.bindInh
		if this is type
			return true
		curType = this to IType?
		counter = 0
		while true
			if curType is type
				return true
			curType = curType.superType
			if curType is nil
				break
			counter += 1
			assert counter < 1000
		return false

	def isStrictDescendantOf(type as IType) as bool
		if type is this
			return false
		else
			return .isDescendantOf(type)

	pro isUsed from var

	def declForName(name as String) as IMember?
		"""
		Returns nil by default.
		"""
		return nil

	def memberForName(name as String) as IMember?
		"""
		Returns a named member of System.Object by default.
		"""
		objectClass = .compiler.libraryType('System.Object')
		return objectClass.memberForName(name)

	def suggestionsForBadMemberName(name as String) as List<of String>
		suggs = List<of String>()
		if _superType
			suggs.addRange(_superType.suggestionsForBadMemberName(name))
		return suggs

	def equals(obj as Object?) as bool is override
		if obj is nil
			return false
		if obj inherits CobraType
			return .serialNum.equals(obj.serialNum)
		else
			return false

	def getHashCode as int is override
		return .serialNum.getHashCode

	def unNilReturnType
		# ack! apparently CobraType inherits IMember
		pass


	## Code gen

	get sharpInit as String is abstract

	get sharpName as String
		return .name

	get sharpNameComponent as String
		name = .name
		i = name.indexOf('/*')  # example: /*dynamic*/object
		if i <> -1
			j = name.indexOf('*/', i)
			name = name[:i] + name[j+2:]
		name = name.replace('.', '_').replace('<', '_').replace('>', '_').replace(', ', '_')
		return name

	get sharpRef as String
		return .sharpName

	get sharpParamRef as String
		return .sharpRef

	def writeSharpTestInvocation(sw as SharpWriter)
		pass


class ValueType
	is abstract
	inherits CobraType

	def init
		pass

	def init(superType as IType?)
		base.init(superType)

	get englishName as String is override
		return 'primitive type'

	get isReference as bool is override
		return false

	def equals(obj as Object?) as bool is override
		if obj is nil
			return false
		if not obj inherits CobraType
			return false
		if .getType is obj.getType
			return true
		return false

	def getHashCode as int is override
		return .getType.getHashCode


class PrimitiveType
	is abstract
	inherits ValueType
	"""
	The base class of BoolType, CharType, etc.
	Used in part for classification purposes (`t inherits PrimitiveType`).
	"""

	var _systemAliasProxy as ITypeProxy?
		"""
		Subclasses set this to a LibraryTypeProxy instead of ClrTypeProxy because, for example, the
		ClrTypeProxy for the clr type System.Boolean would return BoolType instance! Then the
		primitive type has a self reference when what it really wanted was the Struct instance for
		System.Boolean.
		"""

	var _systemAliasType as IType?

	def init
		pass

	def init(superType as IType?)
		base.init(superType)

	get systemAliasProxy from var

	get systemAliasType from var

	def _bindInh
		base._bindInh
		if _superType is nil
			_superType = .compiler.libraryClass('System.Object')
	
	def _bindInt
		base._bindInt
		if not _systemAliasType and _systemAliasProxy
			_systemAliasType = _systemAliasProxy.realType
		# causes an exception and isn't necessary:
		#if _systemAliasType
		#	_systemAliasType.bindInt

	def isAssignableTo(type as IType) as bool
		r = base.isAssignableTo(type)
		if not r
			r = _systemAliasType == type  # TODO: try "is"
		return r

	# TODO?
#	def isComparableTo(t as IType) as bool
#		return this is t

#	def isEquatableTo(t as IType) as bool

	def isComparableTo(t as IType) as bool
		if this is t
			return true
		else
			return base.isComparableTo(t)


class BoolType
	inherits PrimitiveType

	def init
		base.init
		_systemAliasProxy = LibraryTypeProxy('System.Boolean')

	get name as String is override
		return 'bool'

	get sharpInit as String is override
		return 'false'


class CharType
	inherits PrimitiveType

	var _clrType as Type
	var _box as Box?  # TODO: move this and related code up to PrimitiveType

	def init
		base.init
		_clrType = .typeProvider.clrType('System.Char')
		_systemAliasProxy = LibraryTypeProxy('System.Char')

	get name as String is override
		return 'char'

	def _bindInh
		base._bindInh
		_box = Class(Token.empty, '[.getType.name]_[.serialNum]', List<of IType>(), List<of String>(), AttributeList(), ClrTypeProxy(Object), List<of ITypeProxy>(), nil)
		_box.bindInh

	def _bindInt
		base._bindInt
		for methInfo in _clrType.getMethods(BindingFlags(Static, DeclaredOnly, Public))
			if methInfo.isSpecialName
				continue
			params = methInfo.getParameters
			if params and params.length and params[0].parameterType == Char
				# should be a member of char instances
				if params.length == 1
					# TODO: scan parameters and deal with overloads
					meth = Method(Token.empty, _box, Utils.cobraNameForSharpMemberName(methInfo.name), List<of GenericParam>(), List<of Param>(), ClrTypeProxy(methInfo.returnType), nil, List<of String>(), AttributeList(), '')
					meth.sharedMethodBacking = 'char.' + methInfo.name
					_box.addDecl(meth)
					# print '[.name].[meth.name]'
		_box.bindInt

	def memberForName(name as String) as IMember?
		member = base.memberForName(name)
		if member is nil
			member = _box.symbolForName(name, true)
		return member

	def isComparableTo(b as IType) as bool
		r = base.isComparableTo(b)
		if not r and b is .compiler.libraryType('System.String')
			r = true
		return r

	def isEquatableTo(t as IType) as bool
		r = base.isEquatableTo(t)
		if not r and t is .compiler.libraryType('System.String')
			r = true
		return r

	get sharpInit as String is override
		return '(char)0'


class DecimalType
	inherits NumberType

	def init
		base.init
		_systemAliasProxy = LibraryTypeProxy('System.Decimal')

	get name as String is override
		return 'decimal'

	def isComparableTo(t as IType) as bool
		r = base.isComparableTo(t)
		if not r and t inherits IntType
			r = true
		return r


class DynamicType
	inherits CobraType

	get englishName as String is override
		return 'basic type'

	get name as String is override
		return 'dynamic'

	def isAssignableTo(type as IType) as bool is override
		return true

	def isComparableTo(type as IType) as bool is override
		return true

	def isEquatableTo(type as IType) as bool is override
		return true

	get isDynamic as bool is override
		return true

	get isReference as bool is override
		return true

	get innerType as IType? is override
		return this

	get sharpInit as String is override
		return 'null'

	get sharpName as String is override
		return '/*dynamic*/object'

	def greatestCommonDenominatorWith(type as IType) as IType is override
		if this is type
			return this
		if type inherits NilableType
			return NilableType(this)
		if type inherits NilType
			return NilableType(this)
		return this


class AnyFloatType
	inherits NumberType
	
	def init
		pass
	
	def init(superType as IType?)
		base.init(superType)


class FloatType
	inherits AnyFloatType

	test
		saveTP = if(Node.hasTypeProvider, Node.typeProvider, nil)
		Node.typeProvider = BasicTypeProvider()
		try
			anyFloat = AnyFloatType()

			f32 = FloatType(32, anyFloat)
			assert f32.name == 'float32'
			assert f32.size == 32
			
			f64 = FloatType(64, anyFloat)
			assert f64.name == 'float'
			assert f64.size == 64

			assert f64.isEquatableTo(f32)
			assert f32.isEquatableTo(f64)
			assert f32.isAssignableTo(f64)
			assert not f64.isAssignableTo(f32)

			f32b = FloatType(32, anyFloat)
			assert f32 == f32b
			assert f32 <> f64
		finally
			Node.typeProvider = saveTP

	var _size as int
	var _clrType as Type

	def init(size as int, superType as IType?)
		require
			size in [8, 16, 32, 64]
			superType implies superType inherits AnyFloatType
		body
			base.init(superType)
			_size = size
			branch size
				on 32, _clrType = .typeProvider.clrType('System.Single')
				on 64, _clrType = .typeProvider.clrType('System.Double')
				else, throw FallThroughException(size)
			_systemAliasProxy = LibraryTypeProxy(_clrType.fullName)

	def addMinFields
		base.addMinFields
		.addField('size', .size)

	def equals(other as Object?) as bool is override
		if other is this
			return true
		else if other
			if other inherits FloatType
				return .size == other.size
			else
				return false
		else
			return false

	def getHashCode as int is override
		return .size.getHashCode

	get clrType from var

	get isDefaultFloatType as bool
		return _size == 64

	get isDefaultSize as bool
		return _size == 64

	get name as String is override
		if .isDefaultFloatType
			return 'float'
		else
			return 'float[.size]'

	get size from var

	def isAssignableTo(type as IType) as bool
		if type is this  # common case
			return true
		if type inherits FloatType
			if .size <= type.size
				return true
		return base.isAssignableTo(type)

	def isComparableTo(t as IType) as bool
		r = base.isComparableTo(t)
		if not r
			if t inherits IntType
				r = true
			else if t inherits FloatType
				r = true
		return r

	def greatestCommonDenominatorWith(type as IType) as IType is override
		if type inherits FloatType
			maxSize = if(type.size > .size, type.size, .size)
			return .compiler.floatType(maxSize)
		else
			return base.greatestCommonDenominatorWith(type)

	get sharpName as String is override
		return _clrType.name


class AnyIntType
	inherits NumberType
	
	def init
		pass

	def init(superType as IType?)
		base.init(superType)


class IntType
	inherits AnyIntType

	test
		saveTP = if(Node.hasTypeProvider, Node.typeProvider, nil)
		Node.typeProvider = BasicTypeProvider()
		try
			anyInt = AnyIntType()

			snt16 = IntType(true, 16, anyInt)
			assert snt16.name == 'int16'
			assert snt16.isSigned == true
			assert snt16.size == 16

			snt64 = IntType(true, 64, anyInt)

			assert snt64.isEquatableTo(snt16)
			assert snt16.isEquatableTo(snt64)
			assert snt16.isAssignableTo(snt64)
			assert not snt64.isAssignableTo(snt16)
			
			snt16b = IntType(true, 16, anyInt)
			assert snt16 == snt16b
			assert snt16 <> snt64
		finally
			Node.typeProvider = saveTP

	var _signed as bool
	var _size as int
	var _clrType as Type

	def init(signed as bool, size as int, superType as IType?)
		require
			size in @[8, 16, 32, 64]
			superType implies superType inherits AnyIntType
		body
			base.init(superType)
			_signed = signed
			_size = size
			if signed
				branch size
					on  8, _clrType = .typeProvider.clrType('System.SByte')
					on 16, _clrType = .typeProvider.clrType('System.Int16')
					on 32, _clrType = .typeProvider.clrType('System.Int32')
					on 64, _clrType = .typeProvider.clrType('System.Int64')
					else: throw FallThroughException(size)
			else
				branch size
					on  8, _clrType = .typeProvider.clrType('System.Byte')
					on 16, _clrType = .typeProvider.clrType('System.UInt16')
					on 32, _clrType = .typeProvider.clrType('System.UInt32')
					on 64, _clrType = .typeProvider.clrType('System.UInt64')
					else, throw FallThroughException(size)
			_systemAliasProxy = LibraryTypeProxy(_clrType.fullName)

	def addMinFields
		base.addMinFields
		.addField('isSigned', .isSigned)
		.addField('size', .size)

	def equals(other as Object?) as bool is override
		if other is this
			return true
		else if other
			if other inherits IntType
				return .isSigned == other.isSigned and .size == other.size
			else
				return false
		else
			return false

	def getHashCode as int is override
		code = if(.isSigned, -1, 1) * .size
		return code.getHashCode

	get clrType from var

	get isDefaultIntType as bool
		return _signed and _size == 32

	get isDefaultSize as bool
		return _size == 32

	get isSigned as bool
		return _signed
	
	get isUnsigned as bool
		return not _signed

	get name as String is override
		if .isDefaultIntType
			return 'int'
		prefix = if(.isSigned, '', 'u')
		if .isDefaultSize
			return '[prefix]int'
		else
			return '[prefix]int[.size]'

	get size from var

	def isAssignableTo(type as IType) as bool
		if type is this  # common case
			return true
		if type is .typeProvider.decimalType
			return true
		if type inherits AnyFloatType
			return true
		if type inherits IntType
			if .isSigned == type.isSigned and .size == type.size
				return true
			if .size < type.size
				return true
		return base.isAssignableTo(type)

	def isComparableTo(t as IType) as bool
		r = base.isComparableTo(t)
		if not r
			if t inherits IntType
				r = true
			else if t inherits DecimalType or t inherits FloatType
				r = true
		return r

	def greatestCommonDenominatorWith(type as IType) as IType is override
		if type inherits IntType
			# TODO: same size different signs
			maxSize = if(type.size > .size, type.size, .size)
			return .compiler.intType(.isSigned, maxSize)
		else
			return base.greatestCommonDenominatorWith(type)

	get sharpName as String is override
		return _clrType.name


class NilableType
	inherits WrappedType

	def init(t as IType)
		base.init(t)

	get englishName as String is override
		return 'nilable ' + _wrappedType.englishName

	get name as String is override
		return _wrappedType.name + '?'

	get isDynamic as bool is override
		return _wrappedType.isDynamic

	get isReference as bool is override
		return true  # wrong: return _wrappedType.isReference

	# TODO: I think the following is appropriate, but come up with a test case for it first.
	#get innerType
	#	return .wrappedType.innerType

	def isAssignableTo(type as IType) as bool is override
		if type inherits PassThroughType
			return true
		if type inherits NilableType
			return _wrappedType.isAssignableTo(type.theWrappedType)
		return false

	def isComparableTo(b as IType) as bool is override
		if b inherits NilType
			return true
		else
			return _wrappedType.isComparableTo(b)

	def isDescendantOf(type as IType) as bool
		return base.isDescendantOf(type) and _wrappedType.isDescendantOf(type)

	def isEquatableTo(b as IType) as bool is override
		if b inherits NilType
			return true
		else
			return _wrappedType.isEquatableTo(b)

	def memberForName(name as String) as IMember? is override
		return _wrappedType.memberForName(name)

	def greatestCommonDenominatorWith(type as IType) as IType is override
		if this is type
			return this
		if type inherits NilType
			return this
		if type inherits NilableType
			if _wrappedType is type.theWrappedType
				return this
			else
				return NilableType(_wrappedType.greatestCommonDenominatorWith(type.theWrappedType))
		return NilableType(_wrappedType.greatestCommonDenominatorWith(type))

	get sharpInit as String is override
		return 'null'

	get sharpRef as String is override
		return _wrappedType.sharpRef + if(not _wrappedType.isReference, '?', '')


class NilType
	inherits CobraType

	get englishName as String is override
		return 'nil type'

	get name as String is override
		return 'nil'

	get isReference as bool is override
		return true

	def isAssignableTo(type as IType) as bool is override
		if this is type
			return true
		if type is .compiler.passThroughType
			return true
		if type inherits NilableType
			return true
		return false

	def greatestCommonDenominatorWith(type as IType) as IType is override
		if this is type
			return this
		if type inherits NilableType
			return type
		else
			return NilableType(type)

# TODO:
#	def checkBinaryOp(self, op, right, compiler):
#		RootType.checkBinaryOp(self, op, right, compiler)
#		if op=='TO':
#			from Expressions import TypeExpr
#			type = right.realType
#			assert types, right
#			assert not inherits(type, NilType)
#			if not inherits(type, NilableType) and type is not tpassthrough:
#				.throwError('Cannot cast nil to a non-nil type.')

	get sharpInit as String is override
		return 'null'


class NumberType
	is abstract
	inherits PrimitiveType
	"""
	The base class for int, float and decimal.
	"""

	def init
		base.init

	def init(superType as IType?)
		base.init(superType)

	get sharpInit as String is override
		return '0'


class PassThroughType
	inherits CobraType
	"""
	This is a temporary helper type used while Cobra is still deficient in type checking mostly
	due to its inability to look up methods, properties, etc.

	Originally it overrode .isDescendantOf to always return true, but this mislead the C#
	body generation. The override was removed and now you have to check for it explicitly.
	"""

	def init
		base.init

	get englishName as String is override
		return 'basic type'

	get isReference as bool is override
		return true

	get name as String is override
		return 'passthrough'

	get innerType as IType? is override
		return this

	def isAssignableTo(type as IType) as bool is override
		return true

	get sharpInit as String is override
		return 'null'

	get sharpRef as String is override
		return 'object/*passthrough*/'


class VoidType
	inherits ValueType  # TODO: change to CobraType
	"""
	This type is used only for methods that don't declare a return type and therefore cannot return
	anything.
	"""

	def init
		base.init

	get englishName as String is override
		return 'void type'

	get name as String is override
		return 'void'

	get sharpInit as String is override
		throw Exception('Cannot init a void type.')


##
## Wrapped Types
##

class WrappedType
	is abstract
	inherits CobraType

	var _wrappedType as IType
	var _hashCode as int?

	def init(wrappedType as IType)
		base.init  # TODO: ? pass wrappedType.superType
		assert not wrappedType inherits NameSpace  # TODO: remove this when NameSpace is no longer an IType
		_wrappedType = wrappedType

	def addRefFields is override
		base.addRefFields
		.addField('wrappedType', _wrappedType)

	def equals(obj as Object?) as bool is override
		if this is obj
			return true
		if obj is nil
			return false
		if .getType is not obj.getType
			return false
		# at this point, not the identical object, but the class of obj is the same as ours
		if obj inherits WrappedType
			return _wrappedType.equals(obj._wrappedType)
		else
			throw FallThroughException([this, obj])

	def getHashCode as int is override
		if _hashCode is nil
			_hashCode = _wrappedType.getHashCode   # TODO: should be combined with something else so no collision with the actual wrapped type.
		return _hashCode to !

	# CC: this should work, but C# don't dig it. maybe for that reason we can't do it even when generating IL since we want C# to feel comfortable with Cobra based libraries
	#get wrappedType from _wrappedType

	get theWrappedType as IType
		return _wrappedType

	get innerType as IType? is override
		return _wrappedType.innerType

	get sharpInit as String is override
		return _wrappedType.sharpInit

	def secondaryConstructedTypeFor(box as Box, gpToType as Dictionary<of GenericParam, IType>) as IType is override
		thisType = .getType
		return thisType(_wrappedType.secondaryConstructedTypeFor(box, gpToType))


class ArrayType
	inherits WrappedType
	"""
	Represents a .NET array.
	Only single dimension arrays have been tested and are officially supported. These are common in
	the BCL as return types and sometimes as parameters. Multi-dim and jagged arrays are not popular.
	Also, most projects can get by just fine with nested List<of>s.
	TODO: Nevertheless, this should be expanded.
	TODO: Get this related to System.Array.
	"""

	test
		saveTP = if(Node.hasTypeProvider, Node.typeProvider, nil)
		Node.typeProvider = BasicTypeProvider()
		try
			a1 = ArrayType(BoolType())
			a2 = ArrayType(BoolType())
			assert a1 is not a2
			assert a1 == a2
		finally
			Node.typeProvider = saveTP

	var _box as Box?

	def init(wrappedType as IType)
		base.init(wrappedType)

	get englishName as String is override
		return 'array of ' + ''  # TODO: causes the compiler to choke: if(wrappedType, wrappedType.name, wrappedTypeNode.name)

	get innerType as IType? is override
		return _wrappedType

	get isReference as bool is override
		return true

	get name as String is override
		return _wrappedType.name+r'[]'

	def isAssignableTo(type as IType) as bool is override
		if base.isAssignableTo(type)
			return true
		if type inherits ArrayType
			if _wrappedType == type.theWrappedType
				return true
		return false

	def _bindInh
		base._bindInh
		ienum = .compiler.libraryBox('System.Collections.Generic.IEnumerable<of>')
		_superType = ienum.constructedTypeFor([.theWrappedType])

	def memberForName(name as String) as IMember?
		member = base.memberForName(name)
		if member is nil
			if _box is nil
				# TODO: make members based on System.Array
				_box = Class(Token.empty, '[.getType.name]_[.serialNum]', List<of IType>(), List<of String>(), AttributeList(), nil, List<of ITypeProxy>(), nil)
				indexer = Indexer(Token.empty, _box, r'[]', [Param(Token('', 1, 1, 1, 'ID', 'index', nil), .compiler.intType)], _wrappedType, List<of String>(), AttributeList(), '')
				_box.addDecl(indexer)
				lengthProp = Property(Token.empty, _box, 'length', .compiler.intType, List<of String>(), AttributeList(), '')
				_box.addDecl(lengthProp)
				_box.bindAll
			member = _box.symbolForName(name, true)
		return member

	get sharpRef as String is override
		return '[_wrappedType.sharpRef]' + r'[]'

	get sharpInit as String is override
		return 'null'


class VariType
	inherits ArrayType
	"""
	Represents the type for variable number of arguments:
		def sumInts(nums as vari int)
	Not valid for non-parameters such as locals and class fields.
	"""

	def init(wrappedType as IType)
		base.init(wrappedType)

	get englishName as String is override
		return 'variable args type'

	get innerType as IType? is override
		return _wrappedType

	get name as String is override
		return 'vari ' + _wrappedType.name

	get sharpRef as String is override
		return '[_wrappedType.sharpRef]' + r'[]'

	get sharpParamRef as String is override
		return 'params ' + .sharpRef


class UnspecifiedType
	inherits CobraType
	"""
	This is for the compiler's internal use.
	See CobraParser.localVarDecl and the methods that use it.
	"""

	get englishName as String is override
		return 'unspecified'

	get isReference as bool is override
		return true
	
	get sharpInit as String is override
		return '!UnspecifiedType!'


class AbstractTypeIdentifier
	is abstract
	inherits SyntaxNode
	implements ITypeProxy
	"""
	The ancestor class for specific kinds of type identifiers including TypeIdentifier, GenericTypeIdentifier, WrappedTypeIdentifier and more.
	"""

	var _name as String
	var _actualType as IType? is private
	var _didResolveType as bool is private

	def init(token as IToken, name as String)
		base.init(token)
		_name = name

	def init(token as IToken, name as String, type as IType)
		.init(token, name)
		_actualType = type
		_didResolveType = true

	def addMinFields is override
		base.addMinFields
		.addField('name', _name)
		.addField('didResolveType', _didResolveType)

	def addRefFields is override
		base.addSubFields
		.addField('actualType', _actualType)

	get name from var

	get actualType from var

	get didResolveType from var

	get realType as IType
		ensure .actualType
		if not .didResolveType
			_actualType = _resolveType()
			assert .actualType
			_didResolveType = true
		assert _actualType
		return _actualType to !

	def equals(other as Object?) as bool is override
		if other is nil
			return false
		if this is other
			return true
		if other inherits AbstractTypeIdentifier
			if _actualType and other._actualType
				return _actualType.equals(other._actualType)
			else
				return _name.equals(other._name)
		return false

	def getHashCode as int is override
		return _name.getHashCode

	def memberFrom(container as IContainer) as IMember?
		"""
		Used to get the real member represented by this type identifier in container.
		Used for qualified types such as:
			System.Windows.Forms.Control
			System.Collections.Generic.List<of String>
		The default implementation is:
			return container.memberForName(.name)
		Generics have to do more work, though.
		"""
		return container.memberForName(.name)

	def _resolveType as IType is abstract
		"""
		Invoked by .realType only when needed.
		Subclasses must override to compute and return the actual type that this identifier represents (or invoke `.throwError('...')`).
		Subclasses should not bother with other operations such as checking or setting _actualType or _didResolveType to true.
		Subclasses need not invoke `base`.
		"""


class WrappedTypeIdentifier
	is abstract
	inherits AbstractTypeIdentifier

	var _typeId as AbstractTypeIdentifier

	def init(token as IToken, typeId as AbstractTypeIdentifier)
		require
			token.text.length
		ensure
			.name.length
		body
			base.init(token, token.text)
			_typeId = typeId

	def addMinFields
		base.addMinFields
		.addField('typeId', _typeId)

	get theWrappedTypeIdentifier from _typeId

	def _bindInt is override
		_typeId.bindInt
		base._bindInt

	def _bindImp is override
		_typeId.bindImp
		base._bindImp


class ArrayTypeIdentifier
	inherits WrappedTypeIdentifier

	def init(token as IToken, typeId as AbstractTypeIdentifier)
		base.init(token, typeId)

	def memberFrom(container as IContainer) as IMember? is override
		return container.memberForName(.theWrappedTypeIdentifier.name)

	def _resolveType as IType is override
		return ArrayType(_typeId.realType)


class NilableTypeIdentifier
	inherits WrappedTypeIdentifier

	def init(token as IToken, typeId as AbstractTypeIdentifier)
		base.init(token, typeId)

	def _resolveType as IType is override
		return NilableType(_typeId.realType)

	get name as String is override
		return _typeId.name + '?'

	def memberFrom(container as IContainer) as IMember? is override
		m = container.memberForName(.name[:-1])
		if m inherits IType
			return NilableType(m)
		else
			return m


class VariTypeIdentifier
	inherits WrappedTypeIdentifier

	def init(token as IToken, typeId as AbstractTypeIdentifier)
		base.init(token, typeId)

	def _resolveType as IType is override
		return VariType(_typeId.realType)


class TypeIdentifier
	inherits AbstractTypeIdentifier
	"""
	Created by CobraParser.type for identifiers found where types are
	expected.

	Cobra allows forward references so even though types are expected in
	places like the return type of a method, they cannot be turned into
	actual types until the bindInt phase (or bindImp for expressions).
	"""

	def init(token as IToken)
		require
			token.which=='ID'
			token.text.length
		ensure
			.name.length
		body
			base.init(token, token.text)

	def init(token as IToken, type as IType)
		require
			token.text.length
		ensure
			.name.length
		body
			base.init(token, token.text, type)

	def init(token as IToken, name as String, type as IType)
		"""
		Use this to dictate a name other than what is specified by the token.
		Used for QualifiedTypes, for example, that are created from multiple tokens.
		"""
		require
			name.length
		ensure
			.name.length
		body
			base.init(token, name, type)
			assert name == token.text

	def _resolveType as IType is override
		# don't need to check "basic types" like int, bool, etc. here. the parser does those.
		if Utils.isCapped(_name)
			symbol = .compiler.symbolForName(.name, true, false)  # nested enum and class types are capped and can be members of the current class
		else
			symbol = nil
		if symbol is nil
			sugg = ''
			if not Utils.isCapped(_name)
				sugg = Utils.capped(_name)
				other = .compiler.symbolForName(sugg, true, false)
				sugg = if(other, ' Try "[sugg]".', '')
			.throwError('Cannot find type for "[_name]".[sugg]')
		if symbol inherits ITypeProxy
			return symbol.realType
		else
			throw FallThroughException(symbol)


class GenericTypeIdentifier
	inherits AbstractTypeIdentifier
	"""
	The parser produces these when it encounters "List<of String>", for example.
	"""

	var _rootName as String    # ex: 'List'
	var _fullName as String    # ex: 'List<of String>'
	var _typeRefName as String # ex: 'List<of>' 'IDictionary<of,>' -- matches the actual box

	var _typeNodes as List<of ITypeProxy>

	def init(token as IToken, rootName as String, typeNodes as List<of ITypeProxy>, fullName as String)
		require
			token.which=='OPEN_GENERIC'
			rootName.length
			fullName.length
		body
			base.init(token, fullName)
			_rootName = rootName
			_typeNodes = typeNodes
			_fullName = fullName
			_typeRefName = _rootName + '<of'
			# TODO: String(c',', _typeNodes.count-1) ?
			for i = 0 .. _typeNodes.count-1
				_typeRefName += ','
			_typeRefName += '>'
			_name = _typeRefName

	def memberFrom(container as IContainer) as IMember? is override
		# happens for a qualified generic. See ../Tests/160-qualified/200-qual-generic.cobra
		genericType = container.memberForName(_typeRefName)
		assert genericType
		return _locateType(genericType to !)

	def _resolveType as IType is override
		genericType = .compiler.symbolForName(_typeRefName, Utils.isCapped(_name), false)
		if genericType is nil
			.throwError('Cannot find a generic type named "[_typeRefName]".')
		return _locateType(genericType to !)

	def _locateType(genericType as IMember) as IType
		if genericType inherits Box
			if not genericType.isGeneric
				.throwError('"[_rootName]" is not a generic type.')
			types = List<of IType>()
			for tn in _typeNodes
				types.add(tn.realType)
			if genericType.genericParams.count <> types.count
				.throwError('The generic type "[_rootName]" expects [genericType.genericParams.count] type arguments, not [types.count].')
			t = genericType.constructedTypeFor(types)
			assert t.isGeneric
			# assert not t.isGenericDef  Wrong! If some of the parameters are generic, then the constructed type could have generic params...
			# ... hmmm, but am I using the wrong terms? Maybe the returned type is an open or closed constructed type and never a generic def. TODO: resolve this.
			return t
		else if genericType inherits IType
			.throwError('"[_rootName]" is not a generic type.')
			return nil to passthrough
		else
			assert false, 'When does this happen?'
			.throwError('The definition for "[_fullName]" is not a type.')
			return nil to passthrough


class QualifiedTypeIdentifier
	inherits AbstractTypeIdentifier

	var _typeNodes as List<of AbstractTypeIdentifier>

	def init(typeNodes as List<of AbstractTypeIdentifier>)
		require typeNodes.count > 1
		base.init(typeNodes[0].token, '(uninitialized name)')
		_typeNodes = typeNodes
		sb = StringBuilder()
		sep = ''
		for t in typeNodes
			sb.append(sep)
			sb.append(t.name)
			sep = '.'
		_name = sb.toString
		# TODO: would it be useful to set the _token.text to the name? Maybe it would help with syntax highlighting

	get typeNodes from var

	def _resolveType as IType is override
		member = .compiler.symbolForName(_typeNodes[0].name, true, false)
		i = 1
		while i < _typeNodes.count and member <> nil
			if member inherits IContainer
				m = _typeNodes[i].memberFrom(member)
				if m
					member = m
				else
					.throwError('Cannot find "[_typeNodes[i].name]" at component [i+1] of qualified type.')
				i += 1
			else
				.throwError('"[member]" cannot contain additional members.')
		if member inherits NameSpace  # TODO: remove when NameSpace is no longer an IType
			.throwError('The definition for "[_name]" is a namespace, not a type.')
		if member inherits IType
			return member
		else
			.throwError('The definition for "[_name]" is not a type.')
			throw Exception('') # CC: axe when 'always throws' for methods is available


class TypeUtil
	
	# TODO: should be interface extension on IType

	shared

		def isDynamicOrPassThrough(t as IType) as bool
			return t inherits DynamicType or t inherits PassThroughType

		def isNilableAndDescendantOf(t1 as IType, t2 as IType) as bool
			return t1 inherits NilableType and ((t1 to NilableType).theWrappedType).isDescendantOf(t2)
