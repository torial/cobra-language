namespace Cobra.Lang

	extend System.Object

		def typeOf as System.Type
			""" Using.typeOf is portable between platforms in contrast to CLR .getType and JVM .getClass. """
			return .getType

		def toTechString as String
			return CobraImp._techStringMaker.makeString(this)

		def toPrintString as String
			return CobraImp._printStringMaker.makeString(this)


	extend String
	
		def split(chars as List<of char>) as List<of String>
			test
				s = 'a,b:c:d,e,f'
				assert s.split([c',', c':']) == ['a', 'b', 'c', 'd', 'e', 'f']
			body
				return List<of String>(.split(chars.toArray) to !)
	
		def split(chars as IList<of char>) as List<of String>
			charsArray = char[](chars.count)
			for i in chars.count, charsArray[i] = chars[i]
			return List<of String>(.split(charsArray))

		def md5HashInHex as String
			ensure
				result.length == 32
			test
				assert 'Black holes and revelations.'.md5HashInHex == '95b141d670c19f2f20a820751897b9c6'
			body
				md5 = System.Security.Cryptography.MD5CryptoServiceProvider()
				data = System.Text.Encoding.ascii.getBytes(this)  # why ASCII? why not utf8 or something?
				data = md5.computeHash(data)
				ret = ''
				for i in data.length
					ret += data[i].toString('x2')
				return ret

		def count(c as char) as int
			test
				assert ''.count(c'x')==0
				assert 'x'.count(c'x')==1
				assert 'X'.count(c'x')==0  # case sensitive
				assert ' ! ! '.count(c'!')==2
			body
				count = 0
				for ch in this
					if c == ch, count += 1
				return count

		def isCapitalized as bool
			test
				assert 'Aoeu'.isCapitalized
				assert 'Zaoeu'.isCapitalized
				assert not 'aoeu'.isCapitalized
				assert not ''.isCapitalized
				assert not '1234'.isCapitalized
			body
				return .length and this[0].isUpper

		def capitalized as String
			"""
			Returns the string with the first character capitalized.
			Returns a blank string for a blank string.
			"""
			ensure
				result.length == .length
				result.length implies result[0] == result[0].toUpper
			test
				assert 'chuck'.capitalized == 'Chuck'
				assert 'Chuck'.capitalized == 'Chuck'
				assert ''.capitalized == ''
				assert ' foo'.capitalized == ' foo'
				assert 'f'.capitalized == 'F'
				assert '1aoeu'.capitalized == '1aoeu'
			body
				if .length == 0, return this
				return this[:1].toUpper + this[1:]

	
	class DecimalTools

		# Cobra does not yet support extensions of primitive types
		# But the compiler will pick up "DecimalTools" as if it were
	
		shared
	
			def pow(x as decimal, y as decimal) as decimal
				test
					assert DecimalTools.pow(1, 1) == 1
					assert DecimalTools.pow(1, 2) == 1
					assert DecimalTools.pow(2, 2) == 4
					assert DecimalTools.pow(2, 3) == 8
					assert DecimalTools.pow(3, 3) == 27
					assert DecimalTools.pow(3, 4.5d).round(3) == 140.296d
				body
					if y.remainder(1.0d) == 0 and y > 0 and y <= Int32.maxValue
						# a round power like 5.0
						r = x
						for i in (y to int)-1, r *= x
						return r
					else
						# would be nice to have a real algorithm for this to avoid the conversion to float
						# which has a smaller range, fewer significant digits and lossy representation of
						# some of decimal's values
						return (x to float).pow(y to float) to decimal

			def sqrt(x as decimal) as decimal
				test
					assert DecimalTools.sqrt(1) == 1
					assert DecimalTools.sqrt(2).round(3) == 1.414d
					assert DecimalTools.sqrt(3).round(3) == 1.732d
					assert DecimalTools.sqrt(4) == 2
					assert DecimalTools.sqrt(4.5d).round(3) == 2.121d
					expect OverflowException, DecimalTools.sqrt(-4.5d)
				body
					# would be nice to have a real algorithm for this to avoid the conversion to float
					# which has a smaller range, fewer significant digits and lossy representation of
					# some of decimal's values
					return (x to float).sqrt to decimal
