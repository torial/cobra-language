"""
InstallFromWorkspace.cobra

This program installs Cobra onto your system out of the workspace. It's a great
convenience for users who only grab the workspace to get the very latest
version of Cobra (e.g., they are not developing on the compiler). But even for
developers, it's convenient to "snapshot" the compiler for your system when
desired.

Normally the compiler and libraries to be installed are compiled with -turbo.
However, you can pass an argument to this program such as -debug which will
replace -turbo. This is useful for troubleshooting.

Why not a .bat file? Won't run on Mac, Linux, etc.

Why not a bash script? Won't run on Windows-sans-cygwin.

Also, as a .NET program this installer has easy access to the GAC and any other
.NET resources. Furthermore, as a Cobra programmer, any Cobra user could
potentially hack on it.


TO RUN

	On Windows

		Update, if desired:
		> cd \path\to\Workspace
		> svn up

		Get into the Source:
		> cd Source

		Use the batch file:
		> install-from-workspace

	On Mac, Linux, etc.

		Update, if desired:
		$ cd /path/to/Workspace
		$ svn up

		Get into the Source:
		$ cd Source

		Use the script:
		$ sudo ./install-from-workspace


	The installer prints "Success!" at the end, if successful.
	Otherwise you will see an error message.

	It's safe to run the installer more than once.

	The installer does not change any workspace files that are under source code control.

	To test the installation, try invoking Cobra from *outside* the workspace.


NOTES

	In some special cases, users have required that Cobra.Lang.dll not be
	installed to the GAC. There is an option for this called -skip-std-lib.
	Any other command line options are passed to the Cobra snapshot compiler
	when invoked to compile the compiler source code. If no options are
	specified, -turbo is the default.

	
ASSUMPTIONS

	* Your system meets the requirements for Novell Mono 2.4 or .NET 2.0
	  http://msdn.microsoft.com/en-us/library/ms229070.aspx

	* This program is run in the Workspace\Source directory.

	* This program is run by Snapshot\cobra.exe. *NOT* .\cobra.exe

	* The current Cobra compiler in Source\ will report a -version equal to the
	  last released version plus optional additional text. If the last release
	  was "0.8.0" then the new release should be "0.8.0 post".

	* The current Cobra compiler in Source\ will have three components to its
	  base version *number*. Form: x.y.z  Example: 0.8.0


TODO

	[ ] Create an install log

	[ ] Various "TODO" items in the source itself

"""

use System.Diagnostics
use System.Reflection
use System.Security.Principal
use System.Text.RegularExpressions

# for GAC installation
use System.EnterpriseServices
use System.EnterpriseServices.Internal


class InstallFromWorkspace

	var installDirectories = [r'C:\Cobra', '/usr/local/cobra']

	const configFileName = 'install-directory.text'

	const _standardLibName = 'Cobra.Lang'
	const _standardLibPath = _standardLibName + '.dll'

	def main is shared
		InstallFromWorkspace().run

	var _lastCommand as String?

	var _snapshotCompilerPath as String?
	var _gacutil as String?
	var _baseVersion as String?       # ex: '0.8.0-post', '0.8.0-post-2009-03-01'
	var _targetDir as String?         # ex: 'C:\Cobra', '/usr/local/cobra'
	var _versionDir as String?        # ex: 'C:\Cobra\Cobra-0.8.0-post', 'C:\Cobra\Cobra-0.8.0-post-2009-03-01', '/usr/local/cobra/Cobra-0.8.1-post'
	var _cobraCommandPath as String?  # ex: 'C:\Cobra\bin\cobra.bat', '/usr/local/cobra/bin/cobra'
	var _args = List<of String>()
	var _skipStdLib = false

	def run
		print
		print 'The Cobra Programming Language'
		print 'Install From Workspace'
		print
		print 'Working...'
		print
		_args = .parseCommandLineArgs
		.verifyElevatedPermissions
		.verifyInstallDirectory
		.verifyInWorkspace
		.verifyVirtualMachineVersion
		.locateSnapshotCompiler
		# .locateGacUtil
		.buildCobraCompiler
		.getBaseVersion
		if not _skipStdLib
			.buildCobraLibrary
			.installCobraLibraryToGAC
			.verifyGacInstallation
		.verifyNewlyBuiltCobra
		.copyFilesToInstallDirectory
		.verifyNewlyInstalledCobra
		.cleanUpWorkspace
		.installInPath
		print
		print 'Success!'


	## Self utils

	get compileFlags as String
		if _args.count > 0, return _args.join(' ')
		else, return '-turbo'

	get isRunningOnUnix as bool
		"""
		Returns true if the current process is running on Unix/Posix/Linux/BSD/etc.
		"""
		# to-do: have this return CobraCore.isRunningOnUnix after the next snapshot
		platform = Environment.osVersion.platform to int
		return platform in [4, 128] # http://www.mono-project.com/FAQ:_Technical

	get lastCommand from var

	get slash as char
		return Path.directorySeparatorChar

	def parseCommandLineArgs as List<of String>
		args = CobraCore.commandLineArgs
		args = args[1:]
		i = args.indexOf('-skip-std-lib')
		if i > -1
			_skipStdLib = true
			args.removeAt(i)
		return args

	def error(msg)
		print '** ERROR:', msg
		Environment.exit(1)
		print 'Exiting from error.'

	def warning(msg)
		print '** WARING:', msg

	def isAdmin as bool
		wi = WindowsIdentity.getCurrent
		wp = WindowsPrincipal(wi)
		return wp.isInRole(WindowsBuiltInRole.Administrator) or wi.token == IntPtr.zero


	## File system

	def copyContents(source as String, target as String)
		print 'copy from:', source
		print '       to:', target
		.copyContents(DirectoryInfo(source), DirectoryInfo(target))

	def copyContents(source as DirectoryInfo, target as DirectoryInfo)
		if not target.exists, target.create
		for sourceFile in source.getFiles
			sourceFile.copyTo(Path.combine(target.fullName, sourceFile.name), true)
		for sourceSubDir in source.getDirectories
			targetSubDir = target.createSubdirectory(sourceSubDir.name)
			.copyContents(sourceSubDir, targetSubDir)

	def deleteDir(dir as String)
		if Directory.exists(dir)
			print 'del dir  :', dir
			spacer = '          '
			_unReadOnly(dir)
			numAttempts = 3
			for attempt in 1 : numAttempts + 1
				try
					Directory.delete(dir, true)  # true = recursive
				catch IOException
					# sometimes "The directory is not empty." occurs
					if attempt == numAttempts, throw
					print spacer, 'Having trouble deleting directory. Try again in [attempt] seconds.'
					System.Threading.Thread.sleep(attempt*1_000)
					if not Directory.exists(dir)  # and sometimes it goes away!
						print spacer, 'Directory is gone.'
				if not Directory.exists(dir), break

	def _unReadOnly(dirName as String)
		_unReadOnly(DirectoryInfo(dirName))

	def _unReadOnly(dir as DirectoryInfo)
		# print 'checking -', dir
		for file in dir.getFiles
			if sharp'file.Attributes & System.IO.FileAttributes.ReadOnly'
				# print 'changing -', file
				file.attributes = sharp'file.Attributes & ~System.IO.FileAttributes.ReadOnly'
				# file.attributes = file.attributes & ~FileAttributes.ReadOnly
		for subDir in dir.getDirectories
			_unReadOnly(subDir)

	def findAndDeleteDir(baseDir as String, findDir as String)
		.findAndDeleteDir(DirectoryInfo(baseDir), findDir)

	def findAndDeleteDir(baseDir as DirectoryInfo, findDir as String)
		for sourceSubDir in baseDir.getDirectories
			if sourceSubDir.name == findDir
				.deleteDir(sourceSubDir.fullName)
			else
				.findAndDeleteDir(sourceSubDir, findDir)

	def requireDir(dir as String)
		if Directory.exists(dir)
			print 'found dir:', dir
		else
			print 'make dir :', dir
			try
				Directory.createDirectory(dir)
			catch ex as SystemException
				.error('Unable to create installation directory.\n[ex.message]\nRun as admin, or put a correct install path into a file called "[.configFileName]".')

	def startStage(description as String)
		print '====', description
		print
		# this installer relies on there being no directory changes
		assert Environment.currentDirectory.endsWith('Source')


	## Running external commands

	def runCommand(command as String, args as String) as String
		return .runCommand(command, args, true)

	def runCommand(command as String, args as String, displayOutput as bool) as String
		process as Process?
		output = .runCommand(command, args, out process, displayOutput)
		if process.exitCode, .error('Exit code from above command: [process.exitCode]')
		return output

	def runCommand(command as String, args as String, process as out Process?) as String
		return .runCommand(command, args, out process, true)

	def runCommand(command as String, args as String, process as out Process?, displayOutput as bool) as String
		"""
		Runs the given external command with the given args.
		Sets the process to the instance of Process created for this purpose.
		Returns the output, which is also displayed if displayOutput is true.
		Does not check process.exitCode.
		"""
		print 'run: [command] [args]'
		_lastCommand = command + ' ' + args
		p = Process()
		p.startInfo.fileName = command
		p.startInfo.arguments = args
		output = CobraCore.runAndCaptureAllOutput(p).trim
		process = p
		if displayOutput and output <> ''
			for line in output.replace('\r', '').split(c'\n')
				print '   : [line]'
		print
		return output

	def runSnapshotCobra(args as String) as String
		"""
		Runs the Cobra compiler.
		Prints the output and returns it.
		If Cobra gives an error, calls .error.
		"""
		process as Process?
		output = .runSnapshotCobra(args, out process)
		if process.exitCode, .error('Exit code from running SnapshotCobra: [process.exitCode]')
		return output

	def runSnapshotCobra(args as String, process as out Process?) as String
		"""
		Runs the Cobra compiler.
		Creates and "returns" the Process instance via the `process` argument.
		Prints the output and returns it.
		This does not exit on any errors. Check the process yourself.
		"""
		return .runCommand(_snapshotCompilerPath to !, args, out process)

	def runSourceCobra(args as String) as String
		process as Process?
		output = .runSourceCobra(args, out process)
		if process.exitCode, .error('Exit code from running Source Cobra: [process.exitCode]')
		return output

	def runSourceCobra(args as String, process as out Process?) as String
		return .runCommand('cobra.exe', args, out process)


	## Stages

	def verifyElevatedPermissions
		.startStage('Verify running as admin user')
		if not .isAdmin
			.error('Please run this executable as an admin user.')
			

	def verifyInstallDirectory
		.startStage('Verify installation directory')
		default = if(.isRunningOnUnix, .installDirectories[1], .installDirectories[0])
		if File.exists(.configFileName)
			# get install directory from first line of the file
			useDir = File.openText(.configFileName).readLine
			if useDir and useDir.trim.length, default = useDir.trim
		# TODO: prompt the user for the location
		.requireDir(default)
		_targetDir = default
		print

	def verifyInWorkspace
		.startStage('Verify running in workspace')
		msg = 'The current directory does not appear to be a workspace. This program is for installing from the workspace.'
		if not File.exists('Compiler.cobra'), .error(msg)
		if not Directory.exists('Snapshot'), .error(msg)
		print 'Verified.'
		print

	def verifyVirtualMachineVersion
		if CobraCore.isRunningOnMono
			.startStage('Verify Novell Mono version')
			minMonoVersion = '2.4'
			vers = CobraCore.monoVersionString
			if vers is nil or vers.trim == ''
				.error('Cannot determine Mono version. Please install Mono [minMonoVersion] or higher.')
			else
				print 'Mono Version', vers
				parts = vers.split(c'.')
				if parts and parts[0] >= '2'
					print 'Verified >= [minMonoVersion]'
					print
				else
					.error('Mono version must be [minMonoVersion] or higher.')

	def locateSnapshotCompiler
		.startStage('Locate and test Cobra Snapshot compiler')
		_snapshotCompilerPath = 'Snapshot[.slash]cobra.exe'
		if not File.exists(_snapshotCompilerPath)
			.error('Cannot locate [_snapshotCompilerPath].')
		# Not needed; clutters the output; tends to obscure when the Snapshot is being used;
		# _snapshotCompilerPath = Path.getFullPath(_snapshotCompilerPath)
		output = .runSnapshotCobra('-about')
		assert 'The Cobra Programming Language' in output
		assert 'Copyright' in output
		assert 'Usage' in output

	def locateGacUtil(startStage as bool)
		if startStage, .startStage('Locate gacutil.exe')
		slash = .slash
		gacutil = 'gacutil'
		p = Process()
		p.startInfo.fileName = gacutil
		p.startInfo.arguments = '-silent'
		try
			CobraCore.runAndCaptureAllOutput(p)
			found = true
			print 'found in system PATH'
		catch FileNotFoundException
			pass
		catch ComponentModel.Win32Exception
			pass

		if not found
			# try to find the gacutil
			print 'Searching for gacutil...'
			gacutil = 'gacutil.exe'

			dirs = [
				r'Microsoft.NET\SDK\v2.0\bin',        # VS 2005 / SDK .NET 2.0
				r'Microsoft SDKs\Windows\v6.0A\bin',  # VS 2008
				r'Microsoft Visual Studio 8\SDK\v2.0\Bin',
			]

			# search %ProgramFiles% (which can differ internationally)
			programFilesDir = Environment.getFolderPath(Environment.SpecialFolder.ProgramFiles)
			for dir in dirs
				path = '[programFilesDir][slash][dir][slash][gacutil]'
				print 'checking:', path
				if File.exists(path)
					print 'found:', path
					gacutil = path
					found = true
					break
				# else, print path

			if not found
				for dir in dirs
					# search drives for X:\Program Files\...
					for drive in Directory.getLogicalDrives
						drive = drive[:1]  # normalize to just one character
						if drive <= 'B', continue
						path = '[drive]:[slash]Program Files[slash][dir][slash][gacutil]'
						print 'checking:', path
						if File.exists(path)
							print 'found:', path
							gacutil = path
							found = true
							break
						# else, print path
					if found, break

		if not found
			.error('Cannot locate a gacutil. Maybe you can try again using the "Visual Studio Command Prompt" or ".NET SDK Command Prompt".')

		_gacutil = gacutil
		print

	def buildCobraCompiler
		.startStage('Build new Cobra compiler')
		.runSnapshotCobra('-compile [.compileFlags] -ert:yes cobra.cobra -files:files-to-compile.text')

	def getBaseVersion
		.startStage('Retrieve Cobra base version number')
		# It's called "base version" because it doesn't include any text after the numbers
		# "0.8.0 post release" --> "0.8.0"
		output = .runSourceCobra('-version')
		re = Regex(r'\d+\.\d+\.\d+')
		reMatch = re.match(output)
		if reMatch.success
			assert reMatch.value
			_baseVersion = reMatch.value
		else
			.error('Could not extract base version number.')
		_baseVersion += '-post'
		# check for an informal release
		parent = Path.getFullPath('..')
		if File.exists('[parent][.slash]InformalRelease.text')
			output = File.readAllText('[parent][.slash]InformalRelease.text')
			re = Regex(r'\d+\-\d+\-\d+')
			reMatch = re.match(output)
			if reMatch.success
				assert reMatch.value
				_baseVersion += '-' + reMatch.value
			else
				.error('Could not extract date from InformalRelease.text')
		print 'base version: [_baseVersion]'
		print

	def buildCobraLibrary
		"""
		Builds the copy of the Cobra Standard Library for installation to the GAC.
		Must build the library using the Source cobra.exe, not the Snapshot
		Always build with -debug since this is the copy for GAC installation. The debug info (mdb file)
		will be installed to the GAC along with the dll. This is required for the -d compiler option.
		"""
		.startStage('Build Cobra standard library')
		.runSourceCobra('-bsl -debug [.compileFlags] Cobra.Lang[.slash]AssemblyAttrs.cobra -key-file:Cobra.Lang[.slash]Cobra.Lang.snk')

	def verifyNewlyBuiltCobra
		.startStage('Verify newly built Cobra compiler')
		.runSourceCobra('-about')
		msg = 'Cannot run hello.cobra with new compiler.'
		if not _skipStdLib
			output = .runSourceCobra('-ert:no hello')
			if not output.startsWith('Hello'), .error(msg)
			output = .runSourceCobra('hello')
			if not output.startsWith('Hello'), .error(msg)
		output = .runSourceCobra('-ert:yes hello')
		if not output.startsWith('Hello'), .error(msg)

	def installCobraLibraryToGAC
		.startStage('Install Cobra standard library to the GAC')
		print 'Invoking Publish.GacInstall...'
		try
			Publish().gacInstall(_standardLibPath)
			print 'Done.'
		catch NotImplementedException
			print 'Not implemented exception.'
			print 'Will attempt to use gacutil.exe.'
			.locateGacUtil(false)
			.runCommand(_gacutil, '-i [_standardLibPath] -f')
		catch e as Exception
			print '[e.getType] e.message'
		print

	def verifyGacInstallation
		# TODO: verify the version number: Cobra.Lang, Version=0.0.1.0
		.startStage('Verifying Cobra standard library installed to the GAC')
		try 
			# temporarily rename the standard library to ensure that assembly
			# loading is attempted from the GAC.
			tmpFileName = 'temp-[Process.getCurrentProcess.id]-[_standardLibPath]'
			File.move(_standardLibPath, tmpFileName)
			a = Assembly.loadWithPartialName(_standardLibName)
			if a.globalAssemblyCache
				print '[_standardLibPath] has been successfully installed to the GAC.'
			File.move(tmpFileName, _standardLibPath)
		catch NotImplementedException
			print 'Attempting to use gacutil.'
			if not _gacutil, .locateGacUtil(false)
			output = .runCommand(_gacutil, '-l Cobra.Lang')
			if '[_standardLibName], Version=' in output
				print '[_standardLibPath] has been successfully installed to the GAC.'
			else
				.error('Installing the standard library to the GAC was unsuccessful.')
		print		

	def copyFilesToInstallDirectory
		require _targetDir is not nil
		.startStage('Copy files to install directory')
		slash = .slash
		targetDir = _targetDir

		if targetDir, .requireDir(targetDir)
		if Directory.exists(Path.combine(targetDir, 'Source'))
			print 'The directory "[targetDir]" appears to contain a workspace or snapshot of the'
			print 'Cobra source code, due to containing the subdirectory "Source".'
			print 'Installing to that location can lead to confusion and technical difficulties.'
			print 'Consider clearing out "[targetDir]" and creating a workspace *inside* it called,'
			print 'for example, "Workspace".'
			print
			.error('Cannot install to workspace or workspace snapshot. See message above.')

		versionDir = '[targetDir][slash]Cobra-[_baseVersion]'
		.deleteDir(versionDir)
		.requireDir(versionDir)
		_versionDir = versionDir

		# TODO: readme file?
		parent = Path.getFullPath('..')

		versionOutput = ''
		if File.exists('[parent][slash]InformalRelease.text')
			versionOutput = File.readAllText('[parent][slash]InformalRelease.text')
		else if File.exists('.svn') or File.exists('_svn')
			# record "svn info" in the installation directory
			svnFailed = 'Cannot find Subversion revision information. The svn program is not installed or it failed. This only means that the revision number of the workspace is not recorded in the installation directory for your convenience. The compiler and libraries do not rely on this.'
			try
				process as Process?
				versionOutput = .runCommand('svn', 'info', out process, false)
				if process.exitCode
					print '"svn info" failed. Check your svn installation.'
					print '[versionOutput]'
					print
					.warning(svnFailed)
			catch ex as SystemException
				# user could be on TortoiseSVN
				print 'svn is not installed or it is not in the PATH. ', ex.message
				.warning(svnFailed)
		if versionOutput <> ''
			fileName = '[versionDir][slash]Version.text'
			print 'writing  :', fileName
			File.writeAllText(fileName, versionOutput)
		print

		for dir in ['HowTo', 'Reusables', 'Samples', 'Supplements']
			.copyContents('[parent][slash][dir]', '[versionDir][slash][dir]')

		versionBinDir = '[versionDir][slash]bin'
		.requireDir(versionBinDir)
		print 'copy  bin: [versionBinDir]'
		binFiles = 'cobra.exe Cobra.Lang.dll Cobra.Sharp.*.dll styles-cobra-doc.css styles-exception-report.css styles-output-html.css'.split
		for fileName in binFiles
			for fileName2 in Directory.getFiles('.', fileName)  # glob
				File.copy(fileName2, '[versionBinDir][slash][fileName2]')

		.copyContents('Cobra.Lang', '[versionBinDir][slash]Cobra.Lang')

		# delete _svn or .svn from the installation directory
		.findAndDeleteDir(versionDir, '_svn')
		.findAndDeleteDir(versionDir, '.svn')

		# create cobra.bat / cobra for invoking the latest version
		baseBinDir = '[targetDir][slash]bin'
		.requireDir(baseBinDir)
		if .isRunningOnUnix
			_cobraCommandPath = '[baseBinDir][slash]cobra'
			print 'writing  :', _cobraCommandPath
			using f = File.createText(_cobraCommandPath)
				f.writeLine('#!/bin/sh')
				f.writeLine('exec mono "[versionDir][slash]bin[slash]cobra.exe" "$@"')
			.runCommand('chmod', "a+x '[_cobraCommandPath]'")
		else
			_cobraCommandPath = '[baseBinDir][slash]cobra.bat'
			print 'writing  :', _cobraCommandPath
			using f = File.createText(_cobraCommandPath)
				f.writeLine('@"[versionDir][slash]bin[slash]cobra.exe" %*')
			print

	def verifyNewlyInstalledCobra
		.startStage('Verify newly installed Cobra compiler')
		output = .runCommand(_cobraCommandPath, '-about', true)
		if not output.startsWith('The Cobra Programming Language')
			.error('Cannot run the installed Cobra with -about')
		output = .runCommand(_cobraCommandPath, '-ert:yes hello', true)
		if not output.startsWith('Hello')
			.error('Cannot run the installed Cobra on "hello.cobra"')

	def cleanUpWorkspace
		.startStage('Clean up workspace')
		.runSnapshotCobra('-compile -debug -ert:yes cobra.cobra -files:files-to-compile.text')
		.runSourceCobra('-bsl -debug')

	def installInPath
		.startStage('Install "cobra" into a system path directory')
		commandName = if(.isRunningOnUnix, 'cobra', 'cobra.bat')
		slash = .slash
		paths = (Environment.getEnvironmentVariable('PATH') ? '').split(Path.pathSeparator)
		for commandDir in paths
			if commandDir == '.', continue  # skip the 'cobra' in the <workspace>/Source directory
			# print 'checking path:', commandDir
			if commandDir.startsWith('~')
				home = Environment.getEnvironmentVariable('HOME')
				if home, commandDir = home + commandDir[1:]
			commandPath = Path.getFullPath('[commandDir][slash][commandName]')
			if File.exists(commandPath)
				print 'found in PATH:', commandPath
				found = true
				break
		print
		baseBinDir = '[_targetDir][slash]bin'
		if found
			if String.compare(commandPath, '[baseBinDir][slash][commandName]', not .isRunningOnUnix) == 0
				print 'Your PATH already contains [baseBinDir]'
				print 'so you can invoke "cobra" from any directory.'
			else
				if .newlyCompiledFileIsSymlinkedFromOneFoundOnPath(_cobraCommandPath, commandPath)
					print 'The existing "cobra" in your path is the correct'
					print 'symbolic link and has not been changed.'
				else
					print 'copy from:', _cobraCommandPath
					print '       to:', commandPath
					try, File.delete(commandPath)
					catch Exception, pass
					File.copy(_cobraCommandPath, commandPath, true)
					print
					print 'The existing "cobra" in your path at'
					print commandPath
					print 'has been replaced with the new one.'
		else
			# TODO: on unix, create a symlink in /usr/local/bin or /usr/bin if they exist and are in the path
			print 'The Cobra compiler is not in your PATH. To remedy you can:'
			print '1. Add [Path.getDirectoryName(_cobraCommandPath)] to your PATH'
			print '2. Copy [_cobraCommandPath] to any directory in your PATH'

	def newlyCompiledFileIsSymlinkedFromOneFoundOnPath(cobraCommandPath, commandPath) as bool
		if .isRunningOnUnix
			monoAssembly = Assembly.load('Mono.Posix, Version=2.0.0.0, Culture=neutral, PublicKeyToken=0738eb9f132ed756')
			unixFileSystemInfo = monoAssembly.getType('Mono.Unix.UnixFileSystemInfo') to dynamic
			if unixFileSystemInfo
				fileInfo = unixFileSystemInfo.getFileSystemEntry(commandPath)
				if fileInfo.isSymbolicLink and fileInfo.contentsPath == cobraCommandPath
					return true
		return false
