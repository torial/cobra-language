class EnumDecl
	is partial
	inherits Container<of EnumMember>
	implements IBoxMember, INameSpaceMember

	# TODO: defaultAccessLevel = 'public'

	var _attribs as AttributeList
	var _storageTypeNode as ITypeProxy?
	var _storageType as IType?
	var _nativeType as NativeType?
	var _needScanNativeType as bool

	def init(parent as IParentSpace?, token as IToken, name as String, isNames as List<of String>, attribs as AttributeList, storageTypeNode as ITypeProxy?, docString as String, enumMembers as List<of EnumMember>)
		base.init(parent, token, name, isNames, docString)
		_attribs = attribs
		_storageTypeNode = storageTypeNode
		for em in enumMembers
			.addDecl(em)
			em.enumDecl = this

	def init(parent as IParentSpace?, nativeType as NativeType, isNames as List<of String>, docString as String?)
		base.init(parent, TokenFix.empty, nativeType.name, isNames, docString)
		_attribs = AttributeList()
		_nativeType = nativeType
		_storageTypeNode = ClrTypeProxy(Enum.getUnderlyingType((_nativeType to ClrType).theClrType))  # TODO: fix native
		_needScanNativeType = true

	def _scanClrType
		# TODO: read attribs
		_needScanNativeType = false
		clrType = (_nativeType to ClrType).theClrType # TODO: fix native
		isByte = Enum.getUnderlyingType(clrType).name == 'Byte'
		is64 = Enum.getUnderlyingType(clrType).name == 'Int64'
		values = Enum.getValues(clrType)
		i = 0
		for name in Enum.getNames(clrType)
			value = values.getValue(i)
			# CC: lameness follows
			if isByte
				intValue = int.parse((value to Byte).toString) to int
			else if is64
				try
					intValue = int.parse((value to Int64).toString) to int
				catch OverflowException
					intValue = 999  # CC: omg. but probably doesn't affect anything. we're reading the DLL here, not creating one
			else
				intValue = value to int
			member = EnumMember(name, intValue)
			member.enumDecl = this
			.addDecl(member)
			i += 1

	get attributes as AttributeList is override
		return _attribs

	get defaultAccessLevel as String is override
		return 'public'

	get englishName as String is override
		return 'enumeration type'

	get isShared as bool is override
		return true

	get isReference as bool is override
		# enums are not reference types
		return false

	pro isUsed as bool
		get
			return base.isUsed
		set
			base.isUsed = value
			if _needScanNativeType
				_scanClrType

	get typeForIdentifier as IType is override
		return .compiler.typeType

	get typeForReceiver as IType is override
		return this

	def _bindInt is override
		base._bindInt
		for attrib in .attributes, attrib.bindInt
		if _storageTypeNode
			_storageType = _storageTypeNode.realType
			# TODO: give error if _storageType is not some kind of int or char or whatever is legal
		if _needScanNativeType
			_scanClrType

	def _bindImp is override
		base._bindImp
		for attrib in .attributes, attrib.bindImp
		# TODO: can this be removed? since the storage type is always something primitive like 'int', there should be no need for enum to give it .bindImp
		if _storageType
			_storageType.bindImp

	def extensionMemberFor(box as Box, name as String) as IMember?
		return nil

	def memberForName(name as String) as IMember?
		if _needScanNativeType
			_scanClrType
		m = base.memberForName(name)
		if m is nil
			objClass = .compiler.objectType
			return objClass.memberForName(name)
		return m

	def mergedIntoPartialBox(newBox as Box)
		require
			newBox is not .parentBox
			newBox.name == .parentBox.name
		body
			_parentBox = newBox


class EnumMember
	is partial
	inherits NamedNode
	implements IMember
	"""
	Holds the name and (optionally) value of a member of an EnumDecl.
	"""

	var _value as int?
	var _enumDecl as EnumDecl?

	def init(token as IToken, value as int?)
		require token.which=='ID'
		base.init(token, token.text)
		_value = value

	def init(name as String, value as int)
		base.init(name)
		_value = value

	def addMinFields is override
		base.addMinFields
		.addField('value', _value)

	get attributes as AttributeList
		return AttributeList()

	pro enumDecl from var

	get isCallable as bool
		return false

	get isShared as bool
		return true

	get englishName as String
		return 'enumeration value'

	pro parentNameSpace as NameSpace?
		get
			return nil
		set
			throw NotSupportedException()

	get requiresThis as bool
		# This property probably doesn't make much sense for an enum member which must always
		# be accessed via its containg enum type.
		return false

	get resultType as IType
		require .enumDecl
		return _enumDecl to !

	get typeForIdentifier as IType is override
		return _enumDecl to !
	
	get typeForReceiver as IType is override
		return _enumDecl to !
	
	get value from var

	def unNilReturnType
		# TODO: can this be axed when IMember gets broken up?
		pass
