"""
Rules:
	* Do not invoke .bindFoo on any type that an expression discovers during its own .bindImp.
"""

interface IExpr
	inherits ISyntaxNode
	"""
	This is mainly used for categorization.
	To see what really makes an expression, see the Expr class.
	"""

	get definition
		"""
		Returns the definition corresponding to this expression.
		Dynamically typed.
		Returns nil by default.
		Not all expressions have definitions.
		"""

	def toCobraSource as String


enum ArgumentLabel
	None
	Out
	InOut


class Expr
	is abstract, partial
	inherits Stmt
	implements IExpr
	"""
	TODO: Add a .subexpressions iterator which can then be used by .hasError, .willChangeVar and possibly others.
	"""

	var _type as IType?
	var _receiverType as IType?
		"""
		The type for receiving messages which can be different than the
		_type in a static situation such as `ChessPiece.Color` (where
		Color is an enum). The type of that expression, if assigned to a
		local var, is Type. But if accessed with a further dot
		`ChessPiece.Color.Black`, then the type is the Color
		enumeration itself--the receiverType.

		For a runtime access (ex: `user.name`) the two types are
		conceptually the same (ex: `String`) and _receiverType is left
		nil.

		_receiverType is used in memberForName() to look up members such
		as "Black".

		TODO: rename to _typeForMemberAccess
		"""
	var _contextType as IType?
	var _isParened as bool
	var _argumentLabel = ArgumentLabel.None

	def init(token as IToken)
		base.init(token)

	def addRefFields is override
		base.addRefFields
		.addField('type', _type)
		if .definition, .addField('definition', .definition)

	pro argumentLabel from var
		"""
		Indicates the label for an argument such as 'out' or 'inout'.
		"""

	get definition
		return nil

	get willChangeVar as bool
		"""
		Return true if this expression will change a variable.
		Used by `assert` and others that won't accept expressions with such side effects from assignment, `out` parameters, etc.
		Subclasses that contain subexpressions must override to check their subexpressions.
		"""
		return false

	pro type from var

	pro receiverType as IType?  # TODO: consider renaming to typeForReceiver
		"""
		This property returns the .type if there was no receiver type explicitly set because the type of an expression is its receiver type by default.
		"""
		get
			return _receiverType ? _type
		set
			_receiverType = value

	pro contextType from var
		"""
		The type expected where this expression is being used.
		Normally this is the same type as the expression, but it can be different, for example when
		assigning a dynamic-typed expression to a static-typed variable, the type of the variable
		becomes the context type.
		"""

	get curBox as Box? is protected
		"""
		Returns the current code member during "bind imp" and "write sharp".
		"""
		return if(.compiler.boxStack.count, .compiler.boxStack.peek, nil)

	get curCodeMember as AbstractMethod? is protected
		"""
		Returns the current code member during "bind imp" and "write sharp".
		"""
		return if(.compiler.codeMemberStack.count, .compiler.codeMemberStack.peek, nil)

	def canBeAssignedTo(type as IType) as bool
		require
			.didBindImp
			.type
		body
			return .type.isAssignableTo(type)

	def toCobraSource as String
		return '[.getType.name].toCobraSource'

	get isCalling as bool
		"""
		Return true is this expression is making a call.
		The default implementation returns false.
		You might think "inherits CallExpr" would suffice, but MemberExpr and IdentifierExpr can
		also return true when they refer to methods or inits.
		"""
		return false

	def isKindOf(type as IType) as bool
		require
			.type
			.compiler
		body
			return .type.isDescendantOf(type)

	def isKindOfCollection as bool
		require
			.type
			.compiler
		body
			return .isKindOf(.compiler.collectionType) or .isKindOf(.compiler.collectionOfType)

	pro isParened from var
		"""
		Set by the parser if this expression was wrapped in parenthesis.
		TODO: Consider enhancing toCobraSource to make use of this!
		"""

	def memberForName(name as String) as IMember?
		require
			.didBindImp
			.type
		body
			return .receiverType.memberForName(name)

	def suggestionsForBadMemberName(name as String) as List<of String>
		require
			.didBindImp
			.type
		body
			return .receiverType.suggestionsForBadMemberName(name)

	get binarySuperNode as BinaryOpExpr
		require
			.superNode inherits BinaryOpExpr
		body
			return .superNode to BinaryOpExpr

	def bindImp as dynamic is override
		# CC: and ensure result inherits Expr
		base.bindImp
		assert .didBindImp, this
		.postBindImpAssertType
		return .bindImpResult

	def postBindImpAssertType
		"""
		This is broken out because in rare cases, it doesn't apply. (Those classes override this to
		do nothing.)
		"""
		if not .hasError
			assert .type or .transformedTo

	def _bindImp is override
# TODO:
#		ensure
#			.type
		body
			base._bindImp

	def _suggestionsMessage(suggs as List<of String>) as String
		"""
		Shared by MemberExpr, CallExpr and IdentifierExpr to give suggestions in an error message about an unknown member.
		"""
		if suggs.count
			if suggs.count == 1
				sugg = ' There is a member named "[suggs[0]]" with a similar name.'
			else
				sugg = ' There are members with similar names including '
				sep = ''
				for i = 0 .. suggs.count
					sugg += '[sep]"[suggs[i]]"'
					sep = if(i<suggs.count-2, ', ', ' and ')
				sugg += '.'
		else
			sugg = ''
		return sugg

	def whoseTypeIsMessage as String
		"""
		Returns a suffix for member-not-found error messages.
		Returns ' whose type is "[.receiverType.name]"'
		Overridden by IdentifierExpr to return '' when accessing types.
		"""
		return ' whose type is "[.receiverType.name]"'
	
	def throwCannotFindMemberError(receiverExpr as Expr, memberName as String)
		__throwOrRecordCannotFindMemberError(receiverExpr, memberName, 1)

	def recordCannotFindMemberError(receiverExpr as Expr, memberName as String)
		__throwOrRecordCannotFindMemberError(receiverExpr, memberName, 2)

	def __throwOrRecordCannotFindMemberError(receiverExpr as Expr, memberName as String, throwOrRecord as int) is nonvirtual
		require throwOrRecord in [1, 2]
		suggs = _suggestionsMessage(receiverExpr.suggestionsForBadMemberName(memberName))
		errorMsg = 'Cannot find a definition for "[memberName]" in "[receiverExpr.toCobraSource]"[receiverExpr.whoseTypeIsMessage].[suggs]'
		branch throwOrRecord
			on 1, .throwError(errorMsg)
			on 2, .recordError(errorMsg)
			else, throw FallThroughException(throwOrRecord)


interface IPotentialTypeExpr
	inherits IExpr
	"""
	An implementor of IPotentialType *could* be a representation of a type.
	This is implemented by expressions such as DotExpr, IdentifierExpr and TypeExpr.
	It "inherits IExpr" to emphasize and verify that fact. This interface is not for statements, classes, etc.
	"""

	get potentialType as IType?
		"""
		Returns the type that this object represents, or nil if it does not represent a type.
		Should be asked for only during "bind implementation" or later.
		"""


class NameExpr
	is abstract, partial
	inherits Expr
	"""
	The base class for IdentifierExpr and AsExpr.
	"""

	var _name as String
	var _definition as INamedNode?
		"""
		In practice, definitions include:
			* Class, Struct, Interface
			* NameSpace, EnumDecl
			* ClassVar, LocalVar, Param
		There may be others, but at least those have been observed in practice.
		"""

	def init(token as IToken)
		base.init(token)
		_name = token.text

	def addMinFields
		base.addMinFields
		.addField('name', _name)

	get definition is override
		return _definition

	get namedDefinition from _definition

	get name from var

	def memberForName(name as String) as IMember? is override
		or require
			.namedDefinition
		body
			return _definition.typeForReceiver.memberForName(name)


class AnonymousMethodExpr
	is partial
	inherits Expr
	implements HasAddStmt
	"""
	Also called "closures".
	"""
	
	var _method as AnonymousMethod?
	var _returnTypeProxy as ITypeProxy?

	def init(token as IToken, params as List<of Param>, returnTypeProxy as ITypeProxy?)
		base.init(token)
		_params = params
		_stmts = List<of Stmt>()
		_returnTypeProxy = returnTypeProxy

	get params from var as List<of Param>

	get stmts from var as List<of Stmt>
	
	def addStmt(stmt as Stmt)
		_stmts.add(stmt)

	def addSubFields
		base.addSubFields
		.addField('params', .params)

	get hasError as bool
		return base.hasError or _method.hasError

	get willChangeVar as bool is override
		return base.willChangeVar

	def toCobraSource as String is override
		sb = StringBuilder('do(')
		sep = ''
		for param in .params
			sb.append(sep)
			#sb.append(param.toCobraSource)  # TODO
			sb.append(param.name)
			sep = ', '
		sb.append(')')
		return sb.toString

	def _bindImp is override
		base._bindImp
		_method = AnonymousMethod(.token, .curCodeMember, .params, _returnTypeProxy, if(.curCodeMember.isShared, ['shared'], List<of String>()))
		for stmt in .stmts, _method.addStmt(stmt)
		_method.bindInt
		_method.bindImp
		_type = _method.resultType


class AsExpr
	is partial
	inherits NameExpr
	"""
	i as int = 5
	The "i as int" is an AsExpr.
	"""

	var _asToken as IToken  # the identifier vs. the `as` keyword which is the main token
	var _typeNode as ITypeProxy

	def init(token as IToken, nameToken as IToken, typeNode as ITypeProxy)
		base.init(nameToken)
		_asToken = token
		_typeNode = typeNode

	def addMinFields is override
		base.addMinFields
		.addField('name', _name)

	def addSubFields is override
		base.addSubFields
		.addField('typeNode', _typeNode)

	def _bindImp is override
		base._bindImp
		_type = _typeNode.realType
		assert _type, _typeNode
		# make the local var if necessary (usually is)
		definition = .compiler.findLocal(_name)
		if definition is nil
			newVar = LocalVar(_token, _type)
			newVar.bindAll
			.compiler.codeMemberStack.peek.addLocal(newVar)
			_definition = newVar
		else
			if definition.type<>_type
				.throwError('Cannot redeclare "[.name]" as a different type. Earlier type is "[definition.type.name]".')
				# TODO: would be nice to point to earlier location. definition would need to carry source location info
			else
				_definition = definition

	def bindImp as dynamic
		base.bindImp
		# don't want to say isUsed=true if the AsExpr is the left hand side like in:
		#		x as int = 5
		# but if it is the right hand side like so:
		#		_x = x as int = 5
		# then it is, in fact, being used.
		if _definition and .superNode inherits BinaryOpExpr
			if .binarySuperNode.right is this
				# case: x = y as int
				_definition.isUsed = true
			else if .binarySuperNode.superNode inherits BinaryOpExpr and .binarySuperNode is .binarySuperNode.binarySuperNode.right
				# case: x = y as int = 5
				# recall that assign is right-to-left associative
				_definition.isUsed = true
		return .bindImpResult

	def afterStatementBindImp is override
		base.afterStatementBindImp
		if .type.isUninitializedForLocalVars
			.throwError('Must initialize this non-nil object type, or change the type to nilable (suffix with ?).')


class CallExpr
	is partial
	inherits Expr
	implements IDotRightExpr
	"""
	A CallExpr may be on the right side of a dot expression as in `obj.foo(x, y)`.

	This expression will transform into PostCallExpr for the case where in Foo.Bar() the Bar is a type, not a method.
	
	The parser can't always know the exact context and semantics of a call. So transformations include:
		EnumCallExpr
		DotExpr -- for _foo(args) --> ._foo(args)
		PostCallExpr

	A valid call expr may have a nil .definition because the receiver is dynamic.
	"""

	var _name as String
	var _genericArgProxies as List<of ITypeProxy>?
	var _genericArgTypes as List<of IType>?
	var _args as List<of Expr>
	var _hasParens as bool
	var _definition as IMember?

	def init(token as IToken, name as String, args as List<of Expr>, hasParens as bool)
		.init(token, name, nil, args, hasParens as bool)

	def init(token as IToken, name as String, genericArgProxies as List<of ITypeProxy>?, args as List<of Expr>, hasParens as bool)
		base.init(token)
		_name = name
		_genericArgProxies = genericArgProxies
		_args = args
		_hasParens = hasParens
		_definition = nil

	def addMinFields is override
		base.addMinFields
		.addField('name', _name)

	def addSubFields is override
		base.addSubFields
		.addField('args', _args)

	get genericArgProxies from var
	
	get genericArgTypes from var

	get hasError as bool
		if base.hasError, return true
		for arg in _args, if arg.hasError, return true
		return false

	get hasParens from var

	get willChangeVar as bool is override
		for arg in _args, if arg.willChangeVar, return true
		for arg in _args, if arg.argumentLabel <> ArgumentLabel.None, return true
		return false

	get isCalling as bool is override
		return true

	get name from var

	get args from var
		has Subnodes

	get definition is override
		return _definition

	get memberDefinition from _definition

	def _bindImp is override
		base._bindImp
		assert _superNode inherits DotExpr  # otherwise, for something like List<of int>(), the parser creates a PostCallExpr
		if _genericArgProxies
			_setGenericArgTypes
		dotNode = _superNode to DotExpr
		assert this is dotNode.right

		if dotNode.left.didBindImp
			enumDefi = dotNode.left.memberForName(_name)
			if enumDefi inherits EnumDecl
				_transformToEnumDecl(dotNode, enumDefi)
				return

		_bindImpArgs
		definition as IMember?
		type as IType?

		if _definition is nil or _type is nil
			# handle foo.bar() where this is the `bar()` part
			if not dotNode.left.didBindImp
				assert dotNode.left.hasError, dotNode.left
				# we get here for Cobra code like "obj.foo.bar(x)" where "foo" is not found
				_type = .compiler.passThroughType
				return  # TODO: I don't think I want a return here

			definition = _inferDefinitionAndType(dotNode, out type)
			assert type
			if definition inherits IType 	# Box, IVar or GenericParam
				_transformToPostCallExprOnType(dotNode, definition)
				return

			if definition
				# definition should never be a Box, IVar or GenericParam as those cases would be handled by the transformation to PostCallExpr above
				# there is a FallThroughException down below that would report this if it happened
				if definition inherits BoxMember
					if not .hasError
						args = _args
						if definition inherits MemberOverload
							# Note that overloads can have different return types (even if more than just the return type is needed to distinguish them). Example: Math.
							# Plenty of info here:
							# http://www.google.com/search?hl=en&q=C%23+overloaded+method+resolution
							# TODO: handle type inference for generic members. See the C# spec for details.
						
							winner = _computeBestOverload(definition, args)
							sharp'definition = winner'
							type = winner.resultType
						else
							type = definition.resultType
							if not _didVariArgs(definition)
								definition = _checkGenerics(definition, inout type)
								if not definition.hasParams
									_checkNoArgs(definition, args)
								else
									params = definition.params
									if _checkParamsCount(definition, args, params)
										_checkArgsAssignable(definition, args, params)
				else
					throw FallThroughException(definition)
			if type is nil, type = .compiler.passThroughType
			_definition = definition
			if _definition, _definition.isUsed = true
			_type = type
		assert _type, _definition
		if .args.count == 0 and .hasParens
			# TODO:
			# if .definition inherits BoxMember and .definition.isMethod and not dotNode.isImplicit
			if (.definition inherits AbstractMethod or .definition inherits MemberOverload) and not dotNode.isImplicit
				.compiler.warning(this, 'Unnecessary parentheses. You can remove them.')
		else
			for arg in _args
				if arg inherits AssignExpr
					.recordError('Cannot make assignments in arguments. This syntax is reserved in the future for keyword arguments.')

	## _bindImp support

	def _setGenericArgTypes
		_genericArgTypes = List<of IType>()
		num = 1
		for typeProxy in _genericArgProxies
			try
				_genericArgTypes.add(typeProxy.realType)
			catch ne as NodeException
				ne.prefixMessage('For "[_name]" type arg [num]: ')
				.compiler.recordError(ne)
			num += 1
		# TODO: Check types are compatible with call

	def _transformToEnumDecl(dotNode as DotExpr, enumDefi as EnumDecl)
		# Foo.EnumType(MemberA, MemberB)
		# Change to an EnumCallExpr
		# Roll up Foo.Bar.Baz() into one EnumCallExpr
		transformTarget = dotNode
		while transformTarget.superNode inherits DotExpr
			transformTarget = transformTarget.superNode to DotExpr
		enumCall = EnumCallExpr(.token, _name, _args, enumDefi).bindImp
		_type = enumCall.type to IType
		transformTarget._transformTo(enumCall)

	def _inferDefinitionAndType(dotNode as DotExpr, type as out IType?) as IMember?
		type = nil
		possibleDefinition = dotNode.left.memberForName(_name)
		if possibleDefinition is nil
			lrt = dotNode.left.receiverType
			if lrt.isDynamic
				type = .compiler.nilableDynamicType
			else if lrt is .compiler.passThroughType
				if _name == 'toString'
					type = .compiler.stringType
				else
					type = .compiler.passThroughType
			else
				.throwCannotFindMemberError(dotNode.left, _name)
		else
			if not possibleDefinition.isCallable
				.throwError('Cannot call "[_name]" because it is a "[possibleDefinition.englishName]".')
				
			type = possibleDefinition.resultType
		return possibleDefinition

	def _transformToPostCallExprOnType(dotNode, definition as IType?)
		# for Foo.Bar() where Bar is a box/type
		# Change to a PostCallExpr on the type 'Foo.Bar'
			
		# Roll up Foo.Bar.Baz() into one PostCallExpr
		transformTarget = dotNode
		while transformTarget.superNode inherits DotExpr
			transformTarget = transformTarget.superNode to DotExpr

		postCall = PostCallExpr(.token, TypeExpr(.token, definition), .args).bindImp
		_type = postCall.type to IType
		transformTarget._transformTo(postCall)

	def _bindImpArgs			
		num = 1
		for arg in _args
			try
				if arg inherits AssignExpr
					arg.right.bindImp  # 'x=y' has special treatment in arguments
				else
					arg.bindImp
					assert arg.didBindImp
			catch ne as NodeException
				ne.prefixMessage('For "[_name]" arg [num]: ')
				.compiler.recordError(ne)
			num += 1

	def _computeBestOverload(definition as MemberOverload, args as List<of Expr>) as BoxMember
		# I cooked up the algorithm below as a quick way to fix some bugs caused by the previous 
		# implementation of um, doing nothing.
		# But this likely needs to be rewritten.
		candidates = []
		# handle generic arguments to the method
		genericArgTypes = .genericArgTypes
		if genericArgTypes and genericArgTypes.count
			members = List<of BoxMember>()
			for member as BoxMember? in definition.members
				if member inherits Method
					if member.containsGenericParameters
						if member.genericParams.count == genericArgTypes.count
							member = member.constructedMethodWith(genericArgTypes to !)
						else
							member = nil
				if member, members.add(member)
		else
			members = definition.members

		for member in members
			score = -1000
			if member.params.count == args.count
				score = 0
				i = 0
				for param in member.params
					arg = args[i]
					if not arg.didBindImp
						trace arg
						trace arg.hasError
					if arg.type == param.type
						score += 20
					else if arg.canBeAssignedTo(param.type)
						score += 10
					else if arg.type.nonNil.isAssignableTo(param.type) 
						# Cobra's code and data flow analysis sometimes leaves us with a nilable type that's not actually nil anymore
						# due to an assignment, possibly wrapped in an if statement. Eventually this will be corrected, but for now
						# compensate here.
						score += 1
					else
						score -= 100
					i += 1
			# print 'candidate:', score, member.name, member.serialNum, Utils.join(', ', (for param in member.params get param.type.name))
			candidates.add([score, member])

		maxScore = -10_000
		winner = nil to BoxMember?
		for pair in candidates
			if pair[0] to int > maxScore
				maxScore = pair[0] to int
				winner = pair[1] to BoxMember
		if false
			print
			trace .token.fileName
			trace maxScore, _name
			trace .token.toTechString
			trace winner
			print 'args:'
			for arg in args
				print '   [arg]'
			print 'params:'
			for param in winner.params
				print '   [param]'
			print 'overloads:'
			for member in definition.members
				print '   [member]'
		# print 'winner:', score, winner
		assert winner
		return winner to !

	def _didVariArgs(definition as BoxMember) as bool
		hasVari = false
		for param in definition.params
			if param.type inherits VariType 
				hasVari = true
				break
		if hasVari
			# TODO handle variable number of args (4)
			return true
		else
			return false

	def _checkGenerics(definition as BoxMember, type as inout IType?) as BoxMember
		if .genericArgTypes and .genericArgTypes.count
			if definition inherits Method
				definition = definition.constructedMethodWith(.genericArgTypes to !)
				type = definition.resultType
			else
				.throwError('Cannot pass type arguments to "[definition.name]" because it is a [definition.getType.name].') # @@ _definition.englishName; also might need this error in other locations
		return definition
					
	def _checkNoArgs(definition as BoxMember, args as List<of Expr>)
		if .name == 'toString'
			# HACK
			# this enables someFloat.toString('0.0')
			# can remove when primitives know their CLR types and look up their methods
			pass
		else if args.count
			.throwError('The method "[definition.name]" is expecting 0 arguments, but [args.count] are being supplied in this call.')
	
	def _checkParamsCount(definition as BoxMember, args as List<of Expr>, params as List<of Param>) as bool
		if args.count <> params.count
			if _name=='toString'  # TODO because many structs like Decimal have a toString() overload which cannot currently be expressed in SystemInterfaces.cobra
				return false
			else
				.throwError('The method "[definition.name]" is expecting [params.count] argument[Utils.plural(params)], but [args.count] are being supplied in this call.')
		return true
				
	def _checkArgsAssignable(definition as BoxMember, args as List<of Expr>, params as List<of Param>) 
		for i in args.count
			arg = args[i]
			param = params[i]
			if arg.hasError
				break
			if arg inherits AssignExpr  # assignments in arguments have special treatment
				break
			assert arg.didBindImp, arg
			assert param.didBindInt, param
			if arg.canBeAssignedTo(param.type)
				arg.contextType = param.type
			else if param.type inherits GenericParam
				# ..\Tests\240-generics\400-generic-methods\100-generic-method.cobra
				# HACK for generic method args which need proper type checking like anything else
				pass
			else
				if false
					print
					print '<> definition = [definition]'
					print '<> arg = ' stop
					arg.writeDeepString
					print '<> arg.type =', arg.type
					print '<> param = ' stop
					param.writeDeepString
					print '<> param.type =', param.type
					print '<> param.ifInheritsStack.count =', param.ifInheritsStack.count
				if arg.type inherits NilableType and not param.type inherits NilableType and arg.type.nonNil.isAssignableTo(param.type)
					.throwError('Argument [i+1] of method "[_name]" expects a non-nilable type ([param.type.name]), but the call is supplying a nilable type ([arg.type.name]).')
				else
					.throwError('Argument [i+1] of method "[_name]" expects type [param.type.name], but the call is supplying type [arg.type.name].')
		
	def toCobraSource as String is override
		sb = StringBuilder()
		sb.append(_name)
		sb.append('(')
		sep = ''
		for arg in _args
			sb.append(sep)
			sb.append(arg.toCobraSource)
			sep = ', '
		sb.append(')')
		return sb.toString


class EnumCallExpr
	is partial
	inherits Expr
	"""
	Represents an enumeration call like: AnchorStyle(Left, Right)
	Created by CallExpr._bindImp
	"""

	var _name as String
	var _args as List<of Expr>
	var _definition as EnumDecl?
	var _members as List<of EnumMember>
		"""
		Parallels the args with the enum members found during _bindImp.
		"""

	def init(token as IToken, name as String, args as List<of Expr>, definition as EnumDecl)
		require Utils.isCapped(name)
		base.init(token)
		_name = name
		_args = args
		_definition = definition
		_members = List<of EnumMember>()
	
	get name from var
	
	get args from var
		has Subnodes
	
	get definition is override
		return _definition

	get enumDefinition from _definition
	
	get hasError as bool is override
		if base.hasError, return true
		for arg in _args, if arg.hasError, return true
		return false

	def toCobraSource as String is override
		sb = StringBuilder()
		sb.append(_name)
		sb.append('(')
		sep = ''
		for arg in _args
			sb.append(sep)
			sb.append(arg.toCobraSource)
			sep = ', '
		sb.append(')')
		return sb.toString

	def _bindImp
		base._bindImp
		if not _definition
			possible = .compiler.symbolForName(.name, true, false)
			if not possible
				.throwError('Cannot locate enumeration type "[.name]".')
			else if possible inherits EnumDecl
				_definition = possible
			else
				.throwError('"[.name]" is not an enumeration type.')
		if not _type
			_type = _definition
		# TODO: support EnumName(someInt) and EnumName(someString) (and multiple args)
		for arg in _args
			if arg inherits IdentifierExpr
				member = _definition.memberForName(arg.name) to EnumMember?
				if member
					arg.setDefinition(member)
					_members.add(member)  # for use in code generation
				else
					arg.recordError('Cannot find "[arg.name]" in enumeration "[.name]"')


class ForExpr
	is partial
	inherits Expr

	var _nameExpr as NameExpr
	var _var as IVar?
	var _varNumber as int
	var _what as Expr
	var _whereExpr as Expr?
	var _getExpr as Expr
	var _start as Expr?
	var _stop as Expr?
	var _step as Expr?

	def init(token as IToken, nameExpr as NameExpr, what as Expr, stopExpr as Expr?,
				stepExpr as Expr?, whereExpr as Expr?, getExpr as Expr)
		base.init(token)
		_nameExpr = nameExpr
		_what = what
		_stop = stopExpr
		_step = stepExpr
		_whereExpr = whereExpr
		_getExpr = getExpr

	def addSubFields
		base.addSubFields
		.addField('nameExpr', _nameExpr)
		.addField('var', _var)
		.addField('what', _what)
		.addField('whereExpr', _whereExpr)
		.addField('getExpr', _getExpr)
		.addField('start', _start)
		.addField('stop', _stop)
		.addField('step', _step)

	# TODO: add propertiesfor the various object vars

	get willChangeVar as bool is override
		# TODO: ack. kind of weird. if the variable is a new one and its not read afterwards (without first being set) then no side effects.
		if _what.willChangeVar, return true
		if _whereExpr and _whereExpr.willChangeVar, return true
		if _getExpr.willChangeVar, return true
		return false

	def _bindImp
		base._bindImp
		_what.bindImp  # bind first because it may be needed for type inference
		whatType = _what.type to !
		if whatType inherits AnyIntType
			if _stop
				_start = _what
				_stop.bindImp
			else
				_start = IntegerLit(.token.copy('INTEGER_LIT', '0'), 0).bindImp
				_stop = _what
			if not _step
				_step = IntegerLit(.token.copy('INTEGER_LIT', '1'), 1)
			_step.bindImp
		else if not whatType.isDescendantOf(.compiler.enumerableType) and not whatType.isSequenceLike  # TODO: can probably drop .isSequenceLike
			.throwError('Cannot enumerate values of type "[whatType.name]". You can enumerate anything enumerable (IEnumerable, IList, arrays, strings, etc.).')
		_var = .bindVar(_nameExpr)
		if _nameExpr.definition
			if _nameExpr.definition inherits IVar
				_var = _nameExpr.definition
			else
				.throwError('Expecting a variable not a [_nameExpr.definition.getType.name].')  # TODO: what's the best way to report what was found?
		else
			assert _nameExpr.hasError, _nameExpr
		_varNumber = .compiler.curBox.makeNextPrivateSerialNumber
		if _whereExpr
			_whereExpr.bindImp
			if _whereExpr.type is not .compiler.boolType
				_whereExpr = TruthExpr(_whereExpr).bindAll to TruthExpr  # CC: axe cast when have "as same"
		_getExpr.bindImp
		ilist = .compiler.listOfType
		_type = ilist.constructedTypeFor([_getExpr.type to !])

	def inferredType as IType? is override
		assert _what.type
		return if(_what.type inherits AnyIntType, _what.type, _what.type.innerType)


class IdentifierExpr
	is partial
	inherits NameExpr
	implements IPotentialTypeExpr

	def init(token as IToken)
		.init(token, token.text)

	def init(token as IToken, name as String)
		base.init(token)
		_name = name

	def init(token as IToken, definition as INamedNode)
		base.init(token)
		_name = definition.name
		_definition = definition

	def setDefinition(value as INamedNode?)
		# cannot override definition with a set, because base does not do a set
		_definition = value

	get isCalling as bool is override
		assert _definition
		return _definition.isMethod

	get isTypeReference as bool
		"""
		Returns true if this identifier directly names a type.
		"""
		require .didBindImp
		return .definition implements IType and .type.isDescendantOf(.compiler.typeType)
		
	get potentialType as IType?
		# overridden to return the type this identifier represents in those cases when it does represent a type such an "int" or a class
		assert .didBindImp
		assert .type
		assert .compiler
		if .type.isDescendantOf(.compiler.typeType) or .type inherits Box
			assert .definition
			defi = .definition
			if defi inherits IType
				return defi
			else if defi inherits BoxEvent
				# TODO: does execution ever get here?
				return defi.handlerType
			else
				return nil
		else
			return nil

	def _bindImp is override
		base._bindImp
		if _definition is nil
			canBeUndottedMember = .compiler.canNameBeUndottedMember(_name)
			if canBeUndottedMember
				# assert .compiler.boxStack.count TODO: identifier expr is being used by PostCallExpr which is used for attribute calls
				_definition = .compiler.symbolForName(_name, canBeUndottedMember, false)
			else
				# local var ref: foo
				if .compiler.codeMemberStack.count  # could be: var _x = y   or: has foo
					_definition = .compiler.findLocal(_name)
				if _definition is nil
					_definition  = .compiler.symbolForName(_name, false, false, true)  # 3rd party DLLs have lowercase class names like iConnection
			if _definition is nil and not canBeUndottedMember
				if _superNode inherits BinaryOpExpr
					if _superNode.right is this
						curBox = .compiler.boxStack.peek
						definition = curBox.symbolForName(_name, true)
						if definition
							.throwError('You must refer to non-underscored members with a leading dot (.). Member name is "[_name]".')
			if _definition is nil and (not _superNode inherits BinaryOpExpr or .binarySuperNode.op<>'ASSIGN')
				.throwUnknownIdError
				throw FallThroughException()
		if _type is nil
			if _definition
				if _definition inherits AbstractMethod or _definition inherits MemberOverload
					_transformTo(DotExpr(.token, 'DOT', ThisLit(.token, isImplicit=true), MemberExpr(.token), isImplicit=true).bindAll)
				else
					_type = _definition.typeForIdentifier
					_receiverType = _definition.typeForReceiver
			else
				if .binarySuperNode inherits AssignExpr and this is .binarySuperNode.left
					pass  # let the AssignExpr have its chance at type inference
				else
					.throwUnknownIdError
					throw FallThroughException()

	def bindImp as dynamic
		base.bindImp
		if _definition and not (.superNode inherits AbstractAssignExpr and .binarySuperNode.left is this)
			_definition.isUsed = true
		return .bindImpResult

	def throwUnknownIdError
		require .name.length
		name = .name
		msg = 'Cannot find "[name]".'
		if .compiler.unknownSuggestions.containsKey(name)
			sug = .compiler.unknownSuggestions[name] to ?
		if sug and sug.length
			msg += ' Maybe you should try "[sug]".'
		else
			# TODO: check for a local with same name but different case
			sugg = _suggestionsMessage(.compiler.curBox.suggestionsForBadMemberName(name))
			# example suggs:
			#     There is a member named "x" with a similar name.
			#     There are members with similar names including "x" and "y".
			if sugg.length
				assert sugg.endsWith('.')
				sugg = sugg[:-1] + ' that you can access with a leading period (".").'
			msg += sugg
		.throwError(msg)

	def postBindImpAssertType is override
		# TODO: document why this is disabled
		pass

	def afterStatementBindImp
		base.afterStatementBindImp
		if not .hasError
			if not .isCalling
				if .definition inherits IVar
					.throwError('A simple reference to a variable or parameter cannot be a statement.')
				else
					.throwError('A single identifier cannot be a statement (unless it is an underscored method invocation such as "_foo").')

	def toCobraSource as String is override
		return _name

	def whoseTypeIsMessage as String
		"""
		Customized to return '' for boxes.
		"""
		# TODO: should cover other types like `int`. maybe that's a TypeExpr?
		return if(.definition inherits Box, '', base.whoseTypeIsMessage)


class IfExpr
	is partial
	inherits Expr

	var _cond as Expr
	var _tpart as Expr
	var _fpart as Expr

	def init(token as IToken, cond as Expr, tpart as Expr, fpart as Expr)
		base.init(token)
		_cond = cond
		_tpart = tpart
		_fpart = fpart

	def addSubFields is override
		base.addSubFields
		.addField('cond', _cond)
		.addField('tpart', _tpart)
		.addField('fpart', _fpart)

	get hasError as bool is override
		if base.hasError, return true
		if _cond.hasError, return true
		if _tpart.hasError, return true
		if _fpart.hasError, return true
		return false

	get willChangeVar as bool is override
		if _cond.willChangeVar, return true
		if _tpart.willChangeVar, return true
		if _fpart.willChangeVar, return true
		return false

	def _bindImp is override
		base._bindImp
		tpart = _tpart
		fpart = _fpart
		hadError = false
		try
			_cond.bindImp
		catch ne as NodeException
			.compiler.recordError(ne)
			hadError = true
		if not hadError and not _cond.type.isDescendantOf(.compiler.boolType)
			_cond = TruthExpr(_cond).bindAll to TruthExpr  # CC: axe cast when "as same"
		try
			_tpart.bindImp
		catch ne as NodeException
			.compiler.recordError(ne)
			hadError = true
		try
			_fpart.bindImp
		catch ne as NodeException
			.compiler.recordError(ne)
			hadError = true
		if hadError
			_type = .compiler.passThroughType
			return
		assert tpart.type
		assert fpart.type
		_type = tpart.type.greatestCommonDenominatorWith(fpart.type to !)

	def toCobraSource as String is override
		return 'if([_cond.toCobraSource], [_tpart.toCobraSource], [_fpart.toCobraSource])'


class IndexExpr
	is partial
	inherits Expr
	"""
	May transform to a TypeExpr for cases like "int[]".
	"""

	var _target as Expr
	var _args as List<of Expr>
	var _definition as IMember?

	def init(token as IToken, target as Expr, args as List<of Expr>)
		base.init(token)
		_target = target
		_args = args

	def addSubFields is override
		base.addSubFields
		.addField('target', _target)
		.addField('args', _args)

	get definition is override
		return _definition

	get memberDefinition from _definition

	get target from var

	get args from var
		has Subnodes

	get hasError as bool is override
		if base.hasError, return true
		if _target.hasError, return true
		for arg in _args, if arg.hasError, return true
		return false

	get willChangeVar as bool is override
		if _target.willChangeVar, return true
		for arg in _args, if arg.willChangeVar, return true
		return false

	def _bindImp is override
		base._bindImp
		_target.bindImp
		args = _args
		if args.count == 0
			if _target.isKindOf(.compiler.typeType)
				if _target inherits IPotentialTypeExpr and (pt = (_target to IPotentialTypeExpr).potentialType)
					_transformTo(TypeExpr(.token, ArrayType(pt)))
					return					
				else
					.throwError('Unknown array type.')
			else
				.throwError('Invalid index expression or array type.')
		hasArgError = false
		for arg in args
			try
				arg.bindImp
			catch ne as NodeException
				hasArgError = true
				.compiler.recordError(ne)
		target = .target
		if hasArgError or target.hasError
			_type = .compiler.passThroughType
		else if _type is nil
			_definition = target.memberForName(r'[]')  # TODO: will this need to be 'Index' to match DLLs/C#/VB?
			if _definition is nil
				if target.receiverType is .compiler.passThroughType
					_type = .compiler.passThroughType
					return
				if target.receiverType.isDynamic
					_type = .compiler.nilableDynamicType
					return
				.throwError('Cannot find an indexer in "[target.toCobraSource]" whose type is "[target.receiverType.name]".')
			assert _definition
			if _definition inherits MemberOverload
				# TODO
				pass
			else if _definition inherits Indexer
				_bindImpIndexer(args, _definition)
			else
				throw FallThroughException(_definition)
			_type = _definition.resultType
			assert _type
			
	def _bindImpIndexer(args as List<of Expr>, indexer as Indexer)
		#indexer = _definition
		params = indexer.params
		if args.count <> params.count
			.throwError('The method "[_definition.name]" is expecting [params.count] argument[Utils.plural(params)], but [args.count] are being supplied in this call.')
		for i in 0 : args.count
			arg = args[i]
			param = params[i]
			if arg.hasError, break
			assert arg.didBindImp, arg
			assert param.didBindInt, param
			if arg.canBeAssignedTo(param.type)
				arg.contextType = param.type
			else
				if false
					print '<> arg = ' stop
					arg.writeDeepString
					print '<> param = ' stop
					param.writeDeepString
				if arg.type inherits NilableType and not param.type inherits NilableType and arg.type.nonNil.isAssignableTo(param.type)
					.throwError('Argument [i+1] of indexer expects a non-nilable type ([param.type.name]), but the call is supplying a nilable type ([arg.type.name]).')
				else
					.throwError('Argument [i+1] of indexer expects type [param.type.name], but the call is supplying type [arg.type.name].')
						
	def toCobraSource as String is override
		sb = StringBuilder()
		sb.append(_target.toCobraSource)
		sb.append(r'[')
		sep = ''
		for arg in _args
			sb.append(sep)
			sb.append(arg.toCobraSource)
			sep = ', '
		sb.append(']')
		return sb.toString


class IsNilExpr
	is partial
	inherits Expr

	var _expr as Expr

	def init(token as IToken, expr as Expr)
		base.init(token)
		_expr = expr

	get hasError as bool is override
		if base.hasError, return true
		if _expr.hasError, return true
		return false

	get willChangeVar as bool is override
		if _expr.willChangeVar, return true
		return false

	def _bindImp is override
		base._bindImp
		_expr.bindImp
		_type = .compiler.boolType


class IsNotNilExpr
	is partial
	inherits Expr

	var _expr as Expr

	def init(token as IToken, expr as Expr)
		base.init(token)
		_expr = expr

	get hasError as bool is override
		if base.hasError, return true
		if _expr.hasError, return true
		return false

	get willChangeVar as bool is override
		if _expr.willChangeVar, return true
		return false

	def _bindImp is override
		base._bindImp
		_expr.bindImp
		_type = .compiler.boolType

	def toCobraSource as String is override
		return '[_expr.toCobraSource] is not nil'


class MemberExpr
	is partial
	inherits Expr
	implements IDotRightExpr
	"""
	Example members are fields, properties and methods without arguments.

	A trace of .definiton.getType.name at the end of _bindImp gives the set:
		BoxVar
		Class
		EnumMember
		Initializer
		Interface
		MemberOverload
		Method
		NameSpace
		Property

	Presumable Struct could be in there as well.
	
	Note that DotExpr will do some transformations such as Foo.Bar to a TypeExpr if Bar is a type.
	"""

	var _name as String
	var _definition as IMember?
	var _isReference as bool

	def init(token as IToken)
		.init(token, token.text)

	def init(token as IToken, name as String)
		base.init(token)
		_name = name

	def addMinFields is override
		base.addMinFields
		.addField('name', _name)
		.addField('isReference', _isReference)

	get args as List<of Expr>
		return List<of Expr>()

	get definition is override
		return _definition

	get memberDefinition from _definition

	pro isReference from var
		"""
		Returns true if this member expression is a _reference_ to a member instead of an invocation to it.
		This is set by RefExpr and otherwise is false.
		"""

	get isCalling as bool is override
		assert _definition
		return _definition.isMethod

	get name from var

	def _bindImp is override
		base._bindImp
		assert .superNode inherits DotExpr
		assert .binarySuperNode.op == 'DOT'
		assert .binarySuperNode.right is this
		left = .binarySuperNode.left
		if _definition is nil or _type is nil
			if not .binarySuperNode.left.didBindImp
				assert .binarySuperNode.left.hasError, .binarySuperNode.left
				# we get here for Cobra code like "obj.foo.bar" where "foo" is not found
				_type = .compiler.passThroughType
				return
			_definition = .binarySuperNode.left.memberForName(_name)
			if _definition
				_definition.isUsed = true
			else
				if .binarySuperNode.left.receiverType is .compiler.passThroughType
					_type = .compiler.passThroughType
					return
				if .binarySuperNode.left.receiverType.isDynamic
					_type = .compiler.nilableDynamicType
					return
				.throwCannotFindMemberError(left, _name)
			assert _definition
			if _definition inherits IType
				effectiveType as IType = .compiler.typeType  # namespace, class, interface
				receiverType as IType? = _definition
			else if _definition inherits MemberOverload and _definition.name == 'getType'
				# see Box.prepSystemObjectClass
				if .binarySuperNode.left.type.isSystemTypeClass
					sysType = .compiler.typeType
					for member in (_definition to MemberOverload).members
						if member.isShared and member.resultType is sysType
							_definition = member
							break
				effectiveType = _definition.resultType
				receiverType = nil
			else
				effectiveType = _definition.resultType
				receiverType = nil
			_type = effectiveType
			# TODO: there should be a subclass of BinaryOpExpr called DotExpr and it should do the following work and maybe even the work above.
			# TODO: _receiverType = receiverType
			.binarySuperNode.type = .type  # the type of foo.bar is what bar returns. A MemberExpr is the "bar" part.
			.binarySuperNode.receiverType = receiverType
			
			if _definition inherits BoxMember
				_bindImpBoxMember(_definition, left)  # resolve overloads
			else
				# TODO: type access like enum, class, delegate
				pass
		assert _type

	def _bindImpBoxMember(defn as BoxMember, left as Expr)
		# resolve overloads
		if defn inherits MemberOverload
			for member in defn.members
				if member inherits AbstractMethod
					if member.params.count == 0
						_definition = member
						didResolveOverload = true
						break
			if not didResolveOverload
				for member in defn.members 
					if member inherits AbstractMethod
						if member.params.count == 1 and member.params[0].type inherits VariType
							_definition = member
							didResolveOverload = true
							break
			if not didResolveOverload
				.throwError('Could not find an overload for "[.name]" with zero arguments.')
		# check visibility: public, protected, private, internal
		if defn.isPublic
			pass
		else if defn.isProtected
			if not .compiler.curBox.isDescendantOf(defn.parentBox)
				.throwError('Cannot access protected "[_name]" in "[left.toCobraSource]"[left.whoseTypeIsMessage].')
		else if defn.isPrivate
			if not .compiler.curBox is defn.parentBox
				.throwError('Cannot access private "[_name]" in "[left.toCobraSource]"[left.whoseTypeIsMessage].')
		else if defn.isInternal
			# TODO
			pass
			
	def toCobraSource as String is override
		return _name


class OldExpr
	is partial
	inherits Expr
	"""
	The `old` expression used in contracts such as:
		ensure .count == old .count + 1
	"""

	var _expr as Expr

	def init(token as IToken, expr as Expr)
		base.init(token)
		_expr = expr

	get name as String
		return 'old'

	get hasError as bool is override
		if base.hasError, return true
		if _expr.hasError, return true
		return false

	get willChangeVar as bool is override
		if _expr.willChangeVar, return true
		return false

	def addSubFields is override
		base.addSubFields
		.addField('expr', _expr)

	def _bindImp is override
		base._bindImp
		.curCodeMember.addOldExpr(this)  # will set the sharpVarName
		_expr.bindImp
		_type = _expr.type
		assert _type


class PostCallExpr
	is partial
	inherits Expr
	"""
	Covers cases like:
		Car()
		someDelegate()
		obj[i]('x')
		String[](10)
		Foo.Bar.Baz[](0)

	For "bar.foo('x')" that's a binary dot expression with a CallExpr on the right hand side.
	
	Some transformations are required. For example, the parser creates a PostCallExpr for these:
		EnumType(EnumMember1, EnumMember2) -- should be: EnumCallExpr
		_method(arg1, arg2) -- should be: DotExpr containing a CallExpr
	"""

	shared
	
		def isTargetAcceptable(expr as Expr) as bool
			"""
			Returns true if the given expression can be called.
			That currently includes TypeExpr, IndexExpr and IdentifierExpr.
			Do not pass expressions that fail this test to the PostCallExpr init.
			"""
			return expr inherits TypeExpr or expr inherits IndexExpr or expr inherits IdentifierExpr

	var _expr as Expr
	var _args as List<of Expr>
	var _hasKeywordArg as bool  # such as Foo(1, a=2)
	var _isForAttribute as bool  # see Attributes.cobra
	var _helperMethod as Method?

	def init(token as IToken, expr as Expr, args as List<of Expr>)
		require .isTargetAcceptable(expr)
		base.init(token)
		_expr = expr
		_args = args

	def addSubFields is override
		base.addSubFields
		.addField('expr', _expr)
		.addField('args', _args)
		.addField('hasKeywordArg', .hasKeywordArg)
		.addField('isForAttribute', .isForAttribute)

	get expr from var

	get args from var
		has Subnodes

	get hasKeywordArg from var

	pro isForAttribute from var

	get hasError as bool is override
		if base.hasError, return true
		if _expr.hasError, return true
		for arg in _args, if arg.hasError, return true
		return false

	get name as String
		e = .expr
		if e inherits IdentifierExpr, return e.name
		assert .didBindImp
		if e inherits TypeExpr, return e.realType.name
		if e inherits IndexExpr, return e.toCobraSource
		throw FallThroughException(e)

	get willChangeVar as bool is override
		if _expr.willChangeVar, return true
		for arg in _args, if arg.willChangeVar, return true
		return false

	def replaceChild(find as INode, replace as INode) as bool
		# Because _bindImp invokes .bindImp directly on the .right of an AssignExpr argument,
		# the base class thinks this PostCallExpr is the super node and fails to find a child to replace.
		# The real super node is the AssignExpr whose .bindImp was skipped because it's not
		# a true AssignExpr--it's just syntax for init'ing properties during instance creation.
		r = base.replaceChild(find, replace)
		if not r
			for arg in .args
				if arg inherits AssignExpr
					r = arg.replaceChild(find, replace)
					if r, break
		return r

	def _bindImp is override
		base._bindImp
		expr = .expr

		if expr inherits IdentifierExpr
			if expr.name.startsWith('_') and not .compiler.symbolForName(expr.name, true, false) inherits BoxVar
				# method invocation
				# _foo(x) --> ._foo(x)
				newCall = CallExpr(.token, .name, .args, true)
				dotted = DotExpr(.token, 'DOT', ThisLit(.token, isImplicit=true), newCall, isImplicit=true).bindImp
				_type = dotted.type to IType
				_transformTo(dotted)
				return

		expr = expr.bindImp

		if expr.definition inherits EnumDecl
			enumCall = EnumCallExpr(.token, expr.toCobraSource, .args, expr.definition to EnumDecl).bindImp  # CC: axe cast
			_type = enumCall.type to IType
			_transformTo(enumCall)
			return

		for arg in .args
			try
				if arg inherits AssignExpr
					_hasKeywordArg = true
					if not arg.left inherits IdentifierExpr
						.recordError('General purpose assignments are not allowed as arguments. Assignment syntax can only be used for keyword arguments.')
					else if not expr.receiverType.isDynamicOrPassThrough
						propertyName = (arg.left to IdentifierExpr).name
						if expr.memberForName(propertyName) is nil
							.recordCannotFindMemberError(expr, propertyName)
					arg.right.bindImp  # 'x=y' has special treatment in arguments
				else
					if _hasKeywordArg
						.throwError('Cannot have a non-keyword argument ("[arg.toCobraSource]") after a keyword argument. All positional arguments must come before all keyword arguments.')
					arg.bindImp
			catch ne as NodeException
				.compiler.recordError(ne)

		if expr inherits TypeExpr
			# instantiation
			assert expr.containedType
			_type = expr.containedType
		else if expr inherits IndexExpr
			pass
		else if expr inherits IdentifierExpr
			pass
		else
			# one example where this happened: x to SomeType()
			# which yielded: PostCallExpr(expr=ToExpr(...))
			# TODO: can probably make this an error now
			assert false, _expr

		if _type is nil
			assert expr.type is not nil
			exprType = expr.type.nonNil
			if exprType inherits MethodSig
				_type = exprType.returnType
			else if exprType.isDescendantOf(.compiler.delegateType)
				member = exprType.memberForName('invoke')
				if member inherits Method
					_type = member.resultType
				else
					.throwError('Cannot find a single "invoke" method for "_eventType.name".')
			else if expr.receiverType and expr.receiverType.isSystemTypeClass
				_type = .compiler.dynamicType
			else if exprType inherits Box
				_type = expr.receiverType  # for example, an IdentifierExpr of 'SomeClass' has a .receiverType of that class
			else if exprType.isDynamic
				_type = .compiler.nilableDynamicType
			else
				assert false, expr

		if .hasKeywordArg and not .isForAttribute and not .hasError
			_makeHelperMethod
			
	def _makeHelperMethod
		"""
		Add a private helper method to the current box to support extended initializer.

		Foo(expr0, expr1, bar=expr2) -->
			call:
				_ch_ext_init_1207(expr0, expr1, expr2)
			def:
				def _ch_ext_init_1207(arg0 as int, arg1 as int, /#bar=#/arg2 as int)
					obj = Foo(arg0, arg1)
					obj.bar = arg2
					return obj
		"""
		box = .compiler.curBox
		token = box.token.copy
		paramsForDecl = List<of Param>()
		argsForInitCall = List<of Expr>()  # args to pass to `Foo(arg0, arg1)`
		propsToSet = List<of AssignExpr>()  # props to set as `obj.bar = arg2` etc.
		firstPropArg = -1
		i = 0
		for arg in .args
			if arg inherits AssignExpr
				propsToSet.add(arg)
				if firstPropArg == -1, firstPropArg = i
				arg = arg.right
			else
				argsForInitCall.add(if(arg inherits NilLiteral, arg, IdentifierExpr(token.copy('ID', 'arg[i]'))))
			paramsForDecl.add(Param(box.token.copy('ID', 'arg[i]'), arg.type))
			i += 1
		name = '_ch_ext_init_[.serialNum]'  # ch = class helper, ext = extended, init = initializer
		m = Method(token.copy('ID', name), box, name, paramsForDecl, _type, nil, ['shared', 'private'], AttributeList(), '', isCompilerGenerated=true)
		m.locals.add(LocalVar(token.copy('ID', 'obj'), .type))

		objId = IdentifierExpr(token.copy('ID', 'obj'), 'obj')
		callExpr = PostCallExpr(token.copy('ID', .type.name), IdentifierExpr(token.copy('ID', .type.name), .type), argsForInitCall)
		assign = AssignExpr(token.copy('ASSIGN', '='), 'ASSIGN', objId, callExpr)
		m.addStmt(assign)

		i = firstPropArg
		for propSetExpr in propsToSet
			propName = (propSetExpr.left to IdentifierExpr).name
			memberExpr = DotExpr(token.copy('DOT', '.'), 'DOT', IdentifierExpr(token.copy('ID', 'obj')), MemberExpr(token.copy('ID', propName)))
			assign = AssignExpr(token.copy('ASSIGN', '='), 'ASSIGN', memberExpr, IdentifierExpr(token.copy('ID', 'arg[i]')))
			m.addStmt(assign)
			i += 1

		retStmt = ReturnStmt(token.copy('RETURN', 'return'), IdentifierExpr(token.copy('ID', 'obj'), 'obj'))
		m.addStmt(retStmt)

		if .compiler.isBindingInt, m.bindInt  # happens for: var foo = Bar(baz=1)
		else, m.bindAll
		box.addDecl(m)
		_helperMethod = m

	def toCobraSource as String is override
		sb = StringBuilder()
		sb.append(_expr.toCobraSource)
		sb.append('(')
		sep = ''
		for arg in .args
			sb.append(sep)
			sb.append(arg.toCobraSource)
			sep = ', '
		sb.append(')')
		return sb.toString


class RefExpr
	is partial
	inherits Expr
	"""
	A `ref` expression is used to refer to a method without invoking it:
		ref obj.foo
		ref _foo
	"""

	var _expr as Expr
	
	def init(token as IToken, expr as Expr)
		base.init(token)
		_expr = expr

	def addSubFields
		base.addSubFields
		.addField('expr', _expr)

	get expr from var

	get hasError as bool is override
		if base.hasError, return true
		if _expr.hasError, return true
		return false

	get willChangeVar as bool is override
		if _expr.willChangeVar, return true
		return false

	def _bindImp is override
		base._bindImp
		try
			_expr.bindImp
		catch ne as NodeException
			if ne inherits NodeMultiException
				if ne.exceptions.count == 1
					ne = ne.exceptions[0]
			if 'not find an overload' in ne.message
				pass  # Tests\220-delegates-etc\120-events\110-listen-ref-overload.cobra
			else
				throw
		if _expr inherits DotExpr
			right = _expr.right
			if right inherits MemberExpr
				if right.definition is nil
					# happens from error recovery such as: obj = BadClassName() ... ref obj.foo
					pass
				else if right.definition inherits AbstractMethod or right.definition inherits MemberOverload
					right.isReference = true
				else
					.throwError('Only methods can be referenced, not [right.definition.englishName].')
			else if right inherits CallExpr
				.throwError('Cannot call a method that is preceded by `ref`.')
			else
				throw FallThroughException([this, _expr, right])
		else if _expr inherits IdentifierExpr
			if _expr.definition inherits AbstractMethod
				pass
			else
				.throwError('Only methods can be referenced, not [Utils.pluralize(_expr.definition.englishName)].')
		else
			.throwError('Unexpected reference. Refer to methods after `ref` or remove `ref`.')
		_type = .compiler.passThroughType # TODO: Set a real type such as .compiler.delegateType
		# TODO: need to do something more sophisticated like overriding: 	def canBeAssignedTo(type as IType) as bool

	def toCobraSource as String is override
		return 'ref ' + _expr.toCobraSource


class SharpExpr
	is partial
	inherits Expr

	var _expr as StringLit?
	var _sharpSource as String?

	def init(token as IToken, sharpSource as String)
		base.init(token)
		_sharpSource = sharpSource

	def init(token as IToken, expr as Expr)
		base.init(token)
		if expr inherits StringLit  # TODO:? make this an arg type
			_expr = expr
		else
			assert false, r'$sharp expression must be a String Literal (No substitutions) expr=[expr]'

	get sharpSource from var
	
	get expr from var

	get hasError as bool is override
		if base.hasError, return true
		if _expr and _expr.hasError, return true
		return false

	def toCobraSource as String is override
		if _sharpSource
			quote = if(.token.text.startsWith('sharp"'), '"', "'")
			return "sharp[quote][_sharpSource][quote]"
		else
			return "$sharp('[_expr.toCobraSource]')"

	def _bindImp is override
		base._bindImp
		_type = .compiler.passThroughType
		if _expr
			_expr.bindImp


class SliceExpr
	is partial
	inherits Expr
	"""
	Just like Python slices.
	"""

	var _target as Expr
	var _start as Expr?
	var _stop as Expr?
	var _step as Expr?

	def init(token as IToken, target as Expr, start as Expr?, stopp as Expr?, stepp as Expr?)
		base.init(token)
		_target = target
		_start = start
		_stop = stopp
		_step = stepp

	def addSubFields
		base.addSubFields
		.addField('target', _target)
		.addField('start', _start)
		.addField('stop', _stop)
		.addField('step', _step)

	get hasError as bool is override
		if base.hasError, return true
		if _target.hasError, return true
		if _start and _start.hasError, return true
		if _stop and _stop.hasError, return true
		if _step and _step.hasError, return true
		return false

	get willChangeVar as bool is override
		if _target.willChangeVar, return true
		if _start and _start.willChangeVar, return true
		if _stop and _stop.willChangeVar, return true
		if _step and _step.willChangeVar, return true
		return false

	def _bindImp
		base._bindImp
		intType = .compiler.intType
		try
			_target.bindImp
		catch ne as NodeException
			.compiler.recordError(ne)
		success
			if not _target.type.isSequenceLike
				.throwError('Cannot slice values of type "[_target.type.name]". You can slice strings, arrays, IList and IList<of>.')
		if _start
			try
				_start.bindImp
			catch ne as NodeException
				.compiler.recordError(ne)
			success
				if _start.type.isDynamic
					_start.contextType = intType
				else if not _start.isKindOf(intType)
					_start.recordError('The start index of the slice is type "[_start.type.name]", but should be "int".')
		if _stop
			try
				_stop.bindImp
			catch ne as NodeException
				.compiler.recordError(ne)
			success
				if _stop.type.isDynamic
					_stop.contextType = intType
				else if not _stop.isKindOf(intType)
					_stop.recordError('The stop index of the slice is type "[_stop.type.name]", but should be "int".')
		if _step
			try
				_step.bindImp
			catch ne as NodeException
				.compiler.recordError(ne)
			success
				if _step.type.isDynamic
					_step.contextType = intType
				else if not _step.isKindOf(intType)
					_step.recordError('The step of the slice is type "[_step.type.name]", but should be "int".')
		if _target.hasError
			_type = .compiler.passThroughType
		else
			_type = _target.type

	def toCobraSource as String is override
		sb = StringBuilder()
		sb.append(_target.toCobraSource)
		sb.append(r'[')
		if _start
			sb.append(_start.toCobraSource)
		sb.append(':')
		if _stop
			sb.append(_stop.toCobraSource)
		if _step
			sb.append(':')
			sb.append(_step.toCobraSource)
		sb.append(']')
		return sb.toString


class TruthExpr
	is partial
	inherits Expr
	"""
	A truth expr wraps an expression such that it can be used where a bool is expected in .NET/C#.
	For example, if passed an integer typed expression, the truth expression will wrap it with a
	comparison 0!=expr.
	Statically typed bools are passed straight through.
	The `dynamic` and `dynamic?` types use a run-time service.
	Other nilable types are checked for nil.
	"""

	enum Treatment
		AsIs
		InvokeRuntime
		CompareToNull
		CompareToZero
		CompareToZeroChar
		
	var _expr as Expr
	var _origExpr as Expr
	var _notExpr as UnaryOpExpr?
	var _treatment as Treatment
	
	def init(expr as Expr)
		.init(expr, nil)

	def init(expr as Expr, notExpr as UnaryOpExpr?)
		"""
		Pass the notExpr if the truth expression is the target of the not operator.
		This affects warnings generated by TruthExpr.
		"""
		base.init(expr.token)
		_origExpr = _expr = expr
		_notExpr = notExpr

	def addMinFields is override
		base.addMinFields
		.addField('Treatment', _treatment)

	def addSubFields is override
		base.addSubFields
		.addField('expr', _expr)
		.addField('Treatment', _treatment)

	get expr from var

	get hasError as bool is override
		if base.hasError, return true
		if _expr.hasError, return true
		return false

	get willChangeVar as bool is override
		if _expr.willChangeVar, return true
		if _origExpr.willChangeVar, return true
		# Don't check _notExpr which owns *this* expr:
		# if _notExpr and _notExpr.willChangeVar, return true
		return false

	get notExpr from var

	def _bindImp
		base._bindImp
		_expr.bindImp
		type = _expr.type
		if type is .compiler.boolType
			_treatment = Treatment.AsIs
		else if type inherits AbstractNumberType
			_treatment = Treatment.CompareToZero
		else if _expr inherits NilLiteral
			.compiler.warning(this, 'The value nil will always evaluate to false.')
			_expr = BoolLit(_expr.token, false)
			_expr.bindImp
		else if type inherits NilableType
			if type.nonNil inherits DynamicType or type.nonNil inherits PrimitiveType
				_treatment = Treatment.InvokeRuntime
			else
				_treatment = Treatment.CompareToNull
		else if type inherits DynamicType
			_treatment = Treatment.InvokeRuntime
		else if _expr.isKindOf(.compiler.passThroughType)
			_treatment = Treatment.InvokeRuntime
		else if type.isReference
			_treatment = Treatment.CompareToNull
		else if type inherits CharType
			_treatment = Treatment.CompareToZeroChar
		else if type inherits VoidType
			.throwError('Cannot determine truth because the method does not return a value.')
		else
			throw FallThroughException(this)
		if type.isReference and not type inherits NilableType and not type inherits NilType and not type inherits PassThroughType and not type inherits DynamicType
			hint = 'You can remove the expression'
			if _notExpr
				if _expr.isKindOf(.compiler.stringType)
					hint += ' or check for an empty string.'
				else if type inherits ArrayType
					hint += ' or check for an empty array.'
				else if _expr.isKindOfCollection
					hint += ' or check for an empty collection.'
				else
					hint += '.'
				.compiler.warning(_notExpr, 'The expression "[_notExpr.toCobraSource]" (of type "[type.name]") will never evaluate to false because the expression is not nilable. [hint]')
			else
				if _expr.isKindOf(.compiler.stringType)
					hint += ' or check for non-empty strings with ".length".'
				else if type inherits ArrayType
					hint += ' or check for non-empty arrays with ".length".'
				else if _expr.isKindOfCollection
					hint += ' or check for non-empty collections with ".count".'
				else
					hint += '.'
				.compiler.warning(this, 'The expression "[_expr.toCobraSource]" (of type "[type.name]") will always evaluate to true because it is not nilable. [hint]')
		_type = .compiler.boolType

	def toCobraSource as String is override
		return _origExpr.toCobraSource


class TypeExpr
	is partial
	inherits Expr
	implements IPotentialTypeExpr, ITypeProxy
	"""
	Unlike the other expressions that implement IPotentialType, a TypeExpr always represents a type.
	Hence it implements ITypeProxy as well.
	"""
	
	var _typeNode as ITypeProxy?
	var _containedType as IType?

	def init(token as IToken, typeNode as ITypeProxy)
		base.init(token)
		_typeNode = typeNode

	def init(typeNode as ITypeProxy)
		.init((typeNode to ISyntaxNode).token, typeNode)  # TODO: hmmm this is kind of weird

	def init(token as IToken, type as IType)
		base.init(token)
		_containedType = type
		_receiverType = type

	get definition is override
		return _containedType

	get hasError as bool is override
		return base.hasError or (.typeNode and .typeNode.hasError)

	get containedType from var

	get potentialType as IType?
		return .realType

	get realType as IType
		assert .didBindImp
		assert _containedType
		return _containedType to !
		
	get typeNode from var

	def addRefFields is override
		base.addRefFields
		.addField('containedType', _containedType)

	def addSubFields is override
		base.addSubFields
		.addField('typeNode', _typeNode)

	def toCobraSource as String is override
		assert _containedType
		return _containedType.name

	def _bindImp is override
		base._bindImp
		if not _containedType and _typeNode
			_containedType = _receiverType = _typeNode.realType
		_type = .compiler.typeType


class AllOrAnyExpr
	is abstract, partial
	inherits Expr
	"""
	The base class for AllExpr and AnyExpr which have much in common.
	
	They are unary prefix operators taking something enumerable and returning a bool.
	"""

	var _expr as Expr

	def init(token as IToken, expr as Expr)
		base.init(token)
		_expr = expr

	get opName as String is abstract

	get expr from var

	get hasError as bool
		if base.hasError, return true
		if .expr.hasError, return true
		return false

	get willChangeVar as bool is override
		if base.willChangeVar, return true
		if .expr.willChangeVar, return true
		return false

	def addSubFields is override
		base.addSubFields
		.addField('expr', _expr)

	def toCobraSource as String is override
		return '[.opName] [.expr.toCobraSource]'

	def _bindImp
		base._bindImp
		_type = .compiler.boolType
		_expr.bindImp
		enumerable = .compiler.enumerableType
		if _expr.type.isDescendantOf(enumerable)
			pass
		else if _expr.type.isDynamic
			_expr.contextType = enumerable
		else
			.throwError('Expecting an enumerable expression after "[.opName]", but got an expression of type "[.expr.type.name]".')


class AllExpr
	is partial
	inherits AllOrAnyExpr
	"""
	all <enumerable> --> true if all elements are true
	"""
	
	def init(token as IToken, expr as Expr)
		base.init(token, expr)

	get opName as String is override
		return 'all'
	

class AnyExpr
	is partial
	inherits AllOrAnyExpr
	"""
	any <enumerable> --> true if any element is true
	"""
	
	def init(token as IToken, expr as Expr)
		base.init(token, expr)

	get opName as String is override
		return 'any'


class UnaryOpExpr
	is partial
	inherits Expr

	var _op as String
	var _expr as Expr

	def init(token as IToken, op as String, expr as Expr)
		require op in ['MINUS', 'PLUS', 'NOT', 'TILDE']
		base.init(token)
		_op = op
		_expr = expr

	def addMinFields
		base.addMinFields
		.addField('op', _op)

	def addSubFields
		base.addSubFields
		.addField('expr', _expr)

	get hasError as bool is override
		if base.hasError, return true
		if _expr.hasError, return true
		return false

	get willChangeVar as bool is override
		if _expr.willChangeVar, return true
		return false

	get op from var

	get expr from var

	def _bindImp is override
		base._bindImp
		op = .op
		expr = _expr
		expr.bindImp
		if _type is nil, _type = _expr.type
		branch op
			on 'MINUS', _type = expr.type
			on 'PLUS',  _type = expr.type
			on 'TILDE', _type = expr.type
			on 'NOT'
				if expr.type is not .compiler.boolType
					_expr = TruthExpr(expr, this).bindAll to TruthExpr
					_type = .compiler.boolType
			else
				throw FallThroughException(op)

		if op in ['MINUS', 'PLUS']  # TODO: 'TILDE' for ints?
			if expr inherits AtomicLiteral
				if expr.isNumeric
					token = expr.token.copy
					branch op
						on 'PLUS',  pass
						on 'MINUS', token.value = -(token.value to dynamic)
						else, throw FallThroughException(op)
					nodeType = expr.getType
					expr = nodeType(token).bindAll to Expr
					_transformTo(expr)

	def toCobraSource as String is override
		branch _op
			on 'MINUS', op = '-'
			on 'PLUS',  op = '+'
			on 'TILDE', op = '~'
			on 'NOT',   op = 'not '
			else, throw FallThroughException(_op)
		return op + _expr.toCobraSource


##
## Literals
##

class Literal
	is partial
	inherits Expr

	def init(token as IToken)
		base.init(token)


class AtomicLiteral
	is partial
	inherits Literal

	var _text as String

	def init(token as IToken)
		base.init(token)
		_text = token.text

	get isNumeric as bool
		"""
		Returns true if the literal is numeric such that + and - could apply to it.
		The default implementation returns false.
		"""
		return false

	def bindImp as dynamic is override
		base.bindImp
		.checkType
		return .bindImpResult

	def checkType
		assert _type, this

	def _bindImp is override
		base._bindImp

	def toCobraSource as String is override
		return _text


class BoolLit
	is partial
	inherits AtomicLiteral

	var _value as bool

	def init(token as IToken)
		require token.text in ['true', 'false']
		base.init(token)
		_value = token.text=='true'

	def init(token as IToken, value as bool)
		base.init(token)
		_value = value

	def _bindImp is override
		base._bindImp
		_type = .compiler.boolType


class CharLit
	is partial
	inherits AtomicLiteral

	var _value as String  # TODO: should probably be char

	def init(token as IToken)
		require
			token.which in ['CHAR_LIT_SINGLE', 'CHAR_LIT_DOUBLE']
			token.value inherits String
		body
			base.init(token)
			_value = token.value to String

	def _bindImp is override
		base._bindImp
		_type = .compiler.charType


class DecimalLit
	is partial
	inherits AtomicLiteral

	var _value as decimal

	def init(token as IToken)
		require token.value inherits decimal
		base.init(token)
		_value = token.value to decimal

	get isNumeric as bool is override
		return true

	def _bindImp is override
		base._bindImp
		_type = .compiler.decimalType


class FractionalLit
	is partial
	inherits AtomicLiteral

	var _value as decimal

	def init(token as IToken)
		require token.value inherits decimal
		base.init(token)
		_value = token.value to decimal

	get isNumeric as bool is override
		return true

	get value from var

	def _bindImp is override
		base._bindImp
		_type = .compiler.numberType


class FloatLit
	is partial
	inherits AtomicLiteral

	var _value as float

	def init(token as IToken)
		require token.value inherits float
		base.init(token)
		_value = token.value to float

	get isNumeric as bool is override
		return true

	def _bindImp is override
		base._bindImp
		_type = if(.token.info inherits int, .compiler.floatType(.token.info to int), .compiler.floatType)


class IntegerLit
	is partial
	inherits AtomicLiteral

	var _value as int

	def init(token as IToken)
		require token.value inherits int
		base.init(token)
		_value = token.value to int

	def init(token as IToken, value as int)
		base.init(token)
		_value = value

	get isNumeric as bool is override
		return true

	get value from var

	def canBeAssignedTo(type as IType) as bool is override
		if type.isDescendantOf(.compiler.anyIntType)
			# TODO: check that the literal fits in the range of the type
			return true
		else
			return base.canBeAssignedTo(type)

	def _bindImp is override
		base._bindImp
		if .token.info inherits int
			size = .token.info to int
			signed = size < 0
			size = if(signed, -1, +1) * size
			_type = .compiler.intType(signed, size)
		else
			_type = .compiler.intType


class NilLiteral
	is partial
	inherits AtomicLiteral

	def init(token as IToken)
		base.init(token)

	def _bindImp is override
		base._bindImp
		_type = .compiler.nilType


class StringLit
	is partial
	inherits AtomicLiteral

	var _string as String  # String contents (with no surrounding quotes or escaping)

	def init(token as IToken)
		require token.which.startsWith('STRING')
		base.init(token as IToken)
		_string = token.value to String

	get string from var

	def _bindInt is override
		if not _type
			_type = .compiler.stringType
		base._bindInt

	def _bindImp is override
		if not _type
			_type = .compiler.stringType
		base._bindImp

	def toCobraSource as String is override
		return .token.text


class StringSubstLit
	is partial
	inherits Literal

	var _items as List<of Expr>

	def init(items as List<of Expr>)
		require items.count
		base.init(items[0].token)
		if true
			_items = items
		else
			# TODO: the efficient, but not debugged case
			# CC: potential
			# _items = for item in items if not item inherits StringLit or item.string get item
			_items = List<of Expr>()
			for item in _items
				if item inherits StringLit and not (item to StringLit).string.length
					continue
				_items.add(item)
			assert _items.count

	def addSubFields is override
		base.addSubFields
		.addField('items', _items)

	get items from var
		has Subnodes

	get hasError as bool is override
		if base.hasError
			return true
		for item in _items
			if item.hasError
				return true
		return false

	def toCobraSource as String is override
		sb = StringBuilder()
		for item in _items
			if item inherits StringLit
				sb.append(item.token.text)
			else
				sb.append(item.toCobraSource)
		return sb.toString

	def _bindImp is override
		base._bindImp
		for item in _items
			try
				item.bindImp
			catch ne as NodeException
				.compiler.recordError(ne)
		if not _type
			_type = .compiler.stringType


class FormattedExpr
	inherits Expr
	"""
	This is used exclusively for string substitutions that have formatting:
		'[i:N]'
	"""

	var _expr as Expr
	var _format as String

	def init(expr as Expr, format as String)
		base.init(expr.token)
		_expr = expr
		_format = format

	get expr from var

	get format from var

	get hasError as bool is override
		if base.hasError, return true
		if _expr.hasError, return true
		return false

	def toCobraSource as String is override
		return '[_expr.toCobraSource]:[_format]'

	def _bindImp is override
		base._bindImp
		_expr.bindImp
		_type = .compiler.stringType


class ThisOrBaseLit
	is abstract
	inherits AtomicLiteral
	"""
	The "current box" used to be passed to .init rather than referenced in _bindImp, but that
	didn't work well with partial classes. Also, it's not necessary to creating a ThisOrBaseLit.
	"""

	def init(token as IToken)
		base.init(token)

	def _bindImp
		base._bindImp
		_type = .compiler.curBox
		if _type inherits Extension
			_type = _type.extendedBox


class BaseLit
	is partial
	inherits ThisOrBaseLit

	def init(token as IToken)
		base.init(token)

	def checkType is override
		pass

	def memberForName(name as String) as IMember? is override
		assert .didBindImp
		assert _type
		t = .receiverType
		if t.superType
			t = t.superType
		return t.memberForName(name)

	def toCobraSource as String is override
		return 'base'


class ThisLit
	is partial
	inherits ThisOrBaseLit

	# TODO: somewhere it has to be error checked that you're not assigning to
	# "this" (unless C# allows that which I doubt)

	def init(token as IToken)
		base.init(token)

	get isExplicit as bool
		"""
		Returns true if the `this` literal was explicitly present as in `this.foo` vs. implicitly present as in `.foo`.
		"""
		return .token.which == 'THIS'

	def toCobraSource as String is override
		return 'this'


class VarLit
	is partial
	inherits AtomicLiteral

	var _propertyMember as ProperDexerXetter?
	var _name as String
	var _var as IVar?

	def init(token as IToken, propertyMember as ProperDexerXetter)
		base.init(token)
		_propertyMember = propertyMember
		_name = '_'+propertyMember.parent.name

	def _bindImp is override
		possible = _propertyMember.parent.parentBox.symbolForName(_name, true)
		if possible is nil
			.throwError('Cannot find a class variable named "[_name]".')
		else if possible inherits IVar
			_var = possible
		else
			assert false, possible
		_type = _var.type
		_propertyMember = nil  # don't need this reference anymore
		base._bindImp


class CompositeLiteral
	inherits Literal

	def init(token as IToken)
		base.init(token)


class SequenceLit
	is abstract, partial
	inherits CompositeLiteral

	var _exprs as List<of Expr>

	def init(token as IToken, exprs as List<of Expr>)
		base.init(token)
		_exprs = exprs

	def addSubFields is override
		base.addSubFields
		.addField('exprs', _exprs)

	get exprs from var
		has Subnodes

	get hasError as bool is override
		if base.hasError, return true
		for expr in _exprs, if expr.hasError, return true
		return false

	get willChangeVar as bool is override
		for expr in _exprs, if expr.willChangeVar, return true
		return false

	def _bindImp is override
		base._bindImp
		exceptions = List<of NodeException>()
		for expr in _exprs
			try
				expr.bindImp
			catch ne as NodeException
				exceptions.add(ne)
		if exceptions.count
			throw NodeMultiException(exceptions)
		if _type is nil
			exprs = _exprs
			if exprs.count == 0
				type = .compiler.nilableDynamicType to IType
			else
				type = exprs[0].type to !
				i = 1
				while i < exprs.count
					exprs[i].bindImp
					type = exprs[i].type.greatestCommonDenominatorWith(type)
					i += 1
				# TODO: get rid of this hack:
				if type.getType.name=='CobraType'
					type = .compiler.objectType
			_type = _makeTypeWith(type)

	def _makeTypeWith(type as IType) as IType is abstract

	get brackets as List<of String> is abstract

	def toCobraSource as String is override
		brackets = .brackets
		sb = StringBuilder(brackets[0])
		sep = ''
		for expr in _exprs
			sb.append(sep)
			sb.append(expr.toCobraSource)
			sep = ', '
		sb.append(brackets[1])
		return sb.toString


class ListLit
	is partial
	inherits SequenceLit

	# CC: should just inherit this because no initializers are defined
	def init(token as IToken, exprs as List<of Expr>)
		base.init(token, exprs)

	def _makeTypeWith(type as IType) as IType is override
		return .compiler.listOfType.constructedTypeFor([type])

	get brackets as List<of String> is override
		return [r'[', ']']


class ArrayLit
	is partial
	inherits SequenceLit

	# CC: should just inherit this because no initializers are defined
	def init(token as IToken, exprs as List<of Expr>)
		base.init(token, exprs)

	def _makeTypeWith(type as IType) as IType is override
		return ArrayType(type)

	get brackets as List<of String> is override
		return [r'@[', ']']


class SetLit
	is partial
	inherits SequenceLit
	"""
	Sets aren't exactly sequences although they appear that way in source code which itself is a sequence of characters.
	Like lists, sets have one generic type param.

	Hence it's convenient to inherit SequenceLit, the base class for ListLit and ArrayLit as well.

	Examples:
		{1, 2, 3}
		{'Cobra', 'Python'}
		{1, Object(), 'Car'}
		{,}
	"""

	def init(token as IToken, exprs as List<of Expr>)
		base.init(token, exprs)

	def _makeTypeWith(type as IType) as IType is override
		return .compiler.setOfType.constructedTypeFor([type])

	get brackets as List<of String> is override
		return [r'{', '}']

	
class DictLit
	is partial
	inherits CompositeLiteral

	var _entries as List<of List<of Expr>>

	def init(token as IToken, entries as List<of List<of Expr>>)
		base.init(token)
		if CobraCore.willCheckAssert
			for entry in entries
				assert entry.count == 2
		_entries = entries

	def addSubFields is override
		base.addSubFields
		.addField('entries', _entries)

	get hasError as bool is override
		if base.hasError
			return true
		for entry in _entries
			for expr in entry
				if expr.hasError
					return true
		return false

	get willChangeVar as bool is override
		for entry in _entries
			for expr in entry
				if expr.willChangeVar
					return true
		return false

	def replaceChild(find as INode, replace as INode) as bool
		didReplace = base.replaceChild(find, replace)
		if replace inherits Expr
			for entry in _entries
				if entry[0] is find
					entry[0] = replace
					didReplace = true
				if entry[1] is find
					entry[1] = replace
					didReplace = true
		return didReplace

	def _bindImp is override
		base._bindImp
		hadError = false
		for entry in _entries
			try
				entry[0].bindImp
			catch ne as NodeException
				.compiler.recordError(ne)
				hadError = true
			try
				entry[1].bindImp
			catch ne as NodeException
				.compiler.recordError(ne)
				hadError = true
		if hadError
			return
		if .type is nil
			entries = _entries
			if _entries.count == 0
				keyType = valueType = .compiler.nilableDynamicType to IType
			else
				keyType   = entries[0][0].type to !
				valueType = entries[0][1].type to !
				i = 1
				while i<entries.count
					keyType   = entries[i][0].type.greatestCommonDenominatorWith(keyType)
					valueType = entries[i][1].type.greatestCommonDenominatorWith(valueType)
					i += 1
			_type = .compiler.dictionaryOfType.constructedTypeFor([keyType, valueType])


class ToNilableOrNotExpr
	is abstract, partial
	inherits Expr
	"""
	The abstract base class for ToNilableExpr and ToNonNilableExpr which have much in common.
	"""
	
	var _rightTok as IToken
	var _expr as Expr

	def init(opToken as IToken, rightTok as IToken, expr as Expr)
		base.init(opToken)
		_rightTok = rightTok
		_expr = expr

	get rightTok from var
	
	get expr from var

	def _bindImp
		base._bindImp
		_expr.bindImp

	get hasError as bool is override
		if base.hasError, return true
		if _expr.hasError, return true
		return false

	get willChangeVar as bool is override
		if _expr.willChangeVar, return true
		return false

	def toCobraSource as String is override
		sb = StringBuilder()
		sb.append(_expr.toCobraSource)
		sb.append(' to ')
		sb.append(_rightTok.text)
		return sb.toString


class ToNilableExpr
	is partial
	inherits ToNilableOrNotExpr
	"""
	Casts an expression to the nilable version of its type.
	
	When coding in Cobra:

	You would do this primarily when the expression is on the right hand side of an assignment and
	you want the left hand var to by implicitly typed as nilable so you can assign nil to it later.
	
	ex: name = obj.name to ?
	ex: age = customer.age to ?
	"""
	
	def init(opToken as IToken, rightTok as IToken, expr as Expr)
		base.init(opToken, rightTok, expr)

	def _bindImp
		base._bindImp
		if _expr.type inherits NilableType
			_type = _expr.type
			.compiler.warning(this, 'The given expression is already nilable so "to ?" is redundant. You can remove it.')  # TODO: needs test case
		else
			_type = NilableType(_expr.type)


class ToNonNilableExpr
	is partial
	inherits ToNilableOrNotExpr
	"""
	Casts an expression to the non-nilable version of its type.
	
	When coding in Cobra:

	You would do this when trying to use a nilable expression where a non-nil type is expected and
	you know that at run-time the expression won't actually by nil (presumably due to the logic of
	your code).
	
	Or you might do this to affect type inference.
	
	ex: name = obj.name to !
	ex: obj.foo(age to !)
	"""
	
	def init(opToken as IToken, rightTok as IToken, expr as Expr)
		base.init(opToken, rightTok, expr)

	def _bindImp
		base._bindImp
		if (et = _expr.type) inherits NilableType
			_type = et.nonNil
		else
			.compiler.warning(this, 'The given expression is already non-nilable so "to !" is redundant. You can remove it.') # TODO: needs test case
			_type = _expr.type
